require = function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;
                if (!u && a) return a(o, !0);
                if (i) return i(o, !0);
                var f = new Error("Cannot find module '" + o + "'");
                throw f.code = "MODULE_NOT_FOUND", f;
            }
            var l = n[o] = {
                exports: {}
            };
            t[o][0].call(l.exports, function(e) {
                var n = t[o][1][e];
                return s(n ? n : e);
            }, l, l.exports, e, t, n, r);
        }
        return n[o].exports;
    }
    var i = typeof require == "function" && require;
    for (var o = 0; o < r.length; o++) s(r[o]);
    return s;
}({
    1: [ function(require, module, exports) {
        "use strict";
        require("./src/crunch")(window.excludes || []);
    }, {
        "./src/crunch": 117
    } ],
    2: [ function(require, module, exports) {}, {} ],
    3: [ function(require, module, exports) {
        var base64 = require("base64-js");
        var ieee754 = require("ieee754");
        var isArray = require("is-array");
        exports.Buffer = Buffer;
        exports.SlowBuffer = SlowBuffer;
        exports.INSPECT_MAX_BYTES = 50;
        Buffer.poolSize = 8192;
        var kMaxLength = 1073741823;
        var rootParent = {};
        Buffer.TYPED_ARRAY_SUPPORT = function() {
            try {
                var buf = new ArrayBuffer(0);
                var arr = new Uint8Array(buf);
                arr.foo = function() {
                    return 42;
                };
                return arr.foo() === 42 && typeof arr.subarray === "function" && new Uint8Array(1).subarray(1, 1).byteLength === 0;
            } catch (e) {
                return false;
            }
        }();
        function Buffer(subject, encoding) {
            var self = this;
            if (!(self instanceof Buffer)) return new Buffer(subject, encoding);
            var type = typeof subject;
            var length;
            if (type === "number") {
                length = +subject;
            } else if (type === "string") {
                length = Buffer.byteLength(subject, encoding);
            } else if (type === "object" && subject !== null) {
                if (subject.type === "Buffer" && isArray(subject.data)) subject = subject.data;
                length = +subject.length;
            } else {
                throw new TypeError("must start with number, buffer, array or string");
            }
            if (length > kMaxLength) {
                throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + kMaxLength.toString(16) + " bytes");
            }
            if (length < 0) length = 0; else length >>>= 0;
            if (Buffer.TYPED_ARRAY_SUPPORT) {
                self = Buffer._augment(new Uint8Array(length));
            } else {
                self.length = length;
                self._isBuffer = true;
            }
            var i;
            if (Buffer.TYPED_ARRAY_SUPPORT && typeof subject.byteLength === "number") {
                self._set(subject);
            } else if (isArrayish(subject)) {
                if (Buffer.isBuffer(subject)) {
                    for (i = 0; i < length; i++) {
                        self[i] = subject.readUInt8(i);
                    }
                } else {
                    for (i = 0; i < length; i++) {
                        self[i] = (subject[i] % 256 + 256) % 256;
                    }
                }
            } else if (type === "string") {
                self.write(subject, 0, encoding);
            } else if (type === "number" && !Buffer.TYPED_ARRAY_SUPPORT) {
                for (i = 0; i < length; i++) {
                    self[i] = 0;
                }
            }
            if (length > 0 && length <= Buffer.poolSize) self.parent = rootParent;
            return self;
        }
        function SlowBuffer(subject, encoding) {
            if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding);
            var buf = new Buffer(subject, encoding);
            delete buf.parent;
            return buf;
        }
        Buffer.isBuffer = function isBuffer(b) {
            return !!(b != null && b._isBuffer);
        };
        Buffer.compare = function compare(a, b) {
            if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
                throw new TypeError("Arguments must be Buffers");
            }
            if (a === b) return 0;
            var x = a.length;
            var y = b.length;
            for (var i = 0, len = Math.min(x, y); i < len && a[i] === b[i]; i++) {}
            if (i !== len) {
                x = a[i];
                y = b[i];
            }
            if (x < y) return -1;
            if (y < x) return 1;
            return 0;
        };
        Buffer.isEncoding = function isEncoding(encoding) {
            switch (String(encoding).toLowerCase()) {
              case "hex":
              case "utf8":
              case "utf-8":
              case "ascii":
              case "binary":
              case "base64":
              case "raw":
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return true;

              default:
                return false;
            }
        };
        Buffer.concat = function concat(list, totalLength) {
            if (!isArray(list)) throw new TypeError("list argument must be an Array of Buffers.");
            if (list.length === 0) {
                return new Buffer(0);
            } else if (list.length === 1) {
                return list[0];
            }
            var i;
            if (totalLength === undefined) {
                totalLength = 0;
                for (i = 0; i < list.length; i++) {
                    totalLength += list[i].length;
                }
            }
            var buf = new Buffer(totalLength);
            var pos = 0;
            for (i = 0; i < list.length; i++) {
                var item = list[i];
                item.copy(buf, pos);
                pos += item.length;
            }
            return buf;
        };
        Buffer.byteLength = function byteLength(str, encoding) {
            var ret;
            str = str + "";
            switch (encoding || "utf8") {
              case "ascii":
              case "binary":
              case "raw":
                ret = str.length;
                break;

              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                ret = str.length * 2;
                break;

              case "hex":
                ret = str.length >>> 1;
                break;

              case "utf8":
              case "utf-8":
                ret = utf8ToBytes(str).length;
                break;

              case "base64":
                ret = base64ToBytes(str).length;
                break;

              default:
                ret = str.length;
            }
            return ret;
        };
        Buffer.prototype.length = undefined;
        Buffer.prototype.parent = undefined;
        Buffer.prototype.toString = function toString(encoding, start, end) {
            var loweredCase = false;
            start = start >>> 0;
            end = end === undefined || end === Infinity ? this.length : end >>> 0;
            if (!encoding) encoding = "utf8";
            if (start < 0) start = 0;
            if (end > this.length) end = this.length;
            if (end <= start) return "";
            while (true) {
                switch (encoding) {
                  case "hex":
                    return hexSlice(this, start, end);

                  case "utf8":
                  case "utf-8":
                    return utf8Slice(this, start, end);

                  case "ascii":
                    return asciiSlice(this, start, end);

                  case "binary":
                    return binarySlice(this, start, end);

                  case "base64":
                    return base64Slice(this, start, end);

                  case "ucs2":
                  case "ucs-2":
                  case "utf16le":
                  case "utf-16le":
                    return utf16leSlice(this, start, end);

                  default:
                    if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
                    encoding = (encoding + "").toLowerCase();
                    loweredCase = true;
                }
            }
        };
        Buffer.prototype.equals = function equals(b) {
            if (!Buffer.isBuffer(b)) throw new TypeError("Argument must be a Buffer");
            if (this === b) return true;
            return Buffer.compare(this, b) === 0;
        };
        Buffer.prototype.inspect = function inspect() {
            var str = "";
            var max = exports.INSPECT_MAX_BYTES;
            if (this.length > 0) {
                str = this.toString("hex", 0, max).match(/.{2}/g).join(" ");
                if (this.length > max) str += " ... ";
            }
            return "<Buffer " + str + ">";
        };
        Buffer.prototype.compare = function compare(b) {
            if (!Buffer.isBuffer(b)) throw new TypeError("Argument must be a Buffer");
            if (this === b) return 0;
            return Buffer.compare(this, b);
        };
        Buffer.prototype.indexOf = function indexOf(val, byteOffset) {
            if (byteOffset > 2147483647) byteOffset = 2147483647; else if (byteOffset < -2147483648) byteOffset = -2147483648;
            byteOffset >>= 0;
            if (this.length === 0) return -1;
            if (byteOffset >= this.length) return -1;
            if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0);
            if (typeof val === "string") {
                if (val.length === 0) return -1;
                return String.prototype.indexOf.call(this, val, byteOffset);
            }
            if (Buffer.isBuffer(val)) {
                return arrayIndexOf(this, val, byteOffset);
            }
            if (typeof val === "number") {
                if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === "function") {
                    return Uint8Array.prototype.indexOf.call(this, val, byteOffset);
                }
                return arrayIndexOf(this, [ val ], byteOffset);
            }
            function arrayIndexOf(arr, val, byteOffset) {
                var foundIndex = -1;
                for (var i = 0; byteOffset + i < arr.length; i++) {
                    if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {
                        if (foundIndex === -1) foundIndex = i;
                        if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex;
                    } else {
                        foundIndex = -1;
                    }
                }
                return -1;
            }
            throw new TypeError("val must be string, number or Buffer");
        };
        Buffer.prototype.get = function get(offset) {
            console.log(".get() is deprecated. Access using array indexes instead.");
            return this.readUInt8(offset);
        };
        Buffer.prototype.set = function set(v, offset) {
            console.log(".set() is deprecated. Access using array indexes instead.");
            return this.writeUInt8(v, offset);
        };
        function hexWrite(buf, string, offset, length) {
            offset = Number(offset) || 0;
            var remaining = buf.length - offset;
            if (!length) {
                length = remaining;
            } else {
                length = Number(length);
                if (length > remaining) {
                    length = remaining;
                }
            }
            var strLen = string.length;
            if (strLen % 2 !== 0) throw new Error("Invalid hex string");
            if (length > strLen / 2) {
                length = strLen / 2;
            }
            for (var i = 0; i < length; i++) {
                var parsed = parseInt(string.substr(i * 2, 2), 16);
                if (isNaN(parsed)) throw new Error("Invalid hex string");
                buf[offset + i] = parsed;
            }
            return i;
        }
        function utf8Write(buf, string, offset, length) {
            var charsWritten = blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
            return charsWritten;
        }
        function asciiWrite(buf, string, offset, length) {
            var charsWritten = blitBuffer(asciiToBytes(string), buf, offset, length);
            return charsWritten;
        }
        function binaryWrite(buf, string, offset, length) {
            return asciiWrite(buf, string, offset, length);
        }
        function base64Write(buf, string, offset, length) {
            var charsWritten = blitBuffer(base64ToBytes(string), buf, offset, length);
            return charsWritten;
        }
        function utf16leWrite(buf, string, offset, length) {
            var charsWritten = blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
            return charsWritten;
        }
        Buffer.prototype.write = function write(string, offset, length, encoding) {
            if (isFinite(offset)) {
                if (!isFinite(length)) {
                    encoding = length;
                    length = undefined;
                }
            } else {
                var swap = encoding;
                encoding = offset;
                offset = length;
                length = swap;
            }
            offset = Number(offset) || 0;
            if (length < 0 || offset < 0 || offset > this.length) {
                throw new RangeError("attempt to write outside buffer bounds");
            }
            var remaining = this.length - offset;
            if (!length) {
                length = remaining;
            } else {
                length = Number(length);
                if (length > remaining) {
                    length = remaining;
                }
            }
            encoding = String(encoding || "utf8").toLowerCase();
            var ret;
            switch (encoding) {
              case "hex":
                ret = hexWrite(this, string, offset, length);
                break;

              case "utf8":
              case "utf-8":
                ret = utf8Write(this, string, offset, length);
                break;

              case "ascii":
                ret = asciiWrite(this, string, offset, length);
                break;

              case "binary":
                ret = binaryWrite(this, string, offset, length);
                break;

              case "base64":
                ret = base64Write(this, string, offset, length);
                break;

              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                ret = utf16leWrite(this, string, offset, length);
                break;

              default:
                throw new TypeError("Unknown encoding: " + encoding);
            }
            return ret;
        };
        Buffer.prototype.toJSON = function toJSON() {
            return {
                type: "Buffer",
                data: Array.prototype.slice.call(this._arr || this, 0)
            };
        };
        function base64Slice(buf, start, end) {
            if (start === 0 && end === buf.length) {
                return base64.fromByteArray(buf);
            } else {
                return base64.fromByteArray(buf.slice(start, end));
            }
        }
        function utf8Slice(buf, start, end) {
            var res = "";
            var tmp = "";
            end = Math.min(buf.length, end);
            for (var i = start; i < end; i++) {
                if (buf[i] <= 127) {
                    res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i]);
                    tmp = "";
                } else {
                    tmp += "%" + buf[i].toString(16);
                }
            }
            return res + decodeUtf8Char(tmp);
        }
        function asciiSlice(buf, start, end) {
            var ret = "";
            end = Math.min(buf.length, end);
            for (var i = start; i < end; i++) {
                ret += String.fromCharCode(buf[i] & 127);
            }
            return ret;
        }
        function binarySlice(buf, start, end) {
            var ret = "";
            end = Math.min(buf.length, end);
            for (var i = start; i < end; i++) {
                ret += String.fromCharCode(buf[i]);
            }
            return ret;
        }
        function hexSlice(buf, start, end) {
            var len = buf.length;
            if (!start || start < 0) start = 0;
            if (!end || end < 0 || end > len) end = len;
            var out = "";
            for (var i = start; i < end; i++) {
                out += toHex(buf[i]);
            }
            return out;
        }
        function utf16leSlice(buf, start, end) {
            var bytes = buf.slice(start, end);
            var res = "";
            for (var i = 0; i < bytes.length; i += 2) {
                res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
            }
            return res;
        }
        Buffer.prototype.slice = function slice(start, end) {
            var len = this.length;
            start = ~~start;
            end = end === undefined ? len : ~~end;
            if (start < 0) {
                start += len;
                if (start < 0) start = 0;
            } else if (start > len) {
                start = len;
            }
            if (end < 0) {
                end += len;
                if (end < 0) end = 0;
            } else if (end > len) {
                end = len;
            }
            if (end < start) end = start;
            var newBuf;
            if (Buffer.TYPED_ARRAY_SUPPORT) {
                newBuf = Buffer._augment(this.subarray(start, end));
            } else {
                var sliceLen = end - start;
                newBuf = new Buffer(sliceLen, undefined);
                for (var i = 0; i < sliceLen; i++) {
                    newBuf[i] = this[i + start];
                }
            }
            if (newBuf.length) newBuf.parent = this.parent || this;
            return newBuf;
        };
        function checkOffset(offset, ext, length) {
            if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
            if (offset + ext > length) throw new RangeError("Trying to access beyond buffer length");
        }
        Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
            offset = offset >>> 0;
            byteLength = byteLength >>> 0;
            if (!noAssert) checkOffset(offset, byteLength, this.length);
            var val = this[offset];
            var mul = 1;
            var i = 0;
            while (++i < byteLength && (mul *= 256)) {
                val += this[offset + i] * mul;
            }
            return val;
        };
        Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
            offset = offset >>> 0;
            byteLength = byteLength >>> 0;
            if (!noAssert) {
                checkOffset(offset, byteLength, this.length);
            }
            var val = this[offset + --byteLength];
            var mul = 1;
            while (byteLength > 0 && (mul *= 256)) {
                val += this[offset + --byteLength] * mul;
            }
            return val;
        };
        Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
            if (!noAssert) checkOffset(offset, 1, this.length);
            return this[offset];
        };
        Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
            if (!noAssert) checkOffset(offset, 2, this.length);
            return this[offset] | this[offset + 1] << 8;
        };
        Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
            if (!noAssert) checkOffset(offset, 2, this.length);
            return this[offset] << 8 | this[offset + 1];
        };
        Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
            if (!noAssert) checkOffset(offset, 4, this.length);
            return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
        };
        Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
            if (!noAssert) checkOffset(offset, 4, this.length);
            return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
        };
        Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
            offset = offset >>> 0;
            byteLength = byteLength >>> 0;
            if (!noAssert) checkOffset(offset, byteLength, this.length);
            var val = this[offset];
            var mul = 1;
            var i = 0;
            while (++i < byteLength && (mul *= 256)) {
                val += this[offset + i] * mul;
            }
            mul *= 128;
            if (val >= mul) val -= Math.pow(2, 8 * byteLength);
            return val;
        };
        Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
            offset = offset >>> 0;
            byteLength = byteLength >>> 0;
            if (!noAssert) checkOffset(offset, byteLength, this.length);
            var i = byteLength;
            var mul = 1;
            var val = this[offset + --i];
            while (i > 0 && (mul *= 256)) {
                val += this[offset + --i] * mul;
            }
            mul *= 128;
            if (val >= mul) val -= Math.pow(2, 8 * byteLength);
            return val;
        };
        Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
            if (!noAssert) checkOffset(offset, 1, this.length);
            if (!(this[offset] & 128)) return this[offset];
            return (255 - this[offset] + 1) * -1;
        };
        Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
            if (!noAssert) checkOffset(offset, 2, this.length);
            var val = this[offset] | this[offset + 1] << 8;
            return val & 32768 ? val | 4294901760 : val;
        };
        Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
            if (!noAssert) checkOffset(offset, 2, this.length);
            var val = this[offset + 1] | this[offset] << 8;
            return val & 32768 ? val | 4294901760 : val;
        };
        Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
            if (!noAssert) checkOffset(offset, 4, this.length);
            return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
        };
        Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
            if (!noAssert) checkOffset(offset, 4, this.length);
            return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
        };
        Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
            if (!noAssert) checkOffset(offset, 4, this.length);
            return ieee754.read(this, offset, true, 23, 4);
        };
        Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
            if (!noAssert) checkOffset(offset, 4, this.length);
            return ieee754.read(this, offset, false, 23, 4);
        };
        Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
            if (!noAssert) checkOffset(offset, 8, this.length);
            return ieee754.read(this, offset, true, 52, 8);
        };
        Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
            if (!noAssert) checkOffset(offset, 8, this.length);
            return ieee754.read(this, offset, false, 52, 8);
        };
        function checkInt(buf, value, offset, ext, max, min) {
            if (!Buffer.isBuffer(buf)) throw new TypeError("buffer must be a Buffer instance");
            if (value > max || value < min) throw new RangeError("value is out of bounds");
            if (offset + ext > buf.length) throw new RangeError("index out of range");
        }
        Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
            value = +value;
            offset = offset >>> 0;
            byteLength = byteLength >>> 0;
            if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0);
            var mul = 1;
            var i = 0;
            this[offset] = value & 255;
            while (++i < byteLength && (mul *= 256)) {
                this[offset + i] = value / mul >>> 0 & 255;
            }
            return offset + byteLength;
        };
        Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
            value = +value;
            offset = offset >>> 0;
            byteLength = byteLength >>> 0;
            if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0);
            var i = byteLength - 1;
            var mul = 1;
            this[offset + i] = value & 255;
            while (--i >= 0 && (mul *= 256)) {
                this[offset + i] = value / mul >>> 0 & 255;
            }
            return offset + byteLength;
        };
        Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) checkInt(this, value, offset, 1, 255, 0);
            if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
            this[offset] = value;
            return offset + 1;
        };
        function objectWriteUInt16(buf, value, offset, littleEndian) {
            if (value < 0) value = 65535 + value + 1;
            for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
                buf[offset + i] = (value & 255 << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
            }
        }
        Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
            if (Buffer.TYPED_ARRAY_SUPPORT) {
                this[offset] = value;
                this[offset + 1] = value >>> 8;
            } else {
                objectWriteUInt16(this, value, offset, true);
            }
            return offset + 2;
        };
        Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
            if (Buffer.TYPED_ARRAY_SUPPORT) {
                this[offset] = value >>> 8;
                this[offset + 1] = value;
            } else {
                objectWriteUInt16(this, value, offset, false);
            }
            return offset + 2;
        };
        function objectWriteUInt32(buf, value, offset, littleEndian) {
            if (value < 0) value = 4294967295 + value + 1;
            for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
                buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 255;
            }
        }
        Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
            if (Buffer.TYPED_ARRAY_SUPPORT) {
                this[offset + 3] = value >>> 24;
                this[offset + 2] = value >>> 16;
                this[offset + 1] = value >>> 8;
                this[offset] = value;
            } else {
                objectWriteUInt32(this, value, offset, true);
            }
            return offset + 4;
        };
        Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
            if (Buffer.TYPED_ARRAY_SUPPORT) {
                this[offset] = value >>> 24;
                this[offset + 1] = value >>> 16;
                this[offset + 2] = value >>> 8;
                this[offset + 3] = value;
            } else {
                objectWriteUInt32(this, value, offset, false);
            }
            return offset + 4;
        };
        Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) {
                checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength - 1) - 1, -Math.pow(2, 8 * byteLength - 1));
            }
            var i = 0;
            var mul = 1;
            var sub = value < 0 ? 1 : 0;
            this[offset] = value & 255;
            while (++i < byteLength && (mul *= 256)) {
                this[offset + i] = (value / mul >> 0) - sub & 255;
            }
            return offset + byteLength;
        };
        Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) {
                checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength - 1) - 1, -Math.pow(2, 8 * byteLength - 1));
            }
            var i = byteLength - 1;
            var mul = 1;
            var sub = value < 0 ? 1 : 0;
            this[offset + i] = value & 255;
            while (--i >= 0 && (mul *= 256)) {
                this[offset + i] = (value / mul >> 0) - sub & 255;
            }
            return offset + byteLength;
        };
        Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) checkInt(this, value, offset, 1, 127, -128);
            if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
            if (value < 0) value = 255 + value + 1;
            this[offset] = value;
            return offset + 1;
        };
        Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
            if (Buffer.TYPED_ARRAY_SUPPORT) {
                this[offset] = value;
                this[offset + 1] = value >>> 8;
            } else {
                objectWriteUInt16(this, value, offset, true);
            }
            return offset + 2;
        };
        Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
            if (Buffer.TYPED_ARRAY_SUPPORT) {
                this[offset] = value >>> 8;
                this[offset + 1] = value;
            } else {
                objectWriteUInt16(this, value, offset, false);
            }
            return offset + 2;
        };
        Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
            if (Buffer.TYPED_ARRAY_SUPPORT) {
                this[offset] = value;
                this[offset + 1] = value >>> 8;
                this[offset + 2] = value >>> 16;
                this[offset + 3] = value >>> 24;
            } else {
                objectWriteUInt32(this, value, offset, true);
            }
            return offset + 4;
        };
        Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
            if (value < 0) value = 4294967295 + value + 1;
            if (Buffer.TYPED_ARRAY_SUPPORT) {
                this[offset] = value >>> 24;
                this[offset + 1] = value >>> 16;
                this[offset + 2] = value >>> 8;
                this[offset + 3] = value;
            } else {
                objectWriteUInt32(this, value, offset, false);
            }
            return offset + 4;
        };
        function checkIEEE754(buf, value, offset, ext, max, min) {
            if (value > max || value < min) throw new RangeError("value is out of bounds");
            if (offset + ext > buf.length) throw new RangeError("index out of range");
            if (offset < 0) throw new RangeError("index out of range");
        }
        function writeFloat(buf, value, offset, littleEndian, noAssert) {
            if (!noAssert) {
                checkIEEE754(buf, value, offset, 4, 3.4028234663852886e38, -3.4028234663852886e38);
            }
            ieee754.write(buf, value, offset, littleEndian, 23, 4);
            return offset + 4;
        }
        Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
            return writeFloat(this, value, offset, true, noAssert);
        };
        Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
            return writeFloat(this, value, offset, false, noAssert);
        };
        function writeDouble(buf, value, offset, littleEndian, noAssert) {
            if (!noAssert) {
                checkIEEE754(buf, value, offset, 8, 1.7976931348623157e308, -1.7976931348623157e308);
            }
            ieee754.write(buf, value, offset, littleEndian, 52, 8);
            return offset + 8;
        }
        Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
            return writeDouble(this, value, offset, true, noAssert);
        };
        Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
            return writeDouble(this, value, offset, false, noAssert);
        };
        Buffer.prototype.copy = function copy(target, target_start, start, end) {
            if (!start) start = 0;
            if (!end && end !== 0) end = this.length;
            if (target_start >= target.length) target_start = target.length;
            if (!target_start) target_start = 0;
            if (end > 0 && end < start) end = start;
            if (end === start) return 0;
            if (target.length === 0 || this.length === 0) return 0;
            if (target_start < 0) {
                throw new RangeError("targetStart out of bounds");
            }
            if (start < 0 || start >= this.length) throw new RangeError("sourceStart out of bounds");
            if (end < 0) throw new RangeError("sourceEnd out of bounds");
            if (end > this.length) end = this.length;
            if (target.length - target_start < end - start) {
                end = target.length - target_start + start;
            }
            var len = end - start;
            if (len < 1e3 || !Buffer.TYPED_ARRAY_SUPPORT) {
                for (var i = 0; i < len; i++) {
                    target[i + target_start] = this[i + start];
                }
            } else {
                target._set(this.subarray(start, start + len), target_start);
            }
            return len;
        };
        Buffer.prototype.fill = function fill(value, start, end) {
            if (!value) value = 0;
            if (!start) start = 0;
            if (!end) end = this.length;
            if (end < start) throw new RangeError("end < start");
            if (end === start) return;
            if (this.length === 0) return;
            if (start < 0 || start >= this.length) throw new RangeError("start out of bounds");
            if (end < 0 || end > this.length) throw new RangeError("end out of bounds");
            var i;
            if (typeof value === "number") {
                for (i = start; i < end; i++) {
                    this[i] = value;
                }
            } else {
                var bytes = utf8ToBytes(value.toString());
                var len = bytes.length;
                for (i = start; i < end; i++) {
                    this[i] = bytes[i % len];
                }
            }
            return this;
        };
        Buffer.prototype.toArrayBuffer = function toArrayBuffer() {
            if (typeof Uint8Array !== "undefined") {
                if (Buffer.TYPED_ARRAY_SUPPORT) {
                    return new Buffer(this).buffer;
                } else {
                    var buf = new Uint8Array(this.length);
                    for (var i = 0, len = buf.length; i < len; i += 1) {
                        buf[i] = this[i];
                    }
                    return buf.buffer;
                }
            } else {
                throw new TypeError("Buffer.toArrayBuffer not supported in this browser");
            }
        };
        var BP = Buffer.prototype;
        Buffer._augment = function _augment(arr) {
            arr.constructor = Buffer;
            arr._isBuffer = true;
            arr._set = arr.set;
            arr.get = BP.get;
            arr.set = BP.set;
            arr.write = BP.write;
            arr.toString = BP.toString;
            arr.toLocaleString = BP.toString;
            arr.toJSON = BP.toJSON;
            arr.equals = BP.equals;
            arr.compare = BP.compare;
            arr.indexOf = BP.indexOf;
            arr.copy = BP.copy;
            arr.slice = BP.slice;
            arr.readUIntLE = BP.readUIntLE;
            arr.readUIntBE = BP.readUIntBE;
            arr.readUInt8 = BP.readUInt8;
            arr.readUInt16LE = BP.readUInt16LE;
            arr.readUInt16BE = BP.readUInt16BE;
            arr.readUInt32LE = BP.readUInt32LE;
            arr.readUInt32BE = BP.readUInt32BE;
            arr.readIntLE = BP.readIntLE;
            arr.readIntBE = BP.readIntBE;
            arr.readInt8 = BP.readInt8;
            arr.readInt16LE = BP.readInt16LE;
            arr.readInt16BE = BP.readInt16BE;
            arr.readInt32LE = BP.readInt32LE;
            arr.readInt32BE = BP.readInt32BE;
            arr.readFloatLE = BP.readFloatLE;
            arr.readFloatBE = BP.readFloatBE;
            arr.readDoubleLE = BP.readDoubleLE;
            arr.readDoubleBE = BP.readDoubleBE;
            arr.writeUInt8 = BP.writeUInt8;
            arr.writeUIntLE = BP.writeUIntLE;
            arr.writeUIntBE = BP.writeUIntBE;
            arr.writeUInt16LE = BP.writeUInt16LE;
            arr.writeUInt16BE = BP.writeUInt16BE;
            arr.writeUInt32LE = BP.writeUInt32LE;
            arr.writeUInt32BE = BP.writeUInt32BE;
            arr.writeIntLE = BP.writeIntLE;
            arr.writeIntBE = BP.writeIntBE;
            arr.writeInt8 = BP.writeInt8;
            arr.writeInt16LE = BP.writeInt16LE;
            arr.writeInt16BE = BP.writeInt16BE;
            arr.writeInt32LE = BP.writeInt32LE;
            arr.writeInt32BE = BP.writeInt32BE;
            arr.writeFloatLE = BP.writeFloatLE;
            arr.writeFloatBE = BP.writeFloatBE;
            arr.writeDoubleLE = BP.writeDoubleLE;
            arr.writeDoubleBE = BP.writeDoubleBE;
            arr.fill = BP.fill;
            arr.inspect = BP.inspect;
            arr.toArrayBuffer = BP.toArrayBuffer;
            return arr;
        };
        var INVALID_BASE64_RE = /[^+\/0-9A-z\-]/g;
        function base64clean(str) {
            str = stringtrim(str).replace(INVALID_BASE64_RE, "");
            if (str.length < 2) return "";
            while (str.length % 4 !== 0) {
                str = str + "=";
            }
            return str;
        }
        function stringtrim(str) {
            if (str.trim) return str.trim();
            return str.replace(/^\s+|\s+$/g, "");
        }
        function isArrayish(subject) {
            return isArray(subject) || Buffer.isBuffer(subject) || subject && typeof subject === "object" && typeof subject.length === "number";
        }
        function toHex(n) {
            if (n < 16) return "0" + n.toString(16);
            return n.toString(16);
        }
        function utf8ToBytes(string, units) {
            units = units || Infinity;
            var codePoint;
            var length = string.length;
            var leadSurrogate = null;
            var bytes = [];
            var i = 0;
            for (;i < length; i++) {
                codePoint = string.charCodeAt(i);
                if (codePoint > 55295 && codePoint < 57344) {
                    if (leadSurrogate) {
                        if (codePoint < 56320) {
                            if ((units -= 3) > -1) bytes.push(239, 191, 189);
                            leadSurrogate = codePoint;
                            continue;
                        } else {
                            codePoint = leadSurrogate - 55296 << 10 | codePoint - 56320 | 65536;
                            leadSurrogate = null;
                        }
                    } else {
                        if (codePoint > 56319) {
                            if ((units -= 3) > -1) bytes.push(239, 191, 189);
                            continue;
                        } else if (i + 1 === length) {
                            if ((units -= 3) > -1) bytes.push(239, 191, 189);
                            continue;
                        } else {
                            leadSurrogate = codePoint;
                            continue;
                        }
                    }
                } else if (leadSurrogate) {
                    if ((units -= 3) > -1) bytes.push(239, 191, 189);
                    leadSurrogate = null;
                }
                if (codePoint < 128) {
                    if ((units -= 1) < 0) break;
                    bytes.push(codePoint);
                } else if (codePoint < 2048) {
                    if ((units -= 2) < 0) break;
                    bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
                } else if (codePoint < 65536) {
                    if ((units -= 3) < 0) break;
                    bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
                } else if (codePoint < 2097152) {
                    if ((units -= 4) < 0) break;
                    bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
                } else {
                    throw new Error("Invalid code point");
                }
            }
            return bytes;
        }
        function asciiToBytes(str) {
            var byteArray = [];
            for (var i = 0; i < str.length; i++) {
                byteArray.push(str.charCodeAt(i) & 255);
            }
            return byteArray;
        }
        function utf16leToBytes(str, units) {
            var c, hi, lo;
            var byteArray = [];
            for (var i = 0; i < str.length; i++) {
                if ((units -= 2) < 0) break;
                c = str.charCodeAt(i);
                hi = c >> 8;
                lo = c % 256;
                byteArray.push(lo);
                byteArray.push(hi);
            }
            return byteArray;
        }
        function base64ToBytes(str) {
            return base64.toByteArray(base64clean(str));
        }
        function blitBuffer(src, dst, offset, length) {
            for (var i = 0; i < length; i++) {
                if (i + offset >= dst.length || i >= src.length) break;
                dst[i + offset] = src[i];
            }
            return i;
        }
        function decodeUtf8Char(str) {
            try {
                return decodeURIComponent(str);
            } catch (err) {
                return String.fromCharCode(65533);
            }
        }
    }, {
        "base64-js": 4,
        ieee754: 5,
        "is-array": 6
    } ],
    4: [ function(require, module, exports) {
        var lookup = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
        (function(exports) {
            "use strict";
            var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
            var PLUS = "+".charCodeAt(0);
            var SLASH = "/".charCodeAt(0);
            var NUMBER = "0".charCodeAt(0);
            var LOWER = "a".charCodeAt(0);
            var UPPER = "A".charCodeAt(0);
            var PLUS_URL_SAFE = "-".charCodeAt(0);
            var SLASH_URL_SAFE = "_".charCodeAt(0);
            function decode(elt) {
                var code = elt.charCodeAt(0);
                if (code === PLUS || code === PLUS_URL_SAFE) return 62;
                if (code === SLASH || code === SLASH_URL_SAFE) return 63;
                if (code < NUMBER) return -1;
                if (code < NUMBER + 10) return code - NUMBER + 26 + 26;
                if (code < UPPER + 26) return code - UPPER;
                if (code < LOWER + 26) return code - LOWER + 26;
            }
            function b64ToByteArray(b64) {
                var i, j, l, tmp, placeHolders, arr;
                if (b64.length % 4 > 0) {
                    throw new Error("Invalid string. Length must be a multiple of 4");
                }
                var len = b64.length;
                placeHolders = "=" === b64.charAt(len - 2) ? 2 : "=" === b64.charAt(len - 1) ? 1 : 0;
                arr = new Arr(b64.length * 3 / 4 - placeHolders);
                l = placeHolders > 0 ? b64.length - 4 : b64.length;
                var L = 0;
                function push(v) {
                    arr[L++] = v;
                }
                for (i = 0, j = 0; i < l; i += 4, j += 3) {
                    tmp = decode(b64.charAt(i)) << 18 | decode(b64.charAt(i + 1)) << 12 | decode(b64.charAt(i + 2)) << 6 | decode(b64.charAt(i + 3));
                    push((tmp & 16711680) >> 16);
                    push((tmp & 65280) >> 8);
                    push(tmp & 255);
                }
                if (placeHolders === 2) {
                    tmp = decode(b64.charAt(i)) << 2 | decode(b64.charAt(i + 1)) >> 4;
                    push(tmp & 255);
                } else if (placeHolders === 1) {
                    tmp = decode(b64.charAt(i)) << 10 | decode(b64.charAt(i + 1)) << 4 | decode(b64.charAt(i + 2)) >> 2;
                    push(tmp >> 8 & 255);
                    push(tmp & 255);
                }
                return arr;
            }
            function uint8ToBase64(uint8) {
                var i, extraBytes = uint8.length % 3, output = "", temp, length;
                function encode(num) {
                    return lookup.charAt(num);
                }
                function tripletToBase64(num) {
                    return encode(num >> 18 & 63) + encode(num >> 12 & 63) + encode(num >> 6 & 63) + encode(num & 63);
                }
                for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
                    temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];
                    output += tripletToBase64(temp);
                }
                switch (extraBytes) {
                  case 1:
                    temp = uint8[uint8.length - 1];
                    output += encode(temp >> 2);
                    output += encode(temp << 4 & 63);
                    output += "==";
                    break;

                  case 2:
                    temp = (uint8[uint8.length - 2] << 8) + uint8[uint8.length - 1];
                    output += encode(temp >> 10);
                    output += encode(temp >> 4 & 63);
                    output += encode(temp << 2 & 63);
                    output += "=";
                    break;
                }
                return output;
            }
            exports.toByteArray = b64ToByteArray;
            exports.fromByteArray = uint8ToBase64;
        })(typeof exports === "undefined" ? this.base64js = {} : exports);
    }, {} ],
    5: [ function(require, module, exports) {
        exports.read = function(buffer, offset, isLE, mLen, nBytes) {
            var e, m, eLen = nBytes * 8 - mLen - 1, eMax = (1 << eLen) - 1, eBias = eMax >> 1, nBits = -7, i = isLE ? nBytes - 1 : 0, d = isLE ? -1 : 1, s = buffer[offset + i];
            i += d;
            e = s & (1 << -nBits) - 1;
            s >>= -nBits;
            nBits += eLen;
            for (;nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) ;
            m = e & (1 << -nBits) - 1;
            e >>= -nBits;
            nBits += mLen;
            for (;nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) ;
            if (e === 0) {
                e = 1 - eBias;
            } else if (e === eMax) {
                return m ? NaN : (s ? -1 : 1) * Infinity;
            } else {
                m = m + Math.pow(2, mLen);
                e = e - eBias;
            }
            return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
        };
        exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
            var e, m, c, eLen = nBytes * 8 - mLen - 1, eMax = (1 << eLen) - 1, eBias = eMax >> 1, rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, i = isLE ? 0 : nBytes - 1, d = isLE ? 1 : -1, s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
            value = Math.abs(value);
            if (isNaN(value) || value === Infinity) {
                m = isNaN(value) ? 1 : 0;
                e = eMax;
            } else {
                e = Math.floor(Math.log(value) / Math.LN2);
                if (value * (c = Math.pow(2, -e)) < 1) {
                    e--;
                    c *= 2;
                }
                if (e + eBias >= 1) {
                    value += rt / c;
                } else {
                    value += rt * Math.pow(2, 1 - eBias);
                }
                if (value * c >= 2) {
                    e++;
                    c /= 2;
                }
                if (e + eBias >= eMax) {
                    m = 0;
                    e = eMax;
                } else if (e + eBias >= 1) {
                    m = (value * c - 1) * Math.pow(2, mLen);
                    e = e + eBias;
                } else {
                    m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
                    e = 0;
                }
            }
            for (;mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) ;
            e = e << mLen | m;
            eLen += mLen;
            for (;eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) ;
            buffer[offset + i - d] |= s * 128;
        };
    }, {} ],
    6: [ function(require, module, exports) {
        var isArray = Array.isArray;
        var str = Object.prototype.toString;
        module.exports = isArray || function(val) {
            return !!val && "[object Array]" == str.call(val);
        };
    }, {} ],
    7: [ function(require, module, exports) {
        (function(global) {
            (function(root) {
                var freeExports = typeof exports == "object" && exports;
                var freeModule = typeof module == "object" && module && module.exports == freeExports && module;
                var freeGlobal = typeof global == "object" && global;
                if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
                    root = freeGlobal;
                }
                var punycode, maxInt = 2147483647, base = 36, tMin = 1, tMax = 26, skew = 38, damp = 700, initialBias = 72, initialN = 128, delimiter = "-", regexPunycode = /^xn--/, regexNonASCII = /[^ -~]/, regexSeparators = /\x2E|\u3002|\uFF0E|\uFF61/g, errors = {
                    overflow: "Overflow: input needs wider integers to process",
                    "not-basic": "Illegal input >= 0x80 (not a basic code point)",
                    "invalid-input": "Invalid input"
                }, baseMinusTMin = base - tMin, floor = Math.floor, stringFromCharCode = String.fromCharCode, key;
                function error(type) {
                    throw RangeError(errors[type]);
                }
                function map(array, fn) {
                    var length = array.length;
                    while (length--) {
                        array[length] = fn(array[length]);
                    }
                    return array;
                }
                function mapDomain(string, fn) {
                    return map(string.split(regexSeparators), fn).join(".");
                }
                function ucs2decode(string) {
                    var output = [], counter = 0, length = string.length, value, extra;
                    while (counter < length) {
                        value = string.charCodeAt(counter++);
                        if (value >= 55296 && value <= 56319 && counter < length) {
                            extra = string.charCodeAt(counter++);
                            if ((extra & 64512) == 56320) {
                                output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
                            } else {
                                output.push(value);
                                counter--;
                            }
                        } else {
                            output.push(value);
                        }
                    }
                    return output;
                }
                function ucs2encode(array) {
                    return map(array, function(value) {
                        var output = "";
                        if (value > 65535) {
                            value -= 65536;
                            output += stringFromCharCode(value >>> 10 & 1023 | 55296);
                            value = 56320 | value & 1023;
                        }
                        output += stringFromCharCode(value);
                        return output;
                    }).join("");
                }
                function basicToDigit(codePoint) {
                    if (codePoint - 48 < 10) {
                        return codePoint - 22;
                    }
                    if (codePoint - 65 < 26) {
                        return codePoint - 65;
                    }
                    if (codePoint - 97 < 26) {
                        return codePoint - 97;
                    }
                    return base;
                }
                function digitToBasic(digit, flag) {
                    return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
                }
                function adapt(delta, numPoints, firstTime) {
                    var k = 0;
                    delta = firstTime ? floor(delta / damp) : delta >> 1;
                    delta += floor(delta / numPoints);
                    for (;delta > baseMinusTMin * tMax >> 1; k += base) {
                        delta = floor(delta / baseMinusTMin);
                    }
                    return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
                }
                function decode(input) {
                    var output = [], inputLength = input.length, out, i = 0, n = initialN, bias = initialBias, basic, j, index, oldi, w, k, digit, t, baseMinusT;
                    basic = input.lastIndexOf(delimiter);
                    if (basic < 0) {
                        basic = 0;
                    }
                    for (j = 0; j < basic; ++j) {
                        if (input.charCodeAt(j) >= 128) {
                            error("not-basic");
                        }
                        output.push(input.charCodeAt(j));
                    }
                    for (index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
                        for (oldi = i, w = 1, k = base; ;k += base) {
                            if (index >= inputLength) {
                                error("invalid-input");
                            }
                            digit = basicToDigit(input.charCodeAt(index++));
                            if (digit >= base || digit > floor((maxInt - i) / w)) {
                                error("overflow");
                            }
                            i += digit * w;
                            t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                            if (digit < t) {
                                break;
                            }
                            baseMinusT = base - t;
                            if (w > floor(maxInt / baseMinusT)) {
                                error("overflow");
                            }
                            w *= baseMinusT;
                        }
                        out = output.length + 1;
                        bias = adapt(i - oldi, out, oldi == 0);
                        if (floor(i / out) > maxInt - n) {
                            error("overflow");
                        }
                        n += floor(i / out);
                        i %= out;
                        output.splice(i++, 0, n);
                    }
                    return ucs2encode(output);
                }
                function encode(input) {
                    var n, delta, handledCPCount, basicLength, bias, j, m, q, k, t, currentValue, output = [], inputLength, handledCPCountPlusOne, baseMinusT, qMinusT;
                    input = ucs2decode(input);
                    inputLength = input.length;
                    n = initialN;
                    delta = 0;
                    bias = initialBias;
                    for (j = 0; j < inputLength; ++j) {
                        currentValue = input[j];
                        if (currentValue < 128) {
                            output.push(stringFromCharCode(currentValue));
                        }
                    }
                    handledCPCount = basicLength = output.length;
                    if (basicLength) {
                        output.push(delimiter);
                    }
                    while (handledCPCount < inputLength) {
                        for (m = maxInt, j = 0; j < inputLength; ++j) {
                            currentValue = input[j];
                            if (currentValue >= n && currentValue < m) {
                                m = currentValue;
                            }
                        }
                        handledCPCountPlusOne = handledCPCount + 1;
                        if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
                            error("overflow");
                        }
                        delta += (m - n) * handledCPCountPlusOne;
                        n = m;
                        for (j = 0; j < inputLength; ++j) {
                            currentValue = input[j];
                            if (currentValue < n && ++delta > maxInt) {
                                error("overflow");
                            }
                            if (currentValue == n) {
                                for (q = delta, k = base; ;k += base) {
                                    t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                                    if (q < t) {
                                        break;
                                    }
                                    qMinusT = q - t;
                                    baseMinusT = base - t;
                                    output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
                                    q = floor(qMinusT / baseMinusT);
                                }
                                output.push(stringFromCharCode(digitToBasic(q, 0)));
                                bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
                                delta = 0;
                                ++handledCPCount;
                            }
                        }
                        ++delta;
                        ++n;
                    }
                    return output.join("");
                }
                function toUnicode(domain) {
                    return mapDomain(domain, function(string) {
                        return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
                    });
                }
                function toASCII(domain) {
                    return mapDomain(domain, function(string) {
                        return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
                    });
                }
                punycode = {
                    version: "1.2.4",
                    ucs2: {
                        decode: ucs2decode,
                        encode: ucs2encode
                    },
                    decode: decode,
                    encode: encode,
                    toASCII: toASCII,
                    toUnicode: toUnicode
                };
                if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
                    define("punycode", function() {
                        return punycode;
                    });
                } else if (freeExports && !freeExports.nodeType) {
                    if (freeModule) {
                        freeModule.exports = punycode;
                    } else {
                        for (key in punycode) {
                            punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
                        }
                    }
                } else {
                    root.punycode = punycode;
                }
            })(this);
        }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, {} ],
    8: [ function(require, module, exports) {
        "use strict";
        function hasOwnProperty(obj, prop) {
            return Object.prototype.hasOwnProperty.call(obj, prop);
        }
        module.exports = function(qs, sep, eq, options) {
            sep = sep || "&";
            eq = eq || "=";
            var obj = {};
            if (typeof qs !== "string" || qs.length === 0) {
                return obj;
            }
            var regexp = /\+/g;
            qs = qs.split(sep);
            var maxKeys = 1e3;
            if (options && typeof options.maxKeys === "number") {
                maxKeys = options.maxKeys;
            }
            var len = qs.length;
            if (maxKeys > 0 && len > maxKeys) {
                len = maxKeys;
            }
            for (var i = 0; i < len; ++i) {
                var x = qs[i].replace(regexp, "%20"), idx = x.indexOf(eq), kstr, vstr, k, v;
                if (idx >= 0) {
                    kstr = x.substr(0, idx);
                    vstr = x.substr(idx + 1);
                } else {
                    kstr = x;
                    vstr = "";
                }
                k = decodeURIComponent(kstr);
                v = decodeURIComponent(vstr);
                if (!hasOwnProperty(obj, k)) {
                    obj[k] = v;
                } else if (isArray(obj[k])) {
                    obj[k].push(v);
                } else {
                    obj[k] = [ obj[k], v ];
                }
            }
            return obj;
        };
        var isArray = Array.isArray || function(xs) {
            return Object.prototype.toString.call(xs) === "[object Array]";
        };
    }, {} ],
    9: [ function(require, module, exports) {
        "use strict";
        var stringifyPrimitive = function(v) {
            switch (typeof v) {
              case "string":
                return v;

              case "boolean":
                return v ? "true" : "false";

              case "number":
                return isFinite(v) ? v : "";

              default:
                return "";
            }
        };
        module.exports = function(obj, sep, eq, name) {
            sep = sep || "&";
            eq = eq || "=";
            if (obj === null) {
                obj = undefined;
            }
            if (typeof obj === "object") {
                return map(objectKeys(obj), function(k) {
                    var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
                    if (isArray(obj[k])) {
                        return map(obj[k], function(v) {
                            return ks + encodeURIComponent(stringifyPrimitive(v));
                        }).join(sep);
                    } else {
                        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
                    }
                }).join(sep);
            }
            if (!name) return "";
            return encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj));
        };
        var isArray = Array.isArray || function(xs) {
            return Object.prototype.toString.call(xs) === "[object Array]";
        };
        function map(xs, f) {
            if (xs.map) return xs.map(f);
            var res = [];
            for (var i = 0; i < xs.length; i++) {
                res.push(f(xs[i], i));
            }
            return res;
        }
        var objectKeys = Object.keys || function(obj) {
            var res = [];
            for (var key in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
            }
            return res;
        };
    }, {} ],
    10: [ function(require, module, exports) {
        "use strict";
        exports.decode = exports.parse = require("./decode");
        exports.encode = exports.stringify = require("./encode");
    }, {
        "./decode": 8,
        "./encode": 9
    } ],
    11: [ function(require, module, exports) {
        var punycode = require("punycode");
        exports.parse = urlParse;
        exports.resolve = urlResolve;
        exports.resolveObject = urlResolveObject;
        exports.format = urlFormat;
        exports.Url = Url;
        function Url() {
            this.protocol = null;
            this.slashes = null;
            this.auth = null;
            this.host = null;
            this.port = null;
            this.hostname = null;
            this.hash = null;
            this.search = null;
            this.query = null;
            this.pathname = null;
            this.path = null;
            this.href = null;
        }
        var protocolPattern = /^([a-z0-9.+-]+:)/i, portPattern = /:[0-9]*$/, delims = [ "<", ">", '"', "`", " ", "\r", "\n", "	" ], unwise = [ "{", "}", "|", "\\", "^", "`" ].concat(delims), autoEscape = [ "'" ].concat(unwise), nonHostChars = [ "%", "/", "?", ";", "#" ].concat(autoEscape), hostEndingChars = [ "/", "?", "#" ], hostnameMaxLen = 255, hostnamePartPattern = /^[a-z0-9A-Z_-]{0,63}$/, hostnamePartStart = /^([a-z0-9A-Z_-]{0,63})(.*)$/, unsafeProtocol = {
            javascript: true,
            "javascript:": true
        }, hostlessProtocol = {
            javascript: true,
            "javascript:": true
        }, slashedProtocol = {
            http: true,
            https: true,
            ftp: true,
            gopher: true,
            file: true,
            "http:": true,
            "https:": true,
            "ftp:": true,
            "gopher:": true,
            "file:": true
        }, querystring = require("querystring");
        function urlParse(url, parseQueryString, slashesDenoteHost) {
            if (url && isObject(url) && url instanceof Url) return url;
            var u = new Url();
            u.parse(url, parseQueryString, slashesDenoteHost);
            return u;
        }
        Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
            if (!isString(url)) {
                throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
            }
            var rest = url;
            rest = rest.trim();
            var proto = protocolPattern.exec(rest);
            if (proto) {
                proto = proto[0];
                var lowerProto = proto.toLowerCase();
                this.protocol = lowerProto;
                rest = rest.substr(proto.length);
            }
            if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
                var slashes = rest.substr(0, 2) === "//";
                if (slashes && !(proto && hostlessProtocol[proto])) {
                    rest = rest.substr(2);
                    this.slashes = true;
                }
            }
            if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
                var hostEnd = -1;
                for (var i = 0; i < hostEndingChars.length; i++) {
                    var hec = rest.indexOf(hostEndingChars[i]);
                    if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) hostEnd = hec;
                }
                var auth, atSign;
                if (hostEnd === -1) {
                    atSign = rest.lastIndexOf("@");
                } else {
                    atSign = rest.lastIndexOf("@", hostEnd);
                }
                if (atSign !== -1) {
                    auth = rest.slice(0, atSign);
                    rest = rest.slice(atSign + 1);
                    this.auth = decodeURIComponent(auth);
                }
                hostEnd = -1;
                for (var i = 0; i < nonHostChars.length; i++) {
                    var hec = rest.indexOf(nonHostChars[i]);
                    if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) hostEnd = hec;
                }
                if (hostEnd === -1) hostEnd = rest.length;
                this.host = rest.slice(0, hostEnd);
                rest = rest.slice(hostEnd);
                this.parseHost();
                this.hostname = this.hostname || "";
                var ipv6Hostname = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
                if (!ipv6Hostname) {
                    var hostparts = this.hostname.split(/\./);
                    for (var i = 0, l = hostparts.length; i < l; i++) {
                        var part = hostparts[i];
                        if (!part) continue;
                        if (!part.match(hostnamePartPattern)) {
                            var newpart = "";
                            for (var j = 0, k = part.length; j < k; j++) {
                                if (part.charCodeAt(j) > 127) {
                                    newpart += "x";
                                } else {
                                    newpart += part[j];
                                }
                            }
                            if (!newpart.match(hostnamePartPattern)) {
                                var validParts = hostparts.slice(0, i);
                                var notHost = hostparts.slice(i + 1);
                                var bit = part.match(hostnamePartStart);
                                if (bit) {
                                    validParts.push(bit[1]);
                                    notHost.unshift(bit[2]);
                                }
                                if (notHost.length) {
                                    rest = "/" + notHost.join(".") + rest;
                                }
                                this.hostname = validParts.join(".");
                                break;
                            }
                        }
                    }
                }
                if (this.hostname.length > hostnameMaxLen) {
                    this.hostname = "";
                } else {
                    this.hostname = this.hostname.toLowerCase();
                }
                if (!ipv6Hostname) {
                    var domainArray = this.hostname.split(".");
                    var newOut = [];
                    for (var i = 0; i < domainArray.length; ++i) {
                        var s = domainArray[i];
                        newOut.push(s.match(/[^A-Za-z0-9_-]/) ? "xn--" + punycode.encode(s) : s);
                    }
                    this.hostname = newOut.join(".");
                }
                var p = this.port ? ":" + this.port : "";
                var h = this.hostname || "";
                this.host = h + p;
                this.href += this.host;
                if (ipv6Hostname) {
                    this.hostname = this.hostname.substr(1, this.hostname.length - 2);
                    if (rest[0] !== "/") {
                        rest = "/" + rest;
                    }
                }
            }
            if (!unsafeProtocol[lowerProto]) {
                for (var i = 0, l = autoEscape.length; i < l; i++) {
                    var ae = autoEscape[i];
                    var esc = encodeURIComponent(ae);
                    if (esc === ae) {
                        esc = escape(ae);
                    }
                    rest = rest.split(ae).join(esc);
                }
            }
            var hash = rest.indexOf("#");
            if (hash !== -1) {
                this.hash = rest.substr(hash);
                rest = rest.slice(0, hash);
            }
            var qm = rest.indexOf("?");
            if (qm !== -1) {
                this.search = rest.substr(qm);
                this.query = rest.substr(qm + 1);
                if (parseQueryString) {
                    this.query = querystring.parse(this.query);
                }
                rest = rest.slice(0, qm);
            } else if (parseQueryString) {
                this.search = "";
                this.query = {};
            }
            if (rest) this.pathname = rest;
            if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
                this.pathname = "/";
            }
            if (this.pathname || this.search) {
                var p = this.pathname || "";
                var s = this.search || "";
                this.path = p + s;
            }
            this.href = this.format();
            return this;
        };
        function urlFormat(obj) {
            if (isString(obj)) obj = urlParse(obj);
            if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
            return obj.format();
        }
        Url.prototype.format = function() {
            var auth = this.auth || "";
            if (auth) {
                auth = encodeURIComponent(auth);
                auth = auth.replace(/%3A/i, ":");
                auth += "@";
            }
            var protocol = this.protocol || "", pathname = this.pathname || "", hash = this.hash || "", host = false, query = "";
            if (this.host) {
                host = auth + this.host;
            } else if (this.hostname) {
                host = auth + (this.hostname.indexOf(":") === -1 ? this.hostname : "[" + this.hostname + "]");
                if (this.port) {
                    host += ":" + this.port;
                }
            }
            if (this.query && isObject(this.query) && Object.keys(this.query).length) {
                query = querystring.stringify(this.query);
            }
            var search = this.search || query && "?" + query || "";
            if (protocol && protocol.substr(-1) !== ":") protocol += ":";
            if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {
                host = "//" + (host || "");
                if (pathname && pathname.charAt(0) !== "/") pathname = "/" + pathname;
            } else if (!host) {
                host = "";
            }
            if (hash && hash.charAt(0) !== "#") hash = "#" + hash;
            if (search && search.charAt(0) !== "?") search = "?" + search;
            pathname = pathname.replace(/[?#]/g, function(match) {
                return encodeURIComponent(match);
            });
            search = search.replace("#", "%23");
            return protocol + host + pathname + search + hash;
        };
        function urlResolve(source, relative) {
            return urlParse(source, false, true).resolve(relative);
        }
        Url.prototype.resolve = function(relative) {
            return this.resolveObject(urlParse(relative, false, true)).format();
        };
        function urlResolveObject(source, relative) {
            if (!source) return relative;
            return urlParse(source, false, true).resolveObject(relative);
        }
        Url.prototype.resolveObject = function(relative) {
            if (isString(relative)) {
                var rel = new Url();
                rel.parse(relative, false, true);
                relative = rel;
            }
            var result = new Url();
            Object.keys(this).forEach(function(k) {
                result[k] = this[k];
            }, this);
            result.hash = relative.hash;
            if (relative.href === "") {
                result.href = result.format();
                return result;
            }
            if (relative.slashes && !relative.protocol) {
                Object.keys(relative).forEach(function(k) {
                    if (k !== "protocol") result[k] = relative[k];
                });
                if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {
                    result.path = result.pathname = "/";
                }
                result.href = result.format();
                return result;
            }
            if (relative.protocol && relative.protocol !== result.protocol) {
                if (!slashedProtocol[relative.protocol]) {
                    Object.keys(relative).forEach(function(k) {
                        result[k] = relative[k];
                    });
                    result.href = result.format();
                    return result;
                }
                result.protocol = relative.protocol;
                if (!relative.host && !hostlessProtocol[relative.protocol]) {
                    var relPath = (relative.pathname || "").split("/");
                    while (relPath.length && !(relative.host = relPath.shift())) ;
                    if (!relative.host) relative.host = "";
                    if (!relative.hostname) relative.hostname = "";
                    if (relPath[0] !== "") relPath.unshift("");
                    if (relPath.length < 2) relPath.unshift("");
                    result.pathname = relPath.join("/");
                } else {
                    result.pathname = relative.pathname;
                }
                result.search = relative.search;
                result.query = relative.query;
                result.host = relative.host || "";
                result.auth = relative.auth;
                result.hostname = relative.hostname || relative.host;
                result.port = relative.port;
                if (result.pathname || result.search) {
                    var p = result.pathname || "";
                    var s = result.search || "";
                    result.path = p + s;
                }
                result.slashes = result.slashes || relative.slashes;
                result.href = result.format();
                return result;
            }
            var isSourceAbs = result.pathname && result.pathname.charAt(0) === "/", isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === "/", mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname, removeAllDots = mustEndAbs, srcPath = result.pathname && result.pathname.split("/") || [], relPath = relative.pathname && relative.pathname.split("/") || [], psychotic = result.protocol && !slashedProtocol[result.protocol];
            if (psychotic) {
                result.hostname = "";
                result.port = null;
                if (result.host) {
                    if (srcPath[0] === "") srcPath[0] = result.host; else srcPath.unshift(result.host);
                }
                result.host = "";
                if (relative.protocol) {
                    relative.hostname = null;
                    relative.port = null;
                    if (relative.host) {
                        if (relPath[0] === "") relPath[0] = relative.host; else relPath.unshift(relative.host);
                    }
                    relative.host = null;
                }
                mustEndAbs = mustEndAbs && (relPath[0] === "" || srcPath[0] === "");
            }
            if (isRelAbs) {
                result.host = relative.host || relative.host === "" ? relative.host : result.host;
                result.hostname = relative.hostname || relative.hostname === "" ? relative.hostname : result.hostname;
                result.search = relative.search;
                result.query = relative.query;
                srcPath = relPath;
            } else if (relPath.length) {
                if (!srcPath) srcPath = [];
                srcPath.pop();
                srcPath = srcPath.concat(relPath);
                result.search = relative.search;
                result.query = relative.query;
            } else if (!isNullOrUndefined(relative.search)) {
                if (psychotic) {
                    result.hostname = result.host = srcPath.shift();
                    var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
                    if (authInHost) {
                        result.auth = authInHost.shift();
                        result.host = result.hostname = authInHost.shift();
                    }
                }
                result.search = relative.search;
                result.query = relative.query;
                if (!isNull(result.pathname) || !isNull(result.search)) {
                    result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
                }
                result.href = result.format();
                return result;
            }
            if (!srcPath.length) {
                result.pathname = null;
                if (result.search) {
                    result.path = "/" + result.search;
                } else {
                    result.path = null;
                }
                result.href = result.format();
                return result;
            }
            var last = srcPath.slice(-1)[0];
            var hasTrailingSlash = (result.host || relative.host) && (last === "." || last === "..") || last === "";
            var up = 0;
            for (var i = srcPath.length; i >= 0; i--) {
                last = srcPath[i];
                if (last == ".") {
                    srcPath.splice(i, 1);
                } else if (last === "..") {
                    srcPath.splice(i, 1);
                    up++;
                } else if (up) {
                    srcPath.splice(i, 1);
                    up--;
                }
            }
            if (!mustEndAbs && !removeAllDots) {
                for (;up--; up) {
                    srcPath.unshift("..");
                }
            }
            if (mustEndAbs && srcPath[0] !== "" && (!srcPath[0] || srcPath[0].charAt(0) !== "/")) {
                srcPath.unshift("");
            }
            if (hasTrailingSlash && srcPath.join("/").substr(-1) !== "/") {
                srcPath.push("");
            }
            var isAbsolute = srcPath[0] === "" || srcPath[0] && srcPath[0].charAt(0) === "/";
            if (psychotic) {
                result.hostname = result.host = isAbsolute ? "" : srcPath.length ? srcPath.shift() : "";
                var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
                if (authInHost) {
                    result.auth = authInHost.shift();
                    result.host = result.hostname = authInHost.shift();
                }
            }
            mustEndAbs = mustEndAbs || result.host && srcPath.length;
            if (mustEndAbs && !isAbsolute) {
                srcPath.unshift("");
            }
            if (!srcPath.length) {
                result.pathname = null;
                result.path = null;
            } else {
                result.pathname = srcPath.join("/");
            }
            if (!isNull(result.pathname) || !isNull(result.search)) {
                result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
            }
            result.auth = relative.auth || result.auth;
            result.slashes = result.slashes || relative.slashes;
            result.href = result.format();
            return result;
        };
        Url.prototype.parseHost = function() {
            var host = this.host;
            var port = portPattern.exec(host);
            if (port) {
                port = port[0];
                if (port !== ":") {
                    this.port = port.substr(1);
                }
                host = host.substr(0, host.length - port.length);
            }
            if (host) this.hostname = host;
        };
        function isString(arg) {
            return typeof arg === "string";
        }
        function isObject(arg) {
            return typeof arg === "object" && arg !== null;
        }
        function isNull(arg) {
            return arg === null;
        }
        function isNullOrUndefined(arg) {
            return arg == null;
        }
    }, {
        punycode: 7,
        querystring: 10
    } ],
    12: [ function(require, module, exports) {
        "use strict";
        var parse = require("cwise-parser");
        var compile = require("cwise-compiler");
        var REQUIRED_FIELDS = [ "args", "body" ];
        var OPTIONAL_FIELDS = [ "pre", "post", "printCode", "funcName", "blockSize" ];
        function createCWise(user_args) {
            for (var id in user_args) {
                if (REQUIRED_FIELDS.indexOf(id) < 0 && OPTIONAL_FIELDS.indexOf(id) < 0) {
                    console.warn("cwise: Unknown argument '" + id + "' passed to expression compiler");
                }
            }
            for (var i = 0; i < REQUIRED_FIELDS.length; ++i) {
                if (!user_args[REQUIRED_FIELDS[i]]) {
                    throw new Error("cwise: Missing argument: " + REQUIRED_FIELDS[i]);
                }
            }
            return compile({
                args: user_args.args,
                pre: parse(user_args.pre || function() {}),
                body: parse(user_args.body),
                post: parse(user_args.post || function() {}),
                debug: !!user_args.printCode,
                funcName: user_args.funcName || user_args.body.name || "cwise",
                blockSize: user_args.blockSize || 64
            });
        }
        module.exports = createCWise;
    }, {
        "cwise-compiler": 14,
        "cwise-parser": 18
    } ],
    13: [ function(require, module, exports) {
        module.exports = require("cwise-compiler");
    }, {
        "cwise-compiler": 14
    } ],
    14: [ function(require, module, exports) {
        "use strict";
        var createThunk = require("./lib/thunk.js");
        function Procedure() {
            this.argTypes = [];
            this.shimArgs = [];
            this.arrayArgs = [];
            this.arrayBlockIndices = [];
            this.scalarArgs = [];
            this.offsetArgs = [];
            this.offsetArgIndex = [];
            this.indexArgs = [];
            this.shapeArgs = [];
            this.funcName = "";
            this.pre = null;
            this.body = null;
            this.post = null;
            this.debug = false;
        }
        function compileCwise(user_args) {
            var proc = new Procedure();
            proc.pre = user_args.pre;
            proc.body = user_args.body;
            proc.post = user_args.post;
            var proc_args = user_args.args.slice(0);
            proc.argTypes = proc_args;
            for (var i = 0; i < proc_args.length; ++i) {
                var arg_type = proc_args[i];
                if (arg_type === "array" || typeof arg_type === "object" && arg_type.blockIndices) {
                    proc.argTypes[i] = "array";
                    proc.arrayArgs.push(i);
                    proc.arrayBlockIndices.push(arg_type.blockIndices ? arg_type.blockIndices : 0);
                    proc.shimArgs.push("array" + i);
                    if (i < proc.pre.args.length && proc.pre.args[i].count > 0) {
                        throw new Error("cwise: pre() block may not reference array args");
                    }
                    if (i < proc.post.args.length && proc.post.args[i].count > 0) {
                        throw new Error("cwise: post() block may not reference array args");
                    }
                } else if (arg_type === "scalar") {
                    proc.scalarArgs.push(i);
                    proc.shimArgs.push("scalar" + i);
                } else if (arg_type === "index") {
                    proc.indexArgs.push(i);
                    if (i < proc.pre.args.length && proc.pre.args[i].count > 0) {
                        throw new Error("cwise: pre() block may not reference array index");
                    }
                    if (i < proc.body.args.length && proc.body.args[i].lvalue) {
                        throw new Error("cwise: body() block may not write to array index");
                    }
                    if (i < proc.post.args.length && proc.post.args[i].count > 0) {
                        throw new Error("cwise: post() block may not reference array index");
                    }
                } else if (arg_type === "shape") {
                    proc.shapeArgs.push(i);
                    if (i < proc.pre.args.length && proc.pre.args[i].lvalue) {
                        throw new Error("cwise: pre() block may not write to array shape");
                    }
                    if (i < proc.body.args.length && proc.body.args[i].lvalue) {
                        throw new Error("cwise: body() block may not write to array shape");
                    }
                    if (i < proc.post.args.length && proc.post.args[i].lvalue) {
                        throw new Error("cwise: post() block may not write to array shape");
                    }
                } else if (typeof arg_type === "object" && arg_type.offset) {
                    proc.argTypes[i] = "offset";
                    proc.offsetArgs.push({
                        array: arg_type.array,
                        offset: arg_type.offset
                    });
                    proc.offsetArgIndex.push(i);
                } else {
                    throw new Error("cwise: Unknown argument type " + proc_args[i]);
                }
            }
            if (proc.arrayArgs.length <= 0) {
                throw new Error("cwise: No array arguments specified");
            }
            if (proc.pre.args.length > proc_args.length) {
                throw new Error("cwise: Too many arguments in pre() block");
            }
            if (proc.body.args.length > proc_args.length) {
                throw new Error("cwise: Too many arguments in body() block");
            }
            if (proc.post.args.length > proc_args.length) {
                throw new Error("cwise: Too many arguments in post() block");
            }
            proc.debug = !!user_args.printCode || !!user_args.debug;
            proc.funcName = user_args.funcName || "cwise";
            proc.blockSize = user_args.blockSize || 64;
            return createThunk(proc);
        }
        module.exports = compileCwise;
    }, {
        "./lib/thunk.js": 16
    } ],
    15: [ function(require, module, exports) {
        "use strict";
        var uniq = require("uniq");
        function innerFill(order, proc, body) {
            var dimension = order.length, nargs = proc.arrayArgs.length, has_index = proc.indexArgs.length > 0, code = [], vars = [], idx = 0, pidx = 0, i, j;
            for (i = 0; i < dimension; ++i) {
                vars.push([ "i", i, "=0" ].join(""));
            }
            for (j = 0; j < nargs; ++j) {
                for (i = 0; i < dimension; ++i) {
                    pidx = idx;
                    idx = order[i];
                    if (i === 0) {
                        vars.push([ "d", j, "s", i, "=t", j, "p", idx ].join(""));
                    } else {
                        vars.push([ "d", j, "s", i, "=(t", j, "p", idx, "-s", pidx, "*t", j, "p", pidx, ")" ].join(""));
                    }
                }
            }
            code.push("var " + vars.join(","));
            for (i = dimension - 1; i >= 0; --i) {
                idx = order[i];
                code.push([ "for(i", i, "=0;i", i, "<s", idx, ";++i", i, "){" ].join(""));
            }
            code.push(body);
            for (i = 0; i < dimension; ++i) {
                pidx = idx;
                idx = order[i];
                for (j = 0; j < nargs; ++j) {
                    code.push([ "p", j, "+=d", j, "s", i ].join(""));
                }
                if (has_index) {
                    if (i > 0) {
                        code.push([ "index[", pidx, "]-=s", pidx ].join(""));
                    }
                    code.push([ "++index[", idx, "]" ].join(""));
                }
                code.push("}");
            }
            return code.join("\n");
        }
        function outerFill(matched, order, proc, body) {
            var dimension = order.length, nargs = proc.arrayArgs.length, blockSize = proc.blockSize, has_index = proc.indexArgs.length > 0, code = [];
            for (var i = 0; i < nargs; ++i) {
                code.push([ "var offset", i, "=p", i ].join(""));
            }
            for (var i = matched; i < dimension; ++i) {
                code.push([ "for(var j" + i + "=SS[", order[i], "]|0;j", i, ">0;){" ].join(""));
                code.push([ "if(j", i, "<", blockSize, "){" ].join(""));
                code.push([ "s", order[i], "=j", i ].join(""));
                code.push([ "j", i, "=0" ].join(""));
                code.push([ "}else{s", order[i], "=", blockSize ].join(""));
                code.push([ "j", i, "-=", blockSize, "}" ].join(""));
                if (has_index) {
                    code.push([ "index[", order[i], "]=j", i ].join(""));
                }
            }
            for (var i = 0; i < nargs; ++i) {
                var indexStr = [ "offset" + i ];
                for (var j = matched; j < dimension; ++j) {
                    indexStr.push([ "j", j, "*t", i, "p", order[j] ].join(""));
                }
                code.push([ "p", i, "=(", indexStr.join("+"), ")" ].join(""));
            }
            code.push(innerFill(order, proc, body));
            for (var i = matched; i < dimension; ++i) {
                code.push("}");
            }
            return code.join("\n");
        }
        function countMatches(orders) {
            var matched = 0, dimension = orders[0].length;
            while (matched < dimension) {
                for (var j = 1; j < orders.length; ++j) {
                    if (orders[j][matched] !== orders[0][matched]) {
                        return matched;
                    }
                }
                ++matched;
            }
            return matched;
        }
        function processBlock(block, proc, dtypes) {
            var code = block.body;
            var pre = [];
            var post = [];
            for (var i = 0; i < block.args.length; ++i) {
                var carg = block.args[i];
                if (carg.count <= 0) {
                    continue;
                }
                var re = new RegExp(carg.name, "g");
                var ptrStr = "";
                var arrNum = proc.arrayArgs.indexOf(i);
                switch (proc.argTypes[i]) {
                  case "offset":
                    var offArgIndex = proc.offsetArgIndex.indexOf(i);
                    var offArg = proc.offsetArgs[offArgIndex];
                    arrNum = offArg.array;
                    ptrStr = "+q" + offArgIndex;

                  case "array":
                    ptrStr = "p" + arrNum + ptrStr;
                    var localStr = "l" + i;
                    var arrStr = "a" + arrNum;
                    if (proc.arrayBlockIndices[arrNum] === 0) {
                        if (carg.count === 1) {
                            if (dtypes[arrNum] === "generic") {
                                if (carg.lvalue) {
                                    pre.push([ "var ", localStr, "=", arrStr, ".get(", ptrStr, ")" ].join(""));
                                    code = code.replace(re, localStr);
                                    post.push([ arrStr, ".set(", ptrStr, ",", localStr, ")" ].join(""));
                                } else {
                                    code = code.replace(re, [ arrStr, ".get(", ptrStr, ")" ].join(""));
                                }
                            } else {
                                code = code.replace(re, [ arrStr, "[", ptrStr, "]" ].join(""));
                            }
                        } else if (dtypes[arrNum] === "generic") {
                            pre.push([ "var ", localStr, "=", arrStr, ".get(", ptrStr, ")" ].join(""));
                            code = code.replace(re, localStr);
                            if (carg.lvalue) {
                                post.push([ arrStr, ".set(", ptrStr, ",", localStr, ")" ].join(""));
                            }
                        } else {
                            pre.push([ "var ", localStr, "=", arrStr, "[", ptrStr, "]" ].join(""));
                            code = code.replace(re, localStr);
                            if (carg.lvalue) {
                                post.push([ arrStr, "[", ptrStr, "]=", localStr ].join(""));
                            }
                        }
                    } else {
                        var reStrArr = [ carg.name ], ptrStrArr = [ ptrStr ];
                        for (var j = 0; j < Math.abs(proc.arrayBlockIndices[arrNum]); j++) {
                            reStrArr.push("\\s*\\[([^\\]]+)\\]");
                            ptrStrArr.push("$" + (j + 1) + "*t" + arrNum + "b" + j);
                        }
                        re = new RegExp(reStrArr.join(""), "g");
                        ptrStr = ptrStrArr.join("+");
                        if (dtypes[arrNum] === "generic") {
                            throw new Error("cwise: Generic arrays not supported in combination with blocks!");
                        } else {
                            code = code.replace(re, [ arrStr, "[", ptrStr, "]" ].join(""));
                        }
                    }
                    break;

                  case "scalar":
                    code = code.replace(re, "Y" + proc.scalarArgs.indexOf(i));
                    break;

                  case "index":
                    code = code.replace(re, "index");
                    break;

                  case "shape":
                    code = code.replace(re, "shape");
                    break;
                }
            }
            return [ pre.join("\n"), code, post.join("\n") ].join("\n").trim();
        }
        function typeSummary(dtypes) {
            var summary = new Array(dtypes.length);
            var allEqual = true;
            for (var i = 0; i < dtypes.length; ++i) {
                var t = dtypes[i];
                var digits = t.match(/\d+/);
                if (!digits) {
                    digits = "";
                } else {
                    digits = digits[0];
                }
                if (t.charAt(0) === 0) {
                    summary[i] = "u" + t.charAt(1) + digits;
                } else {
                    summary[i] = t.charAt(0) + digits;
                }
                if (i > 0) {
                    allEqual = allEqual && summary[i] === summary[i - 1];
                }
            }
            if (allEqual) {
                return summary[0];
            }
            return summary.join("");
        }
        function generateCWiseOp(proc, typesig) {
            var dimension = typesig[1].length - Math.abs(proc.arrayBlockIndices[0]) | 0;
            var orders = new Array(proc.arrayArgs.length);
            var dtypes = new Array(proc.arrayArgs.length);
            for (var i = 0; i < proc.arrayArgs.length; ++i) {
                dtypes[i] = typesig[2 * i];
                orders[i] = typesig[2 * i + 1];
            }
            var blockBegin = [], blockEnd = [];
            var loopBegin = [], loopEnd = [];
            var loopOrders = [];
            for (var i = 0; i < proc.arrayArgs.length; ++i) {
                if (proc.arrayBlockIndices[i] < 0) {
                    loopBegin.push(0);
                    loopEnd.push(dimension);
                    blockBegin.push(dimension);
                    blockEnd.push(dimension + proc.arrayBlockIndices[i]);
                } else {
                    loopBegin.push(proc.arrayBlockIndices[i]);
                    loopEnd.push(proc.arrayBlockIndices[i] + dimension);
                    blockBegin.push(0);
                    blockEnd.push(proc.arrayBlockIndices[i]);
                }
                var newOrder = [];
                for (var j = 0; j < orders[i].length; j++) {
                    if (loopBegin[i] <= orders[i][j] && orders[i][j] < loopEnd[i]) {
                        newOrder.push(orders[i][j] - loopBegin[i]);
                    }
                }
                loopOrders.push(newOrder);
            }
            var arglist = [ "SS" ];
            var code = [ "'use strict'" ];
            var vars = [];
            for (var j = 0; j < dimension; ++j) {
                vars.push([ "s", j, "=SS[", j, "]" ].join(""));
            }
            for (var i = 0; i < proc.arrayArgs.length; ++i) {
                arglist.push("a" + i);
                arglist.push("t" + i);
                arglist.push("p" + i);
                for (var j = 0; j < dimension; ++j) {
                    vars.push([ "t", i, "p", j, "=t", i, "[", loopBegin[i] + j, "]" ].join(""));
                }
                for (var j = 0; j < Math.abs(proc.arrayBlockIndices[i]); ++j) {
                    vars.push([ "t", i, "b", j, "=t", i, "[", blockBegin[i] + j, "]" ].join(""));
                }
            }
            for (var i = 0; i < proc.scalarArgs.length; ++i) {
                arglist.push("Y" + i);
            }
            if (proc.shapeArgs.length > 0) {
                vars.push("shape=SS.slice(0)");
            }
            if (proc.indexArgs.length > 0) {
                var zeros = new Array(dimension);
                for (var i = 0; i < dimension; ++i) {
                    zeros[i] = "0";
                }
                vars.push([ "index=[", zeros.join(","), "]" ].join(""));
            }
            for (var i = 0; i < proc.offsetArgs.length; ++i) {
                var off_arg = proc.offsetArgs[i];
                var init_string = [];
                for (var j = 0; j < off_arg.offset.length; ++j) {
                    if (off_arg.offset[j] === 0) {
                        continue;
                    } else if (off_arg.offset[j] === 1) {
                        init_string.push([ "t", off_arg.array, "p", j ].join(""));
                    } else {
                        init_string.push([ off_arg.offset[j], "*t", off_arg.array, "p", j ].join(""));
                    }
                }
                if (init_string.length === 0) {
                    vars.push("q" + i + "=0");
                } else {
                    vars.push([ "q", i, "=", init_string.join("+") ].join(""));
                }
            }
            var thisVars = uniq([].concat(proc.pre.thisVars).concat(proc.body.thisVars).concat(proc.post.thisVars));
            vars = vars.concat(thisVars);
            code.push("var " + vars.join(","));
            for (var i = 0; i < proc.arrayArgs.length; ++i) {
                code.push("p" + i + "|=0");
            }
            if (proc.pre.body.length > 3) {
                code.push(processBlock(proc.pre, proc, dtypes));
            }
            var body = processBlock(proc.body, proc, dtypes);
            var matched = countMatches(loopOrders);
            if (matched < dimension) {
                code.push(outerFill(matched, loopOrders[0], proc, body));
            } else {
                code.push(innerFill(loopOrders[0], proc, body));
            }
            if (proc.post.body.length > 3) {
                code.push(processBlock(proc.post, proc, dtypes));
            }
            if (proc.debug) {
                console.log("-----Generated cwise routine for ", typesig, ":\n" + code.join("\n") + "\n----------");
            }
            var loopName = [ proc.funcName || "unnamed", "_cwise_loop_", orders[0].join("s"), "m", matched, typeSummary(dtypes) ].join("");
            var f = new Function([ "function ", loopName, "(", arglist.join(","), "){", code.join("\n"), "} return ", loopName ].join(""));
            return f();
        }
        module.exports = generateCWiseOp;
    }, {
        uniq: 17
    } ],
    16: [ function(require, module, exports) {
        "use strict";
        var compile = require("./compile.js");
        function createThunk(proc) {
            var code = [ "'use strict'", "var CACHED={}" ];
            var vars = [];
            var thunkName = proc.funcName + "_cwise_thunk";
            code.push([ "return function ", thunkName, "(", proc.shimArgs.join(","), "){" ].join(""));
            var typesig = [];
            var string_typesig = [];
            var proc_args = [ [ "array", proc.arrayArgs[0], ".shape.slice(", Math.max(0, proc.arrayBlockIndices[i]), proc.arrayBlockIndices[i] < 0 ? "," + proc.arrayBlockIndices[i] + ")" : ")" ].join("") ];
            for (var i = 0; i < proc.arrayArgs.length; ++i) {
                var j = proc.arrayArgs[i];
                vars.push([ "t", j, "=array", j, ".dtype,", "r", j, "=array", j, ".order" ].join(""));
                typesig.push("t" + j);
                typesig.push("r" + j);
                string_typesig.push("t" + j);
                string_typesig.push("r" + j + ".join()");
                proc_args.push("array" + j + ".data");
                proc_args.push("array" + j + ".stride");
                proc_args.push("array" + j + ".offset|0");
            }
            for (var i = 0; i < proc.scalarArgs.length; ++i) {
                proc_args.push("scalar" + proc.scalarArgs[i]);
            }
            vars.push([ "type=[", string_typesig.join(","), "].join()" ].join(""));
            vars.push("proc=CACHED[type]");
            code.push("var " + vars.join(","));
            code.push([ "if(!proc){", "CACHED[type]=proc=compile([", typesig.join(","), "])}", "return proc(", proc_args.join(","), ")}" ].join(""));
            if (proc.debug) {
                console.log("-----Generated thunk:\n" + code.join("\n") + "\n----------");
            }
            var thunk = new Function("compile", code.join("\n"));
            return thunk(compile.bind(undefined, proc));
        }
        module.exports = createThunk;
    }, {
        "./compile.js": 15
    } ],
    17: [ function(require, module, exports) {
        "use strict";
        function unique_pred(list, compare) {
            var ptr = 1, len = list.length, a = list[0], b = list[0];
            for (var i = 1; i < len; ++i) {
                b = a;
                a = list[i];
                if (compare(a, b)) {
                    if (i === ptr) {
                        ptr++;
                        continue;
                    }
                    list[ptr++] = a;
                }
            }
            list.length = ptr;
            return list;
        }
        function unique_eq(list) {
            var ptr = 1, len = list.length, a = list[0], b = list[0];
            for (var i = 1; i < len; ++i, b = a) {
                b = a;
                a = list[i];
                if (a !== b) {
                    if (i === ptr) {
                        ptr++;
                        continue;
                    }
                    list[ptr++] = a;
                }
            }
            list.length = ptr;
            return list;
        }
        function unique(list, compare, sorted) {
            if (list.length === 0) {
                return list;
            }
            if (compare) {
                if (!sorted) {
                    list.sort(compare);
                }
                return unique_pred(list, compare);
            }
            if (!sorted) {
                list.sort();
            }
            return unique_eq(list);
        }
        module.exports = unique;
    }, {} ],
    18: [ function(require, module, exports) {
        "use strict";
        var esprima = require("esprima");
        var uniq = require("uniq");
        var PREFIX_COUNTER = 0;
        function CompiledArgument(name, lvalue, rvalue) {
            this.name = name;
            this.lvalue = lvalue;
            this.rvalue = rvalue;
            this.count = 0;
        }
        function CompiledRoutine(body, args, thisVars, localVars) {
            this.body = body;
            this.args = args;
            this.thisVars = thisVars;
            this.localVars = localVars;
        }
        function isGlobal(identifier) {
            if (identifier === "eval") {
                throw new Error("cwise-parser: eval() not allowed");
            }
            if (typeof window !== "undefined") {
                return identifier in window;
            } else if (typeof GLOBAL !== "undefined") {
                return identifier in GLOBAL;
            } else if (typeof self !== "undefined") {
                return identifier in self;
            } else {
                return false;
            }
        }
        function getArgNames(ast) {
            var params = ast.body[0].expression.callee.params;
            var names = new Array(params.length);
            for (var i = 0; i < params.length; ++i) {
                names[i] = params[i].name;
            }
            return names;
        }
        function preprocess(func) {
            var src = [ "(", func, ")()" ].join("");
            var ast = esprima.parse(src, {
                range: true
            });
            var prefix = "_inline_" + PREFIX_COUNTER++ + "_";
            var argNames = getArgNames(ast);
            var compiledArgs = new Array(argNames.length);
            for (var i = 0; i < argNames.length; ++i) {
                compiledArgs[i] = new CompiledArgument([ prefix, "arg", i, "_" ].join(""), false, false);
            }
            var exploded = new Array(src.length);
            for (var i = 0, n = src.length; i < n; ++i) {
                exploded[i] = src.charAt(i);
            }
            var localVars = [];
            var thisVars = [];
            var computedThis = false;
            function createLocal(id) {
                var nstr = prefix + id.replace(/\_/g, "__");
                localVars.push(nstr);
                return nstr;
            }
            function createThisVar(id) {
                var nstr = "this_" + id.replace(/\_/g, "__");
                thisVars.push(nstr);
                return nstr;
            }
            function rewrite(node, nstr) {
                var lo = node.range[0], hi = node.range[1];
                for (var i = lo + 1; i < hi; ++i) {
                    exploded[i] = "";
                }
                exploded[lo] = nstr;
            }
            function escapeString(str) {
                return "'" + str.replace(/\_/g, "\\_").replace(/\'/g, "'") + "'";
            }
            function source(node) {
                return exploded.slice(node.range[0], node.range[1]).join("");
            }
            var LVALUE = 1;
            var RVALUE = 2;
            function getUsage(node) {
                if (node.parent.type === "AssignmentExpression") {
                    if (node.parent.left === node) {
                        if (node.parent.operator === "=") {
                            return LVALUE;
                        }
                        return LVALUE | RVALUE;
                    }
                }
                if (node.parent.type === "UpdateExpression") {
                    return LVALUE | RVALUE;
                }
                return RVALUE;
            }
            (function visit(node, parent) {
                node.parent = parent;
                if (node.type === "MemberExpression") {
                    if (node.computed) {
                        visit(node.object, node);
                        visit(node.property, node);
                    } else if (node.object.type === "ThisExpression") {
                        rewrite(node, createThisVar(node.property.name));
                    } else {
                        visit(node.object, node);
                    }
                } else if (node.type === "ThisExpression") {
                    throw new Error("cwise-parser: Computed this is not allowed");
                } else if (node.type === "Identifier") {
                    var name = node.name;
                    var argNo = argNames.indexOf(name);
                    if (argNo >= 0) {
                        var carg = compiledArgs[argNo];
                        var usage = getUsage(node);
                        if (usage & LVALUE) {
                            carg.lvalue = true;
                        }
                        if (usage & RVALUE) {
                            carg.rvalue = true;
                        }
                        ++carg.count;
                        rewrite(node, carg.name);
                    } else if (isGlobal(name)) {} else {
                        rewrite(node, createLocal(name));
                    }
                } else if (node.type === "Literal") {
                    if (typeof node.value === "string") {
                        rewrite(node, escapeString(node.value));
                    }
                } else if (node.type === "WithStatement") {
                    throw new Error("cwise-parser: with() statements not allowed");
                } else {
                    var keys = Object.keys(node);
                    for (var i = 0, n = keys.length; i < n; ++i) {
                        if (keys[i] === "parent") {
                            continue;
                        }
                        var value = node[keys[i]];
                        if (value) {
                            if (value instanceof Array) {
                                for (var j = 0; j < value.length; ++j) {
                                    if (value[j] && typeof value[j].type === "string") {
                                        visit(value[j], node);
                                    }
                                }
                            } else if (typeof value.type === "string") {
                                visit(value, node);
                            }
                        }
                    }
                }
            })(ast.body[0].expression.callee.body, undefined);
            uniq(localVars);
            uniq(thisVars);
            var routine = new CompiledRoutine(source(ast.body[0].expression.callee.body), compiledArgs, thisVars, localVars);
            return routine;
        }
        module.exports = preprocess;
    }, {
        esprima: 19,
        uniq: 20
    } ],
    19: [ function(require, module, exports) {
        (function(root, factory) {
            "use strict";
            if (typeof define === "function" && define.amd) {
                define([ "exports" ], factory);
            } else if (typeof exports !== "undefined") {
                factory(exports);
            } else {
                factory(root.esprima = {});
            }
        })(this, function(exports) {
            "use strict";
            var Token, TokenName, Syntax, PropertyKind, Messages, Regex, source, strict, index, lineNumber, lineStart, length, buffer, state, extra;
            Token = {
                BooleanLiteral: 1,
                EOF: 2,
                Identifier: 3,
                Keyword: 4,
                NullLiteral: 5,
                NumericLiteral: 6,
                Punctuator: 7,
                StringLiteral: 8
            };
            TokenName = {};
            TokenName[Token.BooleanLiteral] = "Boolean";
            TokenName[Token.EOF] = "<end>";
            TokenName[Token.Identifier] = "Identifier";
            TokenName[Token.Keyword] = "Keyword";
            TokenName[Token.NullLiteral] = "Null";
            TokenName[Token.NumericLiteral] = "Numeric";
            TokenName[Token.Punctuator] = "Punctuator";
            TokenName[Token.StringLiteral] = "String";
            Syntax = {
                AssignmentExpression: "AssignmentExpression",
                ArrayExpression: "ArrayExpression",
                BlockStatement: "BlockStatement",
                BinaryExpression: "BinaryExpression",
                BreakStatement: "BreakStatement",
                CallExpression: "CallExpression",
                CatchClause: "CatchClause",
                ConditionalExpression: "ConditionalExpression",
                ContinueStatement: "ContinueStatement",
                DoWhileStatement: "DoWhileStatement",
                DebuggerStatement: "DebuggerStatement",
                EmptyStatement: "EmptyStatement",
                ExpressionStatement: "ExpressionStatement",
                ForStatement: "ForStatement",
                ForInStatement: "ForInStatement",
                FunctionDeclaration: "FunctionDeclaration",
                FunctionExpression: "FunctionExpression",
                Identifier: "Identifier",
                IfStatement: "IfStatement",
                Literal: "Literal",
                LabeledStatement: "LabeledStatement",
                LogicalExpression: "LogicalExpression",
                MemberExpression: "MemberExpression",
                NewExpression: "NewExpression",
                ObjectExpression: "ObjectExpression",
                Program: "Program",
                Property: "Property",
                ReturnStatement: "ReturnStatement",
                SequenceExpression: "SequenceExpression",
                SwitchStatement: "SwitchStatement",
                SwitchCase: "SwitchCase",
                ThisExpression: "ThisExpression",
                ThrowStatement: "ThrowStatement",
                TryStatement: "TryStatement",
                UnaryExpression: "UnaryExpression",
                UpdateExpression: "UpdateExpression",
                VariableDeclaration: "VariableDeclaration",
                VariableDeclarator: "VariableDeclarator",
                WhileStatement: "WhileStatement",
                WithStatement: "WithStatement"
            };
            PropertyKind = {
                Data: 1,
                Get: 2,
                Set: 4
            };
            Messages = {
                UnexpectedToken: "Unexpected token %0",
                UnexpectedNumber: "Unexpected number",
                UnexpectedString: "Unexpected string",
                UnexpectedIdentifier: "Unexpected identifier",
                UnexpectedReserved: "Unexpected reserved word",
                UnexpectedEOS: "Unexpected end of input",
                NewlineAfterThrow: "Illegal newline after throw",
                InvalidRegExp: "Invalid regular expression",
                UnterminatedRegExp: "Invalid regular expression: missing /",
                InvalidLHSInAssignment: "Invalid left-hand side in assignment",
                InvalidLHSInForIn: "Invalid left-hand side in for-in",
                MultipleDefaultsInSwitch: "More than one default clause in switch statement",
                NoCatchOrFinally: "Missing catch or finally after try",
                UnknownLabel: "Undefined label '%0'",
                Redeclaration: "%0 '%1' has already been declared",
                IllegalContinue: "Illegal continue statement",
                IllegalBreak: "Illegal break statement",
                IllegalReturn: "Illegal return statement",
                StrictModeWith: "Strict mode code may not include a with statement",
                StrictCatchVariable: "Catch variable may not be eval or arguments in strict mode",
                StrictVarName: "Variable name may not be eval or arguments in strict mode",
                StrictParamName: "Parameter name eval or arguments is not allowed in strict mode",
                StrictParamDupe: "Strict mode function may not have duplicate parameter names",
                StrictFunctionName: "Function name may not be eval or arguments in strict mode",
                StrictOctalLiteral: "Octal literals are not allowed in strict mode.",
                StrictDelete: "Delete of an unqualified identifier in strict mode.",
                StrictDuplicateProperty: "Duplicate data property in object literal not allowed in strict mode",
                AccessorDataProperty: "Object literal may not have data and accessor property with the same name",
                AccessorGetSet: "Object literal may not have multiple get/set accessors with the same name",
                StrictLHSAssignment: "Assignment to eval or arguments is not allowed in strict mode",
                StrictLHSPostfix: "Postfix increment/decrement may not have eval or arguments operand in strict mode",
                StrictLHSPrefix: "Prefix increment/decrement may not have eval or arguments operand in strict mode",
                StrictReservedWord: "Use of future reserved word in strict mode"
            };
            Regex = {
                NonAsciiIdentifierStart: new RegExp("[ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԧԱ-Ֆՙա-ևא-תװ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࢠࢢ-ࢬऄ-हऽॐक़-ॡॱ-ॷॹ-ॿঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-ళవ-హఽౘౙౠౡಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೞೠೡೱೲഅ-ഌഎ-ഐഒ-ഺഽൎൠൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄງຈຊຍດ-ທນ-ຟມ-ຣລວສຫອ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏼᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛰᜀ-ᜌᜎ-ᜑᜠ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡷᢀ-ᢨᢪᢰ-ᣵᤀ-ᤜᥐ-ᥭᥰ-ᥴᦀ-ᦫᧁ-ᧇᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭋᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᳩ-ᳬᳮ-ᳱᳵᳶᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕℙ-ℝℤΩℨK-ℭℯ-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-Ⱞⰰ-ⱞⱠ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞⸯ々-〇〡-〩〱-〵〸-〼ぁ-ゖゝ-ゟァ-ヺー-ヿㄅ-ㄭㄱ-ㆎㆠ-ㆺㇰ-ㇿ㐀-䶵一-鿌ꀀ-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚗꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꞎꞐ-ꞓꞠ-Ɦꟸ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꪀ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꯀ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ]"),
                NonAsciiIdentifierPart: new RegExp("[ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮ̀-ʹͶͷͺ-ͽΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁ҃-҇Ҋ-ԧԱ-Ֆՙա-և֑-ׇֽֿׁׂׅׄא-תװ-ײؐ-ؚؠ-٩ٮ-ۓە-ۜ۟-۪ۨ-ۼۿܐ-݊ݍ-ޱ߀-ߵߺࠀ-࠭ࡀ-࡛ࢠࢢ-ࢬࣤ-ࣾऀ-ॣ०-९ॱ-ॷॹ-ॿঁ-ঃঅ-ঌএঐও-নপ-রলশ-হ়-ৄেৈো-ৎৗড়ঢ়য়-ৣ০-ৱਁ-ਃਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹ਼ਾ-ੂੇੈੋ-੍ੑਖ਼-ੜਫ਼੦-ੵઁ-ઃઅ-ઍએ-ઑઓ-નપ-રલળવ-હ઼-ૅે-ૉો-્ૐૠ-ૣ૦-૯ଁ-ଃଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହ଼-ୄେୈୋ-୍ୖୗଡ଼ଢ଼ୟ-ୣ୦-୯ୱஂஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹா-ூெ-ைொ-்ௐௗ௦-௯ఁ-ఃఅ-ఌఎ-ఐఒ-నప-ళవ-హఽ-ౄె-ైొ-్ౕౖౘౙౠ-ౣ౦-౯ಂಃಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹ಼-ೄೆ-ೈೊ-್ೕೖೞೠ-ೣ೦-೯ೱೲംഃഅ-ഌഎ-ഐഒ-ഺഽ-ൄെ-ൈൊ-ൎൗൠ-ൣ൦-൯ൺ-ൿංඃඅ-ඖක-නඳ-රලව-ෆ්ා-ුූෘ-ෟෲෳก-ฺเ-๎๐-๙ກຂຄງຈຊຍດ-ທນ-ຟມ-ຣລວສຫອ-ູົ-ຽເ-ໄໆ່-ໍ໐-໙ໜ-ໟༀ༘༙༠-༩༹༵༷༾-ཇཉ-ཬཱ-྄྆-ྗྙ-ྼ࿆က-၉ၐ-ႝႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚ፝-፟ᎀ-ᎏᎠ-Ᏼᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛰᜀ-ᜌᜎ-᜔ᜠ-᜴ᝀ-ᝓᝠ-ᝬᝮ-ᝰᝲᝳក-៓ៗៜ៝០-៩᠋-᠍᠐-᠙ᠠ-ᡷᢀ-ᢪᢰ-ᣵᤀ-ᤜᤠ-ᤫᤰ-᤻᥆-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉ᧐-᧙ᨀ-ᨛᨠ-ᩞ᩠-᩿᩼-᪉᪐-᪙ᪧᬀ-ᭋ᭐-᭙᭫-᭳ᮀ-᯳ᰀ-᰷᱀-᱉ᱍ-ᱽ᳐-᳔᳒-ᳶᴀ-ᷦ᷼-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼ‌‍‿⁀⁔ⁱⁿₐ-ₜ⃐-⃥⃜⃡-⃰ℂℇℊ-ℓℕℙ-ℝℤΩℨK-ℭℯ-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-Ⱞⰰ-ⱞⱠ-ⳤⳫ-ⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯ⵿-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞⷠ-ⷿⸯ々-〇〡-〯〱-〵〸-〼ぁ-ゖ゙゚ゝ-ゟァ-ヺー-ヿㄅ-ㄭㄱ-ㆎㆠ-ㆺㇰ-ㇿ㐀-䶵一-鿌ꀀ-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘫꙀ-꙯ꙴ-꙽ꙿ-ꚗꚟ-꛱ꜗ-ꜟꜢ-ꞈꞋ-ꞎꞐ-ꞓꞠ-Ɦꟸ-ꠧꡀ-ꡳꢀ-꣄꣐-꣙꣠-ꣷꣻ꤀-꤭ꤰ-꥓ꥠ-ꥼꦀ-꧀ꧏ-꧙ꨀ-ꨶꩀ-ꩍ꩐-꩙ꩠ-ꩶꩺꩻꪀ-ꫂꫛ-ꫝꫠ-ꫯꫲ-꫶ꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꯀ-ꯪ꯬꯭꯰-꯹가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻ︀-️︠-︦︳︴﹍-﹏ﹰ-ﹴﹶ-ﻼ０-９Ａ-Ｚ＿ａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ]")
            };
            function assert(condition, message) {
                if (!condition) {
                    throw new Error("ASSERT: " + message);
                }
            }
            function sliceSource(from, to) {
                return source.slice(from, to);
            }
            if (typeof "esprima"[0] === "undefined") {
                sliceSource = function sliceArraySource(from, to) {
                    return source.slice(from, to).join("");
                };
            }
            function isDecimalDigit(ch) {
                return "0123456789".indexOf(ch) >= 0;
            }
            function isHexDigit(ch) {
                return "0123456789abcdefABCDEF".indexOf(ch) >= 0;
            }
            function isOctalDigit(ch) {
                return "01234567".indexOf(ch) >= 0;
            }
            function isWhiteSpace(ch) {
                return ch === " " || ch === "	" || ch === "" || ch === "\f" || ch === " " || ch.charCodeAt(0) >= 5760 && " ᠎             　\ufeff".indexOf(ch) >= 0;
            }
            function isLineTerminator(ch) {
                return ch === "\n" || ch === "\r" || ch === "\u2028" || ch === "\u2029";
            }
            function isIdentifierStart(ch) {
                return ch === "$" || ch === "_" || ch === "\\" || ch >= "a" && ch <= "z" || ch >= "A" && ch <= "Z" || ch.charCodeAt(0) >= 128 && Regex.NonAsciiIdentifierStart.test(ch);
            }
            function isIdentifierPart(ch) {
                return ch === "$" || ch === "_" || ch === "\\" || ch >= "a" && ch <= "z" || ch >= "A" && ch <= "Z" || ch >= "0" && ch <= "9" || ch.charCodeAt(0) >= 128 && Regex.NonAsciiIdentifierPart.test(ch);
            }
            function isFutureReservedWord(id) {
                switch (id) {
                  case "class":
                  case "enum":
                  case "export":
                  case "extends":
                  case "import":
                  case "super":
                    return true;
                }
                return false;
            }
            function isStrictModeReservedWord(id) {
                switch (id) {
                  case "implements":
                  case "interface":
                  case "package":
                  case "private":
                  case "protected":
                  case "public":
                  case "static":
                  case "yield":
                  case "let":
                    return true;
                }
                return false;
            }
            function isRestrictedWord(id) {
                return id === "eval" || id === "arguments";
            }
            function isKeyword(id) {
                var keyword = false;
                switch (id.length) {
                  case 2:
                    keyword = id === "if" || id === "in" || id === "do";
                    break;

                  case 3:
                    keyword = id === "var" || id === "for" || id === "new" || id === "try";
                    break;

                  case 4:
                    keyword = id === "this" || id === "else" || id === "case" || id === "void" || id === "with";
                    break;

                  case 5:
                    keyword = id === "while" || id === "break" || id === "catch" || id === "throw";
                    break;

                  case 6:
                    keyword = id === "return" || id === "typeof" || id === "delete" || id === "switch";
                    break;

                  case 7:
                    keyword = id === "default" || id === "finally";
                    break;

                  case 8:
                    keyword = id === "function" || id === "continue" || id === "debugger";
                    break;

                  case 10:
                    keyword = id === "instanceof";
                    break;
                }
                if (keyword) {
                    return true;
                }
                switch (id) {
                  case "const":
                    return true;

                  case "yield":
                  case "let":
                    return true;
                }
                if (strict && isStrictModeReservedWord(id)) {
                    return true;
                }
                return isFutureReservedWord(id);
            }
            function skipComment() {
                var ch, blockComment, lineComment;
                blockComment = false;
                lineComment = false;
                while (index < length) {
                    ch = source[index];
                    if (lineComment) {
                        ch = source[index++];
                        if (isLineTerminator(ch)) {
                            lineComment = false;
                            if (ch === "\r" && source[index] === "\n") {
                                ++index;
                            }
                            ++lineNumber;
                            lineStart = index;
                        }
                    } else if (blockComment) {
                        if (isLineTerminator(ch)) {
                            if (ch === "\r" && source[index + 1] === "\n") {
                                ++index;
                            }
                            ++lineNumber;
                            ++index;
                            lineStart = index;
                            if (index >= length) {
                                throwError({}, Messages.UnexpectedToken, "ILLEGAL");
                            }
                        } else {
                            ch = source[index++];
                            if (index >= length) {
                                throwError({}, Messages.UnexpectedToken, "ILLEGAL");
                            }
                            if (ch === "*") {
                                ch = source[index];
                                if (ch === "/") {
                                    ++index;
                                    blockComment = false;
                                }
                            }
                        }
                    } else if (ch === "/") {
                        ch = source[index + 1];
                        if (ch === "/") {
                            index += 2;
                            lineComment = true;
                        } else if (ch === "*") {
                            index += 2;
                            blockComment = true;
                            if (index >= length) {
                                throwError({}, Messages.UnexpectedToken, "ILLEGAL");
                            }
                        } else {
                            break;
                        }
                    } else if (isWhiteSpace(ch)) {
                        ++index;
                    } else if (isLineTerminator(ch)) {
                        ++index;
                        if (ch === "\r" && source[index] === "\n") {
                            ++index;
                        }
                        ++lineNumber;
                        lineStart = index;
                    } else {
                        break;
                    }
                }
            }
            function scanHexEscape(prefix) {
                var i, len, ch, code = 0;
                len = prefix === "u" ? 4 : 2;
                for (i = 0; i < len; ++i) {
                    if (index < length && isHexDigit(source[index])) {
                        ch = source[index++];
                        code = code * 16 + "0123456789abcdef".indexOf(ch.toLowerCase());
                    } else {
                        return "";
                    }
                }
                return String.fromCharCode(code);
            }
            function scanIdentifier() {
                var ch, start, id, restore;
                ch = source[index];
                if (!isIdentifierStart(ch)) {
                    return;
                }
                start = index;
                if (ch === "\\") {
                    ++index;
                    if (source[index] !== "u") {
                        return;
                    }
                    ++index;
                    restore = index;
                    ch = scanHexEscape("u");
                    if (ch) {
                        if (ch === "\\" || !isIdentifierStart(ch)) {
                            return;
                        }
                        id = ch;
                    } else {
                        index = restore;
                        id = "u";
                    }
                } else {
                    id = source[index++];
                }
                while (index < length) {
                    ch = source[index];
                    if (!isIdentifierPart(ch)) {
                        break;
                    }
                    if (ch === "\\") {
                        ++index;
                        if (source[index] !== "u") {
                            return;
                        }
                        ++index;
                        restore = index;
                        ch = scanHexEscape("u");
                        if (ch) {
                            if (ch === "\\" || !isIdentifierPart(ch)) {
                                return;
                            }
                            id += ch;
                        } else {
                            index = restore;
                            id += "u";
                        }
                    } else {
                        id += source[index++];
                    }
                }
                if (id.length === 1) {
                    return {
                        type: Token.Identifier,
                        value: id,
                        lineNumber: lineNumber,
                        lineStart: lineStart,
                        range: [ start, index ]
                    };
                }
                if (isKeyword(id)) {
                    return {
                        type: Token.Keyword,
                        value: id,
                        lineNumber: lineNumber,
                        lineStart: lineStart,
                        range: [ start, index ]
                    };
                }
                if (id === "null") {
                    return {
                        type: Token.NullLiteral,
                        value: id,
                        lineNumber: lineNumber,
                        lineStart: lineStart,
                        range: [ start, index ]
                    };
                }
                if (id === "true" || id === "false") {
                    return {
                        type: Token.BooleanLiteral,
                        value: id,
                        lineNumber: lineNumber,
                        lineStart: lineStart,
                        range: [ start, index ]
                    };
                }
                return {
                    type: Token.Identifier,
                    value: id,
                    lineNumber: lineNumber,
                    lineStart: lineStart,
                    range: [ start, index ]
                };
            }
            function scanPunctuator() {
                var start = index, ch1 = source[index], ch2, ch3, ch4;
                if (ch1 === ";" || ch1 === "{" || ch1 === "}") {
                    ++index;
                    return {
                        type: Token.Punctuator,
                        value: ch1,
                        lineNumber: lineNumber,
                        lineStart: lineStart,
                        range: [ start, index ]
                    };
                }
                if (ch1 === "," || ch1 === "(" || ch1 === ")") {
                    ++index;
                    return {
                        type: Token.Punctuator,
                        value: ch1,
                        lineNumber: lineNumber,
                        lineStart: lineStart,
                        range: [ start, index ]
                    };
                }
                ch2 = source[index + 1];
                if (ch1 === "." && !isDecimalDigit(ch2)) {
                    return {
                        type: Token.Punctuator,
                        value: source[index++],
                        lineNumber: lineNumber,
                        lineStart: lineStart,
                        range: [ start, index ]
                    };
                }
                ch3 = source[index + 2];
                ch4 = source[index + 3];
                if (ch1 === ">" && ch2 === ">" && ch3 === ">") {
                    if (ch4 === "=") {
                        index += 4;
                        return {
                            type: Token.Punctuator,
                            value: ">>>=",
                            lineNumber: lineNumber,
                            lineStart: lineStart,
                            range: [ start, index ]
                        };
                    }
                }
                if (ch1 === "=" && ch2 === "=" && ch3 === "=") {
                    index += 3;
                    return {
                        type: Token.Punctuator,
                        value: "===",
                        lineNumber: lineNumber,
                        lineStart: lineStart,
                        range: [ start, index ]
                    };
                }
                if (ch1 === "!" && ch2 === "=" && ch3 === "=") {
                    index += 3;
                    return {
                        type: Token.Punctuator,
                        value: "!==",
                        lineNumber: lineNumber,
                        lineStart: lineStart,
                        range: [ start, index ]
                    };
                }
                if (ch1 === ">" && ch2 === ">" && ch3 === ">") {
                    index += 3;
                    return {
                        type: Token.Punctuator,
                        value: ">>>",
                        lineNumber: lineNumber,
                        lineStart: lineStart,
                        range: [ start, index ]
                    };
                }
                if (ch1 === "<" && ch2 === "<" && ch3 === "=") {
                    index += 3;
                    return {
                        type: Token.Punctuator,
                        value: "<<=",
                        lineNumber: lineNumber,
                        lineStart: lineStart,
                        range: [ start, index ]
                    };
                }
                if (ch1 === ">" && ch2 === ">" && ch3 === "=") {
                    index += 3;
                    return {
                        type: Token.Punctuator,
                        value: ">>=",
                        lineNumber: lineNumber,
                        lineStart: lineStart,
                        range: [ start, index ]
                    };
                }
                if (ch2 === "=") {
                    if ("<>=!+-*%&|^/".indexOf(ch1) >= 0) {
                        index += 2;
                        return {
                            type: Token.Punctuator,
                            value: ch1 + ch2,
                            lineNumber: lineNumber,
                            lineStart: lineStart,
                            range: [ start, index ]
                        };
                    }
                }
                if (ch1 === ch2 && "+-<>&|".indexOf(ch1) >= 0) {
                    if ("+-<>&|".indexOf(ch2) >= 0) {
                        index += 2;
                        return {
                            type: Token.Punctuator,
                            value: ch1 + ch2,
                            lineNumber: lineNumber,
                            lineStart: lineStart,
                            range: [ start, index ]
                        };
                    }
                }
                if ("[]<>+-*%&|^!~?:=/".indexOf(ch1) >= 0) {
                    return {
                        type: Token.Punctuator,
                        value: source[index++],
                        lineNumber: lineNumber,
                        lineStart: lineStart,
                        range: [ start, index ]
                    };
                }
            }
            function scanNumericLiteral() {
                var number, start, ch;
                ch = source[index];
                assert(isDecimalDigit(ch) || ch === ".", "Numeric literal must start with a decimal digit or a decimal point");
                start = index;
                number = "";
                if (ch !== ".") {
                    number = source[index++];
                    ch = source[index];
                    if (number === "0") {
                        if (ch === "x" || ch === "X") {
                            number += source[index++];
                            while (index < length) {
                                ch = source[index];
                                if (!isHexDigit(ch)) {
                                    break;
                                }
                                number += source[index++];
                            }
                            if (number.length <= 2) {
                                throwError({}, Messages.UnexpectedToken, "ILLEGAL");
                            }
                            if (index < length) {
                                ch = source[index];
                                if (isIdentifierStart(ch)) {
                                    throwError({}, Messages.UnexpectedToken, "ILLEGAL");
                                }
                            }
                            return {
                                type: Token.NumericLiteral,
                                value: parseInt(number, 16),
                                lineNumber: lineNumber,
                                lineStart: lineStart,
                                range: [ start, index ]
                            };
                        } else if (isOctalDigit(ch)) {
                            number += source[index++];
                            while (index < length) {
                                ch = source[index];
                                if (!isOctalDigit(ch)) {
                                    break;
                                }
                                number += source[index++];
                            }
                            if (index < length) {
                                ch = source[index];
                                if (isIdentifierStart(ch) || isDecimalDigit(ch)) {
                                    throwError({}, Messages.UnexpectedToken, "ILLEGAL");
                                }
                            }
                            return {
                                type: Token.NumericLiteral,
                                value: parseInt(number, 8),
                                octal: true,
                                lineNumber: lineNumber,
                                lineStart: lineStart,
                                range: [ start, index ]
                            };
                        }
                        if (isDecimalDigit(ch)) {
                            throwError({}, Messages.UnexpectedToken, "ILLEGAL");
                        }
                    }
                    while (index < length) {
                        ch = source[index];
                        if (!isDecimalDigit(ch)) {
                            break;
                        }
                        number += source[index++];
                    }
                }
                if (ch === ".") {
                    number += source[index++];
                    while (index < length) {
                        ch = source[index];
                        if (!isDecimalDigit(ch)) {
                            break;
                        }
                        number += source[index++];
                    }
                }
                if (ch === "e" || ch === "E") {
                    number += source[index++];
                    ch = source[index];
                    if (ch === "+" || ch === "-") {
                        number += source[index++];
                    }
                    ch = source[index];
                    if (isDecimalDigit(ch)) {
                        number += source[index++];
                        while (index < length) {
                            ch = source[index];
                            if (!isDecimalDigit(ch)) {
                                break;
                            }
                            number += source[index++];
                        }
                    } else {
                        ch = "character " + ch;
                        if (index >= length) {
                            ch = "<end>";
                        }
                        throwError({}, Messages.UnexpectedToken, "ILLEGAL");
                    }
                }
                if (index < length) {
                    ch = source[index];
                    if (isIdentifierStart(ch)) {
                        throwError({}, Messages.UnexpectedToken, "ILLEGAL");
                    }
                }
                return {
                    type: Token.NumericLiteral,
                    value: parseFloat(number),
                    lineNumber: lineNumber,
                    lineStart: lineStart,
                    range: [ start, index ]
                };
            }
            function scanStringLiteral() {
                var str = "", quote, start, ch, code, unescaped, restore, octal = false;
                quote = source[index];
                assert(quote === "'" || quote === '"', "String literal must starts with a quote");
                start = index;
                ++index;
                while (index < length) {
                    ch = source[index++];
                    if (ch === quote) {
                        quote = "";
                        break;
                    } else if (ch === "\\") {
                        ch = source[index++];
                        if (!isLineTerminator(ch)) {
                            switch (ch) {
                              case "n":
                                str += "\n";
                                break;

                              case "r":
                                str += "\r";
                                break;

                              case "t":
                                str += "	";
                                break;

                              case "u":
                              case "x":
                                restore = index;
                                unescaped = scanHexEscape(ch);
                                if (unescaped) {
                                    str += unescaped;
                                } else {
                                    index = restore;
                                    str += ch;
                                }
                                break;

                              case "b":
                                str += "\b";
                                break;

                              case "f":
                                str += "\f";
                                break;

                              case "v":
                                str += "";
                                break;

                              default:
                                if (isOctalDigit(ch)) {
                                    code = "01234567".indexOf(ch);
                                    if (code !== 0) {
                                        octal = true;
                                    }
                                    if (index < length && isOctalDigit(source[index])) {
                                        octal = true;
                                        code = code * 8 + "01234567".indexOf(source[index++]);
                                        if ("0123".indexOf(ch) >= 0 && index < length && isOctalDigit(source[index])) {
                                            code = code * 8 + "01234567".indexOf(source[index++]);
                                        }
                                    }
                                    str += String.fromCharCode(code);
                                } else {
                                    str += ch;
                                }
                                break;
                            }
                        } else {
                            ++lineNumber;
                            if (ch === "\r" && source[index] === "\n") {
                                ++index;
                            }
                        }
                    } else if (isLineTerminator(ch)) {
                        break;
                    } else {
                        str += ch;
                    }
                }
                if (quote !== "") {
                    throwError({}, Messages.UnexpectedToken, "ILLEGAL");
                }
                return {
                    type: Token.StringLiteral,
                    value: str,
                    octal: octal,
                    lineNumber: lineNumber,
                    lineStart: lineStart,
                    range: [ start, index ]
                };
            }
            function scanRegExp() {
                var str, ch, start, pattern, flags, value, classMarker = false, restore, terminated = false;
                buffer = null;
                skipComment();
                start = index;
                ch = source[index];
                assert(ch === "/", "Regular expression literal must start with a slash");
                str = source[index++];
                while (index < length) {
                    ch = source[index++];
                    str += ch;
                    if (ch === "\\") {
                        ch = source[index++];
                        if (isLineTerminator(ch)) {
                            throwError({}, Messages.UnterminatedRegExp);
                        }
                        str += ch;
                    } else if (classMarker) {
                        if (ch === "]") {
                            classMarker = false;
                        }
                    } else {
                        if (ch === "/") {
                            terminated = true;
                            break;
                        } else if (ch === "[") {
                            classMarker = true;
                        } else if (isLineTerminator(ch)) {
                            throwError({}, Messages.UnterminatedRegExp);
                        }
                    }
                }
                if (!terminated) {
                    throwError({}, Messages.UnterminatedRegExp);
                }
                pattern = str.substr(1, str.length - 2);
                flags = "";
                while (index < length) {
                    ch = source[index];
                    if (!isIdentifierPart(ch)) {
                        break;
                    }
                    ++index;
                    if (ch === "\\" && index < length) {
                        ch = source[index];
                        if (ch === "u") {
                            ++index;
                            restore = index;
                            ch = scanHexEscape("u");
                            if (ch) {
                                flags += ch;
                                str += "\\u";
                                for (;restore < index; ++restore) {
                                    str += source[restore];
                                }
                            } else {
                                index = restore;
                                flags += "u";
                                str += "\\u";
                            }
                        } else {
                            str += "\\";
                        }
                    } else {
                        flags += ch;
                        str += ch;
                    }
                }
                try {
                    value = new RegExp(pattern, flags);
                } catch (e) {
                    throwError({}, Messages.InvalidRegExp);
                }
                return {
                    literal: str,
                    value: value,
                    range: [ start, index ]
                };
            }
            function isIdentifierName(token) {
                return token.type === Token.Identifier || token.type === Token.Keyword || token.type === Token.BooleanLiteral || token.type === Token.NullLiteral;
            }
            function advance() {
                var ch, token;
                skipComment();
                if (index >= length) {
                    return {
                        type: Token.EOF,
                        lineNumber: lineNumber,
                        lineStart: lineStart,
                        range: [ index, index ]
                    };
                }
                token = scanPunctuator();
                if (typeof token !== "undefined") {
                    return token;
                }
                ch = source[index];
                if (ch === "'" || ch === '"') {
                    return scanStringLiteral();
                }
                if (ch === "." || isDecimalDigit(ch)) {
                    return scanNumericLiteral();
                }
                token = scanIdentifier();
                if (typeof token !== "undefined") {
                    return token;
                }
                throwError({}, Messages.UnexpectedToken, "ILLEGAL");
            }
            function lex() {
                var token;
                if (buffer) {
                    index = buffer.range[1];
                    lineNumber = buffer.lineNumber;
                    lineStart = buffer.lineStart;
                    token = buffer;
                    buffer = null;
                    return token;
                }
                buffer = null;
                return advance();
            }
            function lookahead() {
                var pos, line, start;
                if (buffer !== null) {
                    return buffer;
                }
                pos = index;
                line = lineNumber;
                start = lineStart;
                buffer = advance();
                index = pos;
                lineNumber = line;
                lineStart = start;
                return buffer;
            }
            function peekLineTerminator() {
                var pos, line, start, found;
                pos = index;
                line = lineNumber;
                start = lineStart;
                skipComment();
                found = lineNumber !== line;
                index = pos;
                lineNumber = line;
                lineStart = start;
                return found;
            }
            function throwError(token, messageFormat) {
                var error, args = Array.prototype.slice.call(arguments, 2), msg = messageFormat.replace(/%(\d)/g, function(whole, index) {
                    return args[index] || "";
                });
                if (typeof token.lineNumber === "number") {
                    error = new Error("Line " + token.lineNumber + ": " + msg);
                    error.index = token.range[0];
                    error.lineNumber = token.lineNumber;
                    error.column = token.range[0] - lineStart + 1;
                } else {
                    error = new Error("Line " + lineNumber + ": " + msg);
                    error.index = index;
                    error.lineNumber = lineNumber;
                    error.column = index - lineStart + 1;
                }
                throw error;
            }
            function throwErrorTolerant() {
                try {
                    throwError.apply(null, arguments);
                } catch (e) {
                    if (extra.errors) {
                        extra.errors.push(e);
                    } else {
                        throw e;
                    }
                }
            }
            function throwUnexpected(token) {
                if (token.type === Token.EOF) {
                    throwError(token, Messages.UnexpectedEOS);
                }
                if (token.type === Token.NumericLiteral) {
                    throwError(token, Messages.UnexpectedNumber);
                }
                if (token.type === Token.StringLiteral) {
                    throwError(token, Messages.UnexpectedString);
                }
                if (token.type === Token.Identifier) {
                    throwError(token, Messages.UnexpectedIdentifier);
                }
                if (token.type === Token.Keyword) {
                    if (isFutureReservedWord(token.value)) {
                        throwError(token, Messages.UnexpectedReserved);
                    } else if (strict && isStrictModeReservedWord(token.value)) {
                        throwErrorTolerant(token, Messages.StrictReservedWord);
                        return;
                    }
                    throwError(token, Messages.UnexpectedToken, token.value);
                }
                throwError(token, Messages.UnexpectedToken, token.value);
            }
            function expect(value) {
                var token = lex();
                if (token.type !== Token.Punctuator || token.value !== value) {
                    throwUnexpected(token);
                }
            }
            function expectKeyword(keyword) {
                var token = lex();
                if (token.type !== Token.Keyword || token.value !== keyword) {
                    throwUnexpected(token);
                }
            }
            function match(value) {
                var token = lookahead();
                return token.type === Token.Punctuator && token.value === value;
            }
            function matchKeyword(keyword) {
                var token = lookahead();
                return token.type === Token.Keyword && token.value === keyword;
            }
            function matchAssign() {
                var token = lookahead(), op = token.value;
                if (token.type !== Token.Punctuator) {
                    return false;
                }
                return op === "=" || op === "*=" || op === "/=" || op === "%=" || op === "+=" || op === "-=" || op === "<<=" || op === ">>=" || op === ">>>=" || op === "&=" || op === "^=" || op === "|=";
            }
            function consumeSemicolon() {
                var token, line;
                if (source[index] === ";") {
                    lex();
                    return;
                }
                line = lineNumber;
                skipComment();
                if (lineNumber !== line) {
                    return;
                }
                if (match(";")) {
                    lex();
                    return;
                }
                token = lookahead();
                if (token.type !== Token.EOF && !match("}")) {
                    throwUnexpected(token);
                }
            }
            function isLeftHandSide(expr) {
                return expr.type === Syntax.Identifier || expr.type === Syntax.MemberExpression;
            }
            function parseArrayInitialiser() {
                var elements = [];
                expect("[");
                while (!match("]")) {
                    if (match(",")) {
                        lex();
                        elements.push(null);
                    } else {
                        elements.push(parseAssignmentExpression());
                        if (!match("]")) {
                            expect(",");
                        }
                    }
                }
                expect("]");
                return {
                    type: Syntax.ArrayExpression,
                    elements: elements
                };
            }
            function parsePropertyFunction(param, first) {
                var previousStrict, body;
                previousStrict = strict;
                body = parseFunctionSourceElements();
                if (first && strict && isRestrictedWord(param[0].name)) {
                    throwErrorTolerant(first, Messages.StrictParamName);
                }
                strict = previousStrict;
                return {
                    type: Syntax.FunctionExpression,
                    id: null,
                    params: param,
                    defaults: [],
                    body: body,
                    rest: null,
                    generator: false,
                    expression: false
                };
            }
            function parseObjectPropertyKey() {
                var token = lex();
                if (token.type === Token.StringLiteral || token.type === Token.NumericLiteral) {
                    if (strict && token.octal) {
                        throwErrorTolerant(token, Messages.StrictOctalLiteral);
                    }
                    return createLiteral(token);
                }
                return {
                    type: Syntax.Identifier,
                    name: token.value
                };
            }
            function parseObjectProperty() {
                var token, key, id, param;
                token = lookahead();
                if (token.type === Token.Identifier) {
                    id = parseObjectPropertyKey();
                    if (token.value === "get" && !match(":")) {
                        key = parseObjectPropertyKey();
                        expect("(");
                        expect(")");
                        return {
                            type: Syntax.Property,
                            key: key,
                            value: parsePropertyFunction([]),
                            kind: "get"
                        };
                    } else if (token.value === "set" && !match(":")) {
                        key = parseObjectPropertyKey();
                        expect("(");
                        token = lookahead();
                        if (token.type !== Token.Identifier) {
                            expect(")");
                            throwErrorTolerant(token, Messages.UnexpectedToken, token.value);
                            return {
                                type: Syntax.Property,
                                key: key,
                                value: parsePropertyFunction([]),
                                kind: "set"
                            };
                        } else {
                            param = [ parseVariableIdentifier() ];
                            expect(")");
                            return {
                                type: Syntax.Property,
                                key: key,
                                value: parsePropertyFunction(param, token),
                                kind: "set"
                            };
                        }
                    } else {
                        expect(":");
                        return {
                            type: Syntax.Property,
                            key: id,
                            value: parseAssignmentExpression(),
                            kind: "init"
                        };
                    }
                } else if (token.type === Token.EOF || token.type === Token.Punctuator) {
                    throwUnexpected(token);
                } else {
                    key = parseObjectPropertyKey();
                    expect(":");
                    return {
                        type: Syntax.Property,
                        key: key,
                        value: parseAssignmentExpression(),
                        kind: "init"
                    };
                }
            }
            function parseObjectInitialiser() {
                var properties = [], property, name, kind, map = {}, toString = String;
                expect("{");
                while (!match("}")) {
                    property = parseObjectProperty();
                    if (property.key.type === Syntax.Identifier) {
                        name = property.key.name;
                    } else {
                        name = toString(property.key.value);
                    }
                    kind = property.kind === "init" ? PropertyKind.Data : property.kind === "get" ? PropertyKind.Get : PropertyKind.Set;
                    if (Object.prototype.hasOwnProperty.call(map, name)) {
                        if (map[name] === PropertyKind.Data) {
                            if (strict && kind === PropertyKind.Data) {
                                throwErrorTolerant({}, Messages.StrictDuplicateProperty);
                            } else if (kind !== PropertyKind.Data) {
                                throwErrorTolerant({}, Messages.AccessorDataProperty);
                            }
                        } else {
                            if (kind === PropertyKind.Data) {
                                throwErrorTolerant({}, Messages.AccessorDataProperty);
                            } else if (map[name] & kind) {
                                throwErrorTolerant({}, Messages.AccessorGetSet);
                            }
                        }
                        map[name] |= kind;
                    } else {
                        map[name] = kind;
                    }
                    properties.push(property);
                    if (!match("}")) {
                        expect(",");
                    }
                }
                expect("}");
                return {
                    type: Syntax.ObjectExpression,
                    properties: properties
                };
            }
            function parseGroupExpression() {
                var expr;
                expect("(");
                expr = parseExpression();
                expect(")");
                return expr;
            }
            function parsePrimaryExpression() {
                var token = lookahead(), type = token.type;
                if (type === Token.Identifier) {
                    return {
                        type: Syntax.Identifier,
                        name: lex().value
                    };
                }
                if (type === Token.StringLiteral || type === Token.NumericLiteral) {
                    if (strict && token.octal) {
                        throwErrorTolerant(token, Messages.StrictOctalLiteral);
                    }
                    return createLiteral(lex());
                }
                if (type === Token.Keyword) {
                    if (matchKeyword("this")) {
                        lex();
                        return {
                            type: Syntax.ThisExpression
                        };
                    }
                    if (matchKeyword("function")) {
                        return parseFunctionExpression();
                    }
                }
                if (type === Token.BooleanLiteral) {
                    lex();
                    token.value = token.value === "true";
                    return createLiteral(token);
                }
                if (type === Token.NullLiteral) {
                    lex();
                    token.value = null;
                    return createLiteral(token);
                }
                if (match("[")) {
                    return parseArrayInitialiser();
                }
                if (match("{")) {
                    return parseObjectInitialiser();
                }
                if (match("(")) {
                    return parseGroupExpression();
                }
                if (match("/") || match("/=")) {
                    return createLiteral(scanRegExp());
                }
                return throwUnexpected(lex());
            }
            function parseArguments() {
                var args = [];
                expect("(");
                if (!match(")")) {
                    while (index < length) {
                        args.push(parseAssignmentExpression());
                        if (match(")")) {
                            break;
                        }
                        expect(",");
                    }
                }
                expect(")");
                return args;
            }
            function parseNonComputedProperty() {
                var token = lex();
                if (!isIdentifierName(token)) {
                    throwUnexpected(token);
                }
                return {
                    type: Syntax.Identifier,
                    name: token.value
                };
            }
            function parseNonComputedMember() {
                expect(".");
                return parseNonComputedProperty();
            }
            function parseComputedMember() {
                var expr;
                expect("[");
                expr = parseExpression();
                expect("]");
                return expr;
            }
            function parseNewExpression() {
                var expr;
                expectKeyword("new");
                expr = {
                    type: Syntax.NewExpression,
                    callee: parseLeftHandSideExpression(),
                    arguments: []
                };
                if (match("(")) {
                    expr["arguments"] = parseArguments();
                }
                return expr;
            }
            function parseLeftHandSideExpressionAllowCall() {
                var expr;
                expr = matchKeyword("new") ? parseNewExpression() : parsePrimaryExpression();
                while (match(".") || match("[") || match("(")) {
                    if (match("(")) {
                        expr = {
                            type: Syntax.CallExpression,
                            callee: expr,
                            arguments: parseArguments()
                        };
                    } else if (match("[")) {
                        expr = {
                            type: Syntax.MemberExpression,
                            computed: true,
                            object: expr,
                            property: parseComputedMember()
                        };
                    } else {
                        expr = {
                            type: Syntax.MemberExpression,
                            computed: false,
                            object: expr,
                            property: parseNonComputedMember()
                        };
                    }
                }
                return expr;
            }
            function parseLeftHandSideExpression() {
                var expr;
                expr = matchKeyword("new") ? parseNewExpression() : parsePrimaryExpression();
                while (match(".") || match("[")) {
                    if (match("[")) {
                        expr = {
                            type: Syntax.MemberExpression,
                            computed: true,
                            object: expr,
                            property: parseComputedMember()
                        };
                    } else {
                        expr = {
                            type: Syntax.MemberExpression,
                            computed: false,
                            object: expr,
                            property: parseNonComputedMember()
                        };
                    }
                }
                return expr;
            }
            function parsePostfixExpression() {
                var expr = parseLeftHandSideExpressionAllowCall(), token;
                token = lookahead();
                if (token.type !== Token.Punctuator) {
                    return expr;
                }
                if ((match("++") || match("--")) && !peekLineTerminator()) {
                    if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {
                        throwErrorTolerant({}, Messages.StrictLHSPostfix);
                    }
                    if (!isLeftHandSide(expr)) {
                        throwErrorTolerant({}, Messages.InvalidLHSInAssignment);
                    }
                    expr = {
                        type: Syntax.UpdateExpression,
                        operator: lex().value,
                        argument: expr,
                        prefix: false
                    };
                }
                return expr;
            }
            function parseUnaryExpression() {
                var token, expr;
                token = lookahead();
                if (token.type !== Token.Punctuator && token.type !== Token.Keyword) {
                    return parsePostfixExpression();
                }
                if (match("++") || match("--")) {
                    token = lex();
                    expr = parseUnaryExpression();
                    if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {
                        throwErrorTolerant({}, Messages.StrictLHSPrefix);
                    }
                    if (!isLeftHandSide(expr)) {
                        throwErrorTolerant({}, Messages.InvalidLHSInAssignment);
                    }
                    expr = {
                        type: Syntax.UpdateExpression,
                        operator: token.value,
                        argument: expr,
                        prefix: true
                    };
                    return expr;
                }
                if (match("+") || match("-") || match("~") || match("!")) {
                    expr = {
                        type: Syntax.UnaryExpression,
                        operator: lex().value,
                        argument: parseUnaryExpression(),
                        prefix: true
                    };
                    return expr;
                }
                if (matchKeyword("delete") || matchKeyword("void") || matchKeyword("typeof")) {
                    expr = {
                        type: Syntax.UnaryExpression,
                        operator: lex().value,
                        argument: parseUnaryExpression(),
                        prefix: true
                    };
                    if (strict && expr.operator === "delete" && expr.argument.type === Syntax.Identifier) {
                        throwErrorTolerant({}, Messages.StrictDelete);
                    }
                    return expr;
                }
                return parsePostfixExpression();
            }
            function parseMultiplicativeExpression() {
                var expr = parseUnaryExpression();
                while (match("*") || match("/") || match("%")) {
                    expr = {
                        type: Syntax.BinaryExpression,
                        operator: lex().value,
                        left: expr,
                        right: parseUnaryExpression()
                    };
                }
                return expr;
            }
            function parseAdditiveExpression() {
                var expr = parseMultiplicativeExpression();
                while (match("+") || match("-")) {
                    expr = {
                        type: Syntax.BinaryExpression,
                        operator: lex().value,
                        left: expr,
                        right: parseMultiplicativeExpression()
                    };
                }
                return expr;
            }
            function parseShiftExpression() {
                var expr = parseAdditiveExpression();
                while (match("<<") || match(">>") || match(">>>")) {
                    expr = {
                        type: Syntax.BinaryExpression,
                        operator: lex().value,
                        left: expr,
                        right: parseAdditiveExpression()
                    };
                }
                return expr;
            }
            function parseRelationalExpression() {
                var expr, previousAllowIn;
                previousAllowIn = state.allowIn;
                state.allowIn = true;
                expr = parseShiftExpression();
                while (match("<") || match(">") || match("<=") || match(">=") || previousAllowIn && matchKeyword("in") || matchKeyword("instanceof")) {
                    expr = {
                        type: Syntax.BinaryExpression,
                        operator: lex().value,
                        left: expr,
                        right: parseShiftExpression()
                    };
                }
                state.allowIn = previousAllowIn;
                return expr;
            }
            function parseEqualityExpression() {
                var expr = parseRelationalExpression();
                while (match("==") || match("!=") || match("===") || match("!==")) {
                    expr = {
                        type: Syntax.BinaryExpression,
                        operator: lex().value,
                        left: expr,
                        right: parseRelationalExpression()
                    };
                }
                return expr;
            }
            function parseBitwiseANDExpression() {
                var expr = parseEqualityExpression();
                while (match("&")) {
                    lex();
                    expr = {
                        type: Syntax.BinaryExpression,
                        operator: "&",
                        left: expr,
                        right: parseEqualityExpression()
                    };
                }
                return expr;
            }
            function parseBitwiseXORExpression() {
                var expr = parseBitwiseANDExpression();
                while (match("^")) {
                    lex();
                    expr = {
                        type: Syntax.BinaryExpression,
                        operator: "^",
                        left: expr,
                        right: parseBitwiseANDExpression()
                    };
                }
                return expr;
            }
            function parseBitwiseORExpression() {
                var expr = parseBitwiseXORExpression();
                while (match("|")) {
                    lex();
                    expr = {
                        type: Syntax.BinaryExpression,
                        operator: "|",
                        left: expr,
                        right: parseBitwiseXORExpression()
                    };
                }
                return expr;
            }
            function parseLogicalANDExpression() {
                var expr = parseBitwiseORExpression();
                while (match("&&")) {
                    lex();
                    expr = {
                        type: Syntax.LogicalExpression,
                        operator: "&&",
                        left: expr,
                        right: parseBitwiseORExpression()
                    };
                }
                return expr;
            }
            function parseLogicalORExpression() {
                var expr = parseLogicalANDExpression();
                while (match("||")) {
                    lex();
                    expr = {
                        type: Syntax.LogicalExpression,
                        operator: "||",
                        left: expr,
                        right: parseLogicalANDExpression()
                    };
                }
                return expr;
            }
            function parseConditionalExpression() {
                var expr, previousAllowIn, consequent;
                expr = parseLogicalORExpression();
                if (match("?")) {
                    lex();
                    previousAllowIn = state.allowIn;
                    state.allowIn = true;
                    consequent = parseAssignmentExpression();
                    state.allowIn = previousAllowIn;
                    expect(":");
                    expr = {
                        type: Syntax.ConditionalExpression,
                        test: expr,
                        consequent: consequent,
                        alternate: parseAssignmentExpression()
                    };
                }
                return expr;
            }
            function parseAssignmentExpression() {
                var token, expr;
                token = lookahead();
                expr = parseConditionalExpression();
                if (matchAssign()) {
                    if (!isLeftHandSide(expr)) {
                        throwErrorTolerant({}, Messages.InvalidLHSInAssignment);
                    }
                    if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {
                        throwErrorTolerant(token, Messages.StrictLHSAssignment);
                    }
                    expr = {
                        type: Syntax.AssignmentExpression,
                        operator: lex().value,
                        left: expr,
                        right: parseAssignmentExpression()
                    };
                }
                return expr;
            }
            function parseExpression() {
                var expr = parseAssignmentExpression();
                if (match(",")) {
                    expr = {
                        type: Syntax.SequenceExpression,
                        expressions: [ expr ]
                    };
                    while (index < length) {
                        if (!match(",")) {
                            break;
                        }
                        lex();
                        expr.expressions.push(parseAssignmentExpression());
                    }
                }
                return expr;
            }
            function parseStatementList() {
                var list = [], statement;
                while (index < length) {
                    if (match("}")) {
                        break;
                    }
                    statement = parseSourceElement();
                    if (typeof statement === "undefined") {
                        break;
                    }
                    list.push(statement);
                }
                return list;
            }
            function parseBlock() {
                var block;
                expect("{");
                block = parseStatementList();
                expect("}");
                return {
                    type: Syntax.BlockStatement,
                    body: block
                };
            }
            function parseVariableIdentifier() {
                var token = lex();
                if (token.type !== Token.Identifier) {
                    throwUnexpected(token);
                }
                return {
                    type: Syntax.Identifier,
                    name: token.value
                };
            }
            function parseVariableDeclaration(kind) {
                var id = parseVariableIdentifier(), init = null;
                if (strict && isRestrictedWord(id.name)) {
                    throwErrorTolerant({}, Messages.StrictVarName);
                }
                if (kind === "const") {
                    expect("=");
                    init = parseAssignmentExpression();
                } else if (match("=")) {
                    lex();
                    init = parseAssignmentExpression();
                }
                return {
                    type: Syntax.VariableDeclarator,
                    id: id,
                    init: init
                };
            }
            function parseVariableDeclarationList(kind) {
                var list = [];
                do {
                    list.push(parseVariableDeclaration(kind));
                    if (!match(",")) {
                        break;
                    }
                    lex();
                } while (index < length);
                return list;
            }
            function parseVariableStatement() {
                var declarations;
                expectKeyword("var");
                declarations = parseVariableDeclarationList();
                consumeSemicolon();
                return {
                    type: Syntax.VariableDeclaration,
                    declarations: declarations,
                    kind: "var"
                };
            }
            function parseConstLetDeclaration(kind) {
                var declarations;
                expectKeyword(kind);
                declarations = parseVariableDeclarationList(kind);
                consumeSemicolon();
                return {
                    type: Syntax.VariableDeclaration,
                    declarations: declarations,
                    kind: kind
                };
            }
            function parseEmptyStatement() {
                expect(";");
                return {
                    type: Syntax.EmptyStatement
                };
            }
            function parseExpressionStatement() {
                var expr = parseExpression();
                consumeSemicolon();
                return {
                    type: Syntax.ExpressionStatement,
                    expression: expr
                };
            }
            function parseIfStatement() {
                var test, consequent, alternate;
                expectKeyword("if");
                expect("(");
                test = parseExpression();
                expect(")");
                consequent = parseStatement();
                if (matchKeyword("else")) {
                    lex();
                    alternate = parseStatement();
                } else {
                    alternate = null;
                }
                return {
                    type: Syntax.IfStatement,
                    test: test,
                    consequent: consequent,
                    alternate: alternate
                };
            }
            function parseDoWhileStatement() {
                var body, test, oldInIteration;
                expectKeyword("do");
                oldInIteration = state.inIteration;
                state.inIteration = true;
                body = parseStatement();
                state.inIteration = oldInIteration;
                expectKeyword("while");
                expect("(");
                test = parseExpression();
                expect(")");
                if (match(";")) {
                    lex();
                }
                return {
                    type: Syntax.DoWhileStatement,
                    body: body,
                    test: test
                };
            }
            function parseWhileStatement() {
                var test, body, oldInIteration;
                expectKeyword("while");
                expect("(");
                test = parseExpression();
                expect(")");
                oldInIteration = state.inIteration;
                state.inIteration = true;
                body = parseStatement();
                state.inIteration = oldInIteration;
                return {
                    type: Syntax.WhileStatement,
                    test: test,
                    body: body
                };
            }
            function parseForVariableDeclaration() {
                var token = lex();
                return {
                    type: Syntax.VariableDeclaration,
                    declarations: parseVariableDeclarationList(),
                    kind: token.value
                };
            }
            function parseForStatement() {
                var init, test, update, left, right, body, oldInIteration;
                init = test = update = null;
                expectKeyword("for");
                expect("(");
                if (match(";")) {
                    lex();
                } else {
                    if (matchKeyword("var") || matchKeyword("let")) {
                        state.allowIn = false;
                        init = parseForVariableDeclaration();
                        state.allowIn = true;
                        if (init.declarations.length === 1 && matchKeyword("in")) {
                            lex();
                            left = init;
                            right = parseExpression();
                            init = null;
                        }
                    } else {
                        state.allowIn = false;
                        init = parseExpression();
                        state.allowIn = true;
                        if (matchKeyword("in")) {
                            if (!isLeftHandSide(init)) {
                                throwErrorTolerant({}, Messages.InvalidLHSInForIn);
                            }
                            lex();
                            left = init;
                            right = parseExpression();
                            init = null;
                        }
                    }
                    if (typeof left === "undefined") {
                        expect(";");
                    }
                }
                if (typeof left === "undefined") {
                    if (!match(";")) {
                        test = parseExpression();
                    }
                    expect(";");
                    if (!match(")")) {
                        update = parseExpression();
                    }
                }
                expect(")");
                oldInIteration = state.inIteration;
                state.inIteration = true;
                body = parseStatement();
                state.inIteration = oldInIteration;
                if (typeof left === "undefined") {
                    return {
                        type: Syntax.ForStatement,
                        init: init,
                        test: test,
                        update: update,
                        body: body
                    };
                }
                return {
                    type: Syntax.ForInStatement,
                    left: left,
                    right: right,
                    body: body,
                    each: false
                };
            }
            function parseContinueStatement() {
                var token, label = null;
                expectKeyword("continue");
                if (source[index] === ";") {
                    lex();
                    if (!state.inIteration) {
                        throwError({}, Messages.IllegalContinue);
                    }
                    return {
                        type: Syntax.ContinueStatement,
                        label: null
                    };
                }
                if (peekLineTerminator()) {
                    if (!state.inIteration) {
                        throwError({}, Messages.IllegalContinue);
                    }
                    return {
                        type: Syntax.ContinueStatement,
                        label: null
                    };
                }
                token = lookahead();
                if (token.type === Token.Identifier) {
                    label = parseVariableIdentifier();
                    if (!Object.prototype.hasOwnProperty.call(state.labelSet, label.name)) {
                        throwError({}, Messages.UnknownLabel, label.name);
                    }
                }
                consumeSemicolon();
                if (label === null && !state.inIteration) {
                    throwError({}, Messages.IllegalContinue);
                }
                return {
                    type: Syntax.ContinueStatement,
                    label: label
                };
            }
            function parseBreakStatement() {
                var token, label = null;
                expectKeyword("break");
                if (source[index] === ";") {
                    lex();
                    if (!(state.inIteration || state.inSwitch)) {
                        throwError({}, Messages.IllegalBreak);
                    }
                    return {
                        type: Syntax.BreakStatement,
                        label: null
                    };
                }
                if (peekLineTerminator()) {
                    if (!(state.inIteration || state.inSwitch)) {
                        throwError({}, Messages.IllegalBreak);
                    }
                    return {
                        type: Syntax.BreakStatement,
                        label: null
                    };
                }
                token = lookahead();
                if (token.type === Token.Identifier) {
                    label = parseVariableIdentifier();
                    if (!Object.prototype.hasOwnProperty.call(state.labelSet, label.name)) {
                        throwError({}, Messages.UnknownLabel, label.name);
                    }
                }
                consumeSemicolon();
                if (label === null && !(state.inIteration || state.inSwitch)) {
                    throwError({}, Messages.IllegalBreak);
                }
                return {
                    type: Syntax.BreakStatement,
                    label: label
                };
            }
            function parseReturnStatement() {
                var token, argument = null;
                expectKeyword("return");
                if (!state.inFunctionBody) {
                    throwErrorTolerant({}, Messages.IllegalReturn);
                }
                if (source[index] === " ") {
                    if (isIdentifierStart(source[index + 1])) {
                        argument = parseExpression();
                        consumeSemicolon();
                        return {
                            type: Syntax.ReturnStatement,
                            argument: argument
                        };
                    }
                }
                if (peekLineTerminator()) {
                    return {
                        type: Syntax.ReturnStatement,
                        argument: null
                    };
                }
                if (!match(";")) {
                    token = lookahead();
                    if (!match("}") && token.type !== Token.EOF) {
                        argument = parseExpression();
                    }
                }
                consumeSemicolon();
                return {
                    type: Syntax.ReturnStatement,
                    argument: argument
                };
            }
            function parseWithStatement() {
                var object, body;
                if (strict) {
                    throwErrorTolerant({}, Messages.StrictModeWith);
                }
                expectKeyword("with");
                expect("(");
                object = parseExpression();
                expect(")");
                body = parseStatement();
                return {
                    type: Syntax.WithStatement,
                    object: object,
                    body: body
                };
            }
            function parseSwitchCase() {
                var test, consequent = [], statement;
                if (matchKeyword("default")) {
                    lex();
                    test = null;
                } else {
                    expectKeyword("case");
                    test = parseExpression();
                }
                expect(":");
                while (index < length) {
                    if (match("}") || matchKeyword("default") || matchKeyword("case")) {
                        break;
                    }
                    statement = parseStatement();
                    if (typeof statement === "undefined") {
                        break;
                    }
                    consequent.push(statement);
                }
                return {
                    type: Syntax.SwitchCase,
                    test: test,
                    consequent: consequent
                };
            }
            function parseSwitchStatement() {
                var discriminant, cases, clause, oldInSwitch, defaultFound;
                expectKeyword("switch");
                expect("(");
                discriminant = parseExpression();
                expect(")");
                expect("{");
                cases = [];
                if (match("}")) {
                    lex();
                    return {
                        type: Syntax.SwitchStatement,
                        discriminant: discriminant,
                        cases: cases
                    };
                }
                oldInSwitch = state.inSwitch;
                state.inSwitch = true;
                defaultFound = false;
                while (index < length) {
                    if (match("}")) {
                        break;
                    }
                    clause = parseSwitchCase();
                    if (clause.test === null) {
                        if (defaultFound) {
                            throwError({}, Messages.MultipleDefaultsInSwitch);
                        }
                        defaultFound = true;
                    }
                    cases.push(clause);
                }
                state.inSwitch = oldInSwitch;
                expect("}");
                return {
                    type: Syntax.SwitchStatement,
                    discriminant: discriminant,
                    cases: cases
                };
            }
            function parseThrowStatement() {
                var argument;
                expectKeyword("throw");
                if (peekLineTerminator()) {
                    throwError({}, Messages.NewlineAfterThrow);
                }
                argument = parseExpression();
                consumeSemicolon();
                return {
                    type: Syntax.ThrowStatement,
                    argument: argument
                };
            }
            function parseCatchClause() {
                var param;
                expectKeyword("catch");
                expect("(");
                if (match(")")) {
                    throwUnexpected(lookahead());
                }
                param = parseVariableIdentifier();
                if (strict && isRestrictedWord(param.name)) {
                    throwErrorTolerant({}, Messages.StrictCatchVariable);
                }
                expect(")");
                return {
                    type: Syntax.CatchClause,
                    param: param,
                    body: parseBlock()
                };
            }
            function parseTryStatement() {
                var block, handlers = [], finalizer = null;
                expectKeyword("try");
                block = parseBlock();
                if (matchKeyword("catch")) {
                    handlers.push(parseCatchClause());
                }
                if (matchKeyword("finally")) {
                    lex();
                    finalizer = parseBlock();
                }
                if (handlers.length === 0 && !finalizer) {
                    throwError({}, Messages.NoCatchOrFinally);
                }
                return {
                    type: Syntax.TryStatement,
                    block: block,
                    guardedHandlers: [],
                    handlers: handlers,
                    finalizer: finalizer
                };
            }
            function parseDebuggerStatement() {
                expectKeyword("debugger");
                consumeSemicolon();
                return {
                    type: Syntax.DebuggerStatement
                };
            }
            function parseStatement() {
                var token = lookahead(), expr, labeledBody;
                if (token.type === Token.EOF) {
                    throwUnexpected(token);
                }
                if (token.type === Token.Punctuator) {
                    switch (token.value) {
                      case ";":
                        return parseEmptyStatement();

                      case "{":
                        return parseBlock();

                      case "(":
                        return parseExpressionStatement();

                      default:
                        break;
                    }
                }
                if (token.type === Token.Keyword) {
                    switch (token.value) {
                      case "break":
                        return parseBreakStatement();

                      case "continue":
                        return parseContinueStatement();

                      case "debugger":
                        return parseDebuggerStatement();

                      case "do":
                        return parseDoWhileStatement();

                      case "for":
                        return parseForStatement();

                      case "function":
                        return parseFunctionDeclaration();

                      case "if":
                        return parseIfStatement();

                      case "return":
                        return parseReturnStatement();

                      case "switch":
                        return parseSwitchStatement();

                      case "throw":
                        return parseThrowStatement();

                      case "try":
                        return parseTryStatement();

                      case "var":
                        return parseVariableStatement();

                      case "while":
                        return parseWhileStatement();

                      case "with":
                        return parseWithStatement();

                      default:
                        break;
                    }
                }
                expr = parseExpression();
                if (expr.type === Syntax.Identifier && match(":")) {
                    lex();
                    if (Object.prototype.hasOwnProperty.call(state.labelSet, expr.name)) {
                        throwError({}, Messages.Redeclaration, "Label", expr.name);
                    }
                    state.labelSet[expr.name] = true;
                    labeledBody = parseStatement();
                    delete state.labelSet[expr.name];
                    return {
                        type: Syntax.LabeledStatement,
                        label: expr,
                        body: labeledBody
                    };
                }
                consumeSemicolon();
                return {
                    type: Syntax.ExpressionStatement,
                    expression: expr
                };
            }
            function parseFunctionSourceElements() {
                var sourceElement, sourceElements = [], token, directive, firstRestricted, oldLabelSet, oldInIteration, oldInSwitch, oldInFunctionBody;
                expect("{");
                while (index < length) {
                    token = lookahead();
                    if (token.type !== Token.StringLiteral) {
                        break;
                    }
                    sourceElement = parseSourceElement();
                    sourceElements.push(sourceElement);
                    if (sourceElement.expression.type !== Syntax.Literal) {
                        break;
                    }
                    directive = sliceSource(token.range[0] + 1, token.range[1] - 1);
                    if (directive === "use strict") {
                        strict = true;
                        if (firstRestricted) {
                            throwErrorTolerant(firstRestricted, Messages.StrictOctalLiteral);
                        }
                    } else {
                        if (!firstRestricted && token.octal) {
                            firstRestricted = token;
                        }
                    }
                }
                oldLabelSet = state.labelSet;
                oldInIteration = state.inIteration;
                oldInSwitch = state.inSwitch;
                oldInFunctionBody = state.inFunctionBody;
                state.labelSet = {};
                state.inIteration = false;
                state.inSwitch = false;
                state.inFunctionBody = true;
                while (index < length) {
                    if (match("}")) {
                        break;
                    }
                    sourceElement = parseSourceElement();
                    if (typeof sourceElement === "undefined") {
                        break;
                    }
                    sourceElements.push(sourceElement);
                }
                expect("}");
                state.labelSet = oldLabelSet;
                state.inIteration = oldInIteration;
                state.inSwitch = oldInSwitch;
                state.inFunctionBody = oldInFunctionBody;
                return {
                    type: Syntax.BlockStatement,
                    body: sourceElements
                };
            }
            function parseFunctionDeclaration() {
                var id, param, params = [], body, token, stricted, firstRestricted, message, previousStrict, paramSet;
                expectKeyword("function");
                token = lookahead();
                id = parseVariableIdentifier();
                if (strict) {
                    if (isRestrictedWord(token.value)) {
                        throwErrorTolerant(token, Messages.StrictFunctionName);
                    }
                } else {
                    if (isRestrictedWord(token.value)) {
                        firstRestricted = token;
                        message = Messages.StrictFunctionName;
                    } else if (isStrictModeReservedWord(token.value)) {
                        firstRestricted = token;
                        message = Messages.StrictReservedWord;
                    }
                }
                expect("(");
                if (!match(")")) {
                    paramSet = {};
                    while (index < length) {
                        token = lookahead();
                        param = parseVariableIdentifier();
                        if (strict) {
                            if (isRestrictedWord(token.value)) {
                                stricted = token;
                                message = Messages.StrictParamName;
                            }
                            if (Object.prototype.hasOwnProperty.call(paramSet, token.value)) {
                                stricted = token;
                                message = Messages.StrictParamDupe;
                            }
                        } else if (!firstRestricted) {
                            if (isRestrictedWord(token.value)) {
                                firstRestricted = token;
                                message = Messages.StrictParamName;
                            } else if (isStrictModeReservedWord(token.value)) {
                                firstRestricted = token;
                                message = Messages.StrictReservedWord;
                            } else if (Object.prototype.hasOwnProperty.call(paramSet, token.value)) {
                                firstRestricted = token;
                                message = Messages.StrictParamDupe;
                            }
                        }
                        params.push(param);
                        paramSet[param.name] = true;
                        if (match(")")) {
                            break;
                        }
                        expect(",");
                    }
                }
                expect(")");
                previousStrict = strict;
                body = parseFunctionSourceElements();
                if (strict && firstRestricted) {
                    throwError(firstRestricted, message);
                }
                if (strict && stricted) {
                    throwErrorTolerant(stricted, message);
                }
                strict = previousStrict;
                return {
                    type: Syntax.FunctionDeclaration,
                    id: id,
                    params: params,
                    defaults: [],
                    body: body,
                    rest: null,
                    generator: false,
                    expression: false
                };
            }
            function parseFunctionExpression() {
                var token, id = null, stricted, firstRestricted, message, param, params = [], body, previousStrict, paramSet;
                expectKeyword("function");
                if (!match("(")) {
                    token = lookahead();
                    id = parseVariableIdentifier();
                    if (strict) {
                        if (isRestrictedWord(token.value)) {
                            throwErrorTolerant(token, Messages.StrictFunctionName);
                        }
                    } else {
                        if (isRestrictedWord(token.value)) {
                            firstRestricted = token;
                            message = Messages.StrictFunctionName;
                        } else if (isStrictModeReservedWord(token.value)) {
                            firstRestricted = token;
                            message = Messages.StrictReservedWord;
                        }
                    }
                }
                expect("(");
                if (!match(")")) {
                    paramSet = {};
                    while (index < length) {
                        token = lookahead();
                        param = parseVariableIdentifier();
                        if (strict) {
                            if (isRestrictedWord(token.value)) {
                                stricted = token;
                                message = Messages.StrictParamName;
                            }
                            if (Object.prototype.hasOwnProperty.call(paramSet, token.value)) {
                                stricted = token;
                                message = Messages.StrictParamDupe;
                            }
                        } else if (!firstRestricted) {
                            if (isRestrictedWord(token.value)) {
                                firstRestricted = token;
                                message = Messages.StrictParamName;
                            } else if (isStrictModeReservedWord(token.value)) {
                                firstRestricted = token;
                                message = Messages.StrictReservedWord;
                            } else if (Object.prototype.hasOwnProperty.call(paramSet, token.value)) {
                                firstRestricted = token;
                                message = Messages.StrictParamDupe;
                            }
                        }
                        params.push(param);
                        paramSet[param.name] = true;
                        if (match(")")) {
                            break;
                        }
                        expect(",");
                    }
                }
                expect(")");
                previousStrict = strict;
                body = parseFunctionSourceElements();
                if (strict && firstRestricted) {
                    throwError(firstRestricted, message);
                }
                if (strict && stricted) {
                    throwErrorTolerant(stricted, message);
                }
                strict = previousStrict;
                return {
                    type: Syntax.FunctionExpression,
                    id: id,
                    params: params,
                    defaults: [],
                    body: body,
                    rest: null,
                    generator: false,
                    expression: false
                };
            }
            function parseSourceElement() {
                var token = lookahead();
                if (token.type === Token.Keyword) {
                    switch (token.value) {
                      case "const":
                      case "let":
                        return parseConstLetDeclaration(token.value);

                      case "function":
                        return parseFunctionDeclaration();

                      default:
                        return parseStatement();
                    }
                }
                if (token.type !== Token.EOF) {
                    return parseStatement();
                }
            }
            function parseSourceElements() {
                var sourceElement, sourceElements = [], token, directive, firstRestricted;
                while (index < length) {
                    token = lookahead();
                    if (token.type !== Token.StringLiteral) {
                        break;
                    }
                    sourceElement = parseSourceElement();
                    sourceElements.push(sourceElement);
                    if (sourceElement.expression.type !== Syntax.Literal) {
                        break;
                    }
                    directive = sliceSource(token.range[0] + 1, token.range[1] - 1);
                    if (directive === "use strict") {
                        strict = true;
                        if (firstRestricted) {
                            throwErrorTolerant(firstRestricted, Messages.StrictOctalLiteral);
                        }
                    } else {
                        if (!firstRestricted && token.octal) {
                            firstRestricted = token;
                        }
                    }
                }
                while (index < length) {
                    sourceElement = parseSourceElement();
                    if (typeof sourceElement === "undefined") {
                        break;
                    }
                    sourceElements.push(sourceElement);
                }
                return sourceElements;
            }
            function parseProgram() {
                var program;
                strict = false;
                program = {
                    type: Syntax.Program,
                    body: parseSourceElements()
                };
                return program;
            }
            function addComment(type, value, start, end, loc) {
                assert(typeof start === "number", "Comment must have valid position");
                if (extra.comments.length > 0) {
                    if (extra.comments[extra.comments.length - 1].range[1] > start) {
                        return;
                    }
                }
                extra.comments.push({
                    type: type,
                    value: value,
                    range: [ start, end ],
                    loc: loc
                });
            }
            function scanComment() {
                var comment, ch, loc, start, blockComment, lineComment;
                comment = "";
                blockComment = false;
                lineComment = false;
                while (index < length) {
                    ch = source[index];
                    if (lineComment) {
                        ch = source[index++];
                        if (isLineTerminator(ch)) {
                            loc.end = {
                                line: lineNumber,
                                column: index - lineStart - 1
                            };
                            lineComment = false;
                            addComment("Line", comment, start, index - 1, loc);
                            if (ch === "\r" && source[index] === "\n") {
                                ++index;
                            }
                            ++lineNumber;
                            lineStart = index;
                            comment = "";
                        } else if (index >= length) {
                            lineComment = false;
                            comment += ch;
                            loc.end = {
                                line: lineNumber,
                                column: length - lineStart
                            };
                            addComment("Line", comment, start, length, loc);
                        } else {
                            comment += ch;
                        }
                    } else if (blockComment) {
                        if (isLineTerminator(ch)) {
                            if (ch === "\r" && source[index + 1] === "\n") {
                                ++index;
                                comment += "\r\n";
                            } else {
                                comment += ch;
                            }
                            ++lineNumber;
                            ++index;
                            lineStart = index;
                            if (index >= length) {
                                throwError({}, Messages.UnexpectedToken, "ILLEGAL");
                            }
                        } else {
                            ch = source[index++];
                            if (index >= length) {
                                throwError({}, Messages.UnexpectedToken, "ILLEGAL");
                            }
                            comment += ch;
                            if (ch === "*") {
                                ch = source[index];
                                if (ch === "/") {
                                    comment = comment.substr(0, comment.length - 1);
                                    blockComment = false;
                                    ++index;
                                    loc.end = {
                                        line: lineNumber,
                                        column: index - lineStart
                                    };
                                    addComment("Block", comment, start, index, loc);
                                    comment = "";
                                }
                            }
                        }
                    } else if (ch === "/") {
                        ch = source[index + 1];
                        if (ch === "/") {
                            loc = {
                                start: {
                                    line: lineNumber,
                                    column: index - lineStart
                                }
                            };
                            start = index;
                            index += 2;
                            lineComment = true;
                            if (index >= length) {
                                loc.end = {
                                    line: lineNumber,
                                    column: index - lineStart
                                };
                                lineComment = false;
                                addComment("Line", comment, start, index, loc);
                            }
                        } else if (ch === "*") {
                            start = index;
                            index += 2;
                            blockComment = true;
                            loc = {
                                start: {
                                    line: lineNumber,
                                    column: index - lineStart - 2
                                }
                            };
                            if (index >= length) {
                                throwError({}, Messages.UnexpectedToken, "ILLEGAL");
                            }
                        } else {
                            break;
                        }
                    } else if (isWhiteSpace(ch)) {
                        ++index;
                    } else if (isLineTerminator(ch)) {
                        ++index;
                        if (ch === "\r" && source[index] === "\n") {
                            ++index;
                        }
                        ++lineNumber;
                        lineStart = index;
                    } else {
                        break;
                    }
                }
            }
            function filterCommentLocation() {
                var i, entry, comment, comments = [];
                for (i = 0; i < extra.comments.length; ++i) {
                    entry = extra.comments[i];
                    comment = {
                        type: entry.type,
                        value: entry.value
                    };
                    if (extra.range) {
                        comment.range = entry.range;
                    }
                    if (extra.loc) {
                        comment.loc = entry.loc;
                    }
                    comments.push(comment);
                }
                extra.comments = comments;
            }
            function collectToken() {
                var start, loc, token, range, value;
                skipComment();
                start = index;
                loc = {
                    start: {
                        line: lineNumber,
                        column: index - lineStart
                    }
                };
                token = extra.advance();
                loc.end = {
                    line: lineNumber,
                    column: index - lineStart
                };
                if (token.type !== Token.EOF) {
                    range = [ token.range[0], token.range[1] ];
                    value = sliceSource(token.range[0], token.range[1]);
                    extra.tokens.push({
                        type: TokenName[token.type],
                        value: value,
                        range: range,
                        loc: loc
                    });
                }
                return token;
            }
            function collectRegex() {
                var pos, loc, regex, token;
                skipComment();
                pos = index;
                loc = {
                    start: {
                        line: lineNumber,
                        column: index - lineStart
                    }
                };
                regex = extra.scanRegExp();
                loc.end = {
                    line: lineNumber,
                    column: index - lineStart
                };
                if (extra.tokens.length > 0) {
                    token = extra.tokens[extra.tokens.length - 1];
                    if (token.range[0] === pos && token.type === "Punctuator") {
                        if (token.value === "/" || token.value === "/=") {
                            extra.tokens.pop();
                        }
                    }
                }
                extra.tokens.push({
                    type: "RegularExpression",
                    value: regex.literal,
                    range: [ pos, index ],
                    loc: loc
                });
                return regex;
            }
            function filterTokenLocation() {
                var i, entry, token, tokens = [];
                for (i = 0; i < extra.tokens.length; ++i) {
                    entry = extra.tokens[i];
                    token = {
                        type: entry.type,
                        value: entry.value
                    };
                    if (extra.range) {
                        token.range = entry.range;
                    }
                    if (extra.loc) {
                        token.loc = entry.loc;
                    }
                    tokens.push(token);
                }
                extra.tokens = tokens;
            }
            function createLiteral(token) {
                return {
                    type: Syntax.Literal,
                    value: token.value
                };
            }
            function createRawLiteral(token) {
                return {
                    type: Syntax.Literal,
                    value: token.value,
                    raw: sliceSource(token.range[0], token.range[1])
                };
            }
            function createLocationMarker() {
                var marker = {};
                marker.range = [ index, index ];
                marker.loc = {
                    start: {
                        line: lineNumber,
                        column: index - lineStart
                    },
                    end: {
                        line: lineNumber,
                        column: index - lineStart
                    }
                };
                marker.end = function() {
                    this.range[1] = index;
                    this.loc.end.line = lineNumber;
                    this.loc.end.column = index - lineStart;
                };
                marker.applyGroup = function(node) {
                    if (extra.range) {
                        node.groupRange = [ this.range[0], this.range[1] ];
                    }
                    if (extra.loc) {
                        node.groupLoc = {
                            start: {
                                line: this.loc.start.line,
                                column: this.loc.start.column
                            },
                            end: {
                                line: this.loc.end.line,
                                column: this.loc.end.column
                            }
                        };
                    }
                };
                marker.apply = function(node) {
                    if (extra.range) {
                        node.range = [ this.range[0], this.range[1] ];
                    }
                    if (extra.loc) {
                        node.loc = {
                            start: {
                                line: this.loc.start.line,
                                column: this.loc.start.column
                            },
                            end: {
                                line: this.loc.end.line,
                                column: this.loc.end.column
                            }
                        };
                    }
                };
                return marker;
            }
            function trackGroupExpression() {
                var marker, expr;
                skipComment();
                marker = createLocationMarker();
                expect("(");
                expr = parseExpression();
                expect(")");
                marker.end();
                marker.applyGroup(expr);
                return expr;
            }
            function trackLeftHandSideExpression() {
                var marker, expr;
                skipComment();
                marker = createLocationMarker();
                expr = matchKeyword("new") ? parseNewExpression() : parsePrimaryExpression();
                while (match(".") || match("[")) {
                    if (match("[")) {
                        expr = {
                            type: Syntax.MemberExpression,
                            computed: true,
                            object: expr,
                            property: parseComputedMember()
                        };
                        marker.end();
                        marker.apply(expr);
                    } else {
                        expr = {
                            type: Syntax.MemberExpression,
                            computed: false,
                            object: expr,
                            property: parseNonComputedMember()
                        };
                        marker.end();
                        marker.apply(expr);
                    }
                }
                return expr;
            }
            function trackLeftHandSideExpressionAllowCall() {
                var marker, expr;
                skipComment();
                marker = createLocationMarker();
                expr = matchKeyword("new") ? parseNewExpression() : parsePrimaryExpression();
                while (match(".") || match("[") || match("(")) {
                    if (match("(")) {
                        expr = {
                            type: Syntax.CallExpression,
                            callee: expr,
                            arguments: parseArguments()
                        };
                        marker.end();
                        marker.apply(expr);
                    } else if (match("[")) {
                        expr = {
                            type: Syntax.MemberExpression,
                            computed: true,
                            object: expr,
                            property: parseComputedMember()
                        };
                        marker.end();
                        marker.apply(expr);
                    } else {
                        expr = {
                            type: Syntax.MemberExpression,
                            computed: false,
                            object: expr,
                            property: parseNonComputedMember()
                        };
                        marker.end();
                        marker.apply(expr);
                    }
                }
                return expr;
            }
            function filterGroup(node) {
                var n, i, entry;
                n = Object.prototype.toString.apply(node) === "[object Array]" ? [] : {};
                for (i in node) {
                    if (node.hasOwnProperty(i) && i !== "groupRange" && i !== "groupLoc") {
                        entry = node[i];
                        if (entry === null || typeof entry !== "object" || entry instanceof RegExp) {
                            n[i] = entry;
                        } else {
                            n[i] = filterGroup(entry);
                        }
                    }
                }
                return n;
            }
            function wrapTrackingFunction(range, loc) {
                return function(parseFunction) {
                    function isBinary(node) {
                        return node.type === Syntax.LogicalExpression || node.type === Syntax.BinaryExpression;
                    }
                    function visit(node) {
                        var start, end;
                        if (isBinary(node.left)) {
                            visit(node.left);
                        }
                        if (isBinary(node.right)) {
                            visit(node.right);
                        }
                        if (range) {
                            if (node.left.groupRange || node.right.groupRange) {
                                start = node.left.groupRange ? node.left.groupRange[0] : node.left.range[0];
                                end = node.right.groupRange ? node.right.groupRange[1] : node.right.range[1];
                                node.range = [ start, end ];
                            } else if (typeof node.range === "undefined") {
                                start = node.left.range[0];
                                end = node.right.range[1];
                                node.range = [ start, end ];
                            }
                        }
                        if (loc) {
                            if (node.left.groupLoc || node.right.groupLoc) {
                                start = node.left.groupLoc ? node.left.groupLoc.start : node.left.loc.start;
                                end = node.right.groupLoc ? node.right.groupLoc.end : node.right.loc.end;
                                node.loc = {
                                    start: start,
                                    end: end
                                };
                            } else if (typeof node.loc === "undefined") {
                                node.loc = {
                                    start: node.left.loc.start,
                                    end: node.right.loc.end
                                };
                            }
                        }
                    }
                    return function() {
                        var marker, node;
                        skipComment();
                        marker = createLocationMarker();
                        node = parseFunction.apply(null, arguments);
                        marker.end();
                        if (range && typeof node.range === "undefined") {
                            marker.apply(node);
                        }
                        if (loc && typeof node.loc === "undefined") {
                            marker.apply(node);
                        }
                        if (isBinary(node)) {
                            visit(node);
                        }
                        return node;
                    };
                };
            }
            function patch() {
                var wrapTracking;
                if (extra.comments) {
                    extra.skipComment = skipComment;
                    skipComment = scanComment;
                }
                if (extra.raw) {
                    extra.createLiteral = createLiteral;
                    createLiteral = createRawLiteral;
                }
                if (extra.range || extra.loc) {
                    extra.parseGroupExpression = parseGroupExpression;
                    extra.parseLeftHandSideExpression = parseLeftHandSideExpression;
                    extra.parseLeftHandSideExpressionAllowCall = parseLeftHandSideExpressionAllowCall;
                    parseGroupExpression = trackGroupExpression;
                    parseLeftHandSideExpression = trackLeftHandSideExpression;
                    parseLeftHandSideExpressionAllowCall = trackLeftHandSideExpressionAllowCall;
                    wrapTracking = wrapTrackingFunction(extra.range, extra.loc);
                    extra.parseAdditiveExpression = parseAdditiveExpression;
                    extra.parseAssignmentExpression = parseAssignmentExpression;
                    extra.parseBitwiseANDExpression = parseBitwiseANDExpression;
                    extra.parseBitwiseORExpression = parseBitwiseORExpression;
                    extra.parseBitwiseXORExpression = parseBitwiseXORExpression;
                    extra.parseBlock = parseBlock;
                    extra.parseFunctionSourceElements = parseFunctionSourceElements;
                    extra.parseCatchClause = parseCatchClause;
                    extra.parseComputedMember = parseComputedMember;
                    extra.parseConditionalExpression = parseConditionalExpression;
                    extra.parseConstLetDeclaration = parseConstLetDeclaration;
                    extra.parseEqualityExpression = parseEqualityExpression;
                    extra.parseExpression = parseExpression;
                    extra.parseForVariableDeclaration = parseForVariableDeclaration;
                    extra.parseFunctionDeclaration = parseFunctionDeclaration;
                    extra.parseFunctionExpression = parseFunctionExpression;
                    extra.parseLogicalANDExpression = parseLogicalANDExpression;
                    extra.parseLogicalORExpression = parseLogicalORExpression;
                    extra.parseMultiplicativeExpression = parseMultiplicativeExpression;
                    extra.parseNewExpression = parseNewExpression;
                    extra.parseNonComputedProperty = parseNonComputedProperty;
                    extra.parseObjectProperty = parseObjectProperty;
                    extra.parseObjectPropertyKey = parseObjectPropertyKey;
                    extra.parsePostfixExpression = parsePostfixExpression;
                    extra.parsePrimaryExpression = parsePrimaryExpression;
                    extra.parseProgram = parseProgram;
                    extra.parsePropertyFunction = parsePropertyFunction;
                    extra.parseRelationalExpression = parseRelationalExpression;
                    extra.parseStatement = parseStatement;
                    extra.parseShiftExpression = parseShiftExpression;
                    extra.parseSwitchCase = parseSwitchCase;
                    extra.parseUnaryExpression = parseUnaryExpression;
                    extra.parseVariableDeclaration = parseVariableDeclaration;
                    extra.parseVariableIdentifier = parseVariableIdentifier;
                    parseAdditiveExpression = wrapTracking(extra.parseAdditiveExpression);
                    parseAssignmentExpression = wrapTracking(extra.parseAssignmentExpression);
                    parseBitwiseANDExpression = wrapTracking(extra.parseBitwiseANDExpression);
                    parseBitwiseORExpression = wrapTracking(extra.parseBitwiseORExpression);
                    parseBitwiseXORExpression = wrapTracking(extra.parseBitwiseXORExpression);
                    parseBlock = wrapTracking(extra.parseBlock);
                    parseFunctionSourceElements = wrapTracking(extra.parseFunctionSourceElements);
                    parseCatchClause = wrapTracking(extra.parseCatchClause);
                    parseComputedMember = wrapTracking(extra.parseComputedMember);
                    parseConditionalExpression = wrapTracking(extra.parseConditionalExpression);
                    parseConstLetDeclaration = wrapTracking(extra.parseConstLetDeclaration);
                    parseEqualityExpression = wrapTracking(extra.parseEqualityExpression);
                    parseExpression = wrapTracking(extra.parseExpression);
                    parseForVariableDeclaration = wrapTracking(extra.parseForVariableDeclaration);
                    parseFunctionDeclaration = wrapTracking(extra.parseFunctionDeclaration);
                    parseFunctionExpression = wrapTracking(extra.parseFunctionExpression);
                    parseLeftHandSideExpression = wrapTracking(parseLeftHandSideExpression);
                    parseLogicalANDExpression = wrapTracking(extra.parseLogicalANDExpression);
                    parseLogicalORExpression = wrapTracking(extra.parseLogicalORExpression);
                    parseMultiplicativeExpression = wrapTracking(extra.parseMultiplicativeExpression);
                    parseNewExpression = wrapTracking(extra.parseNewExpression);
                    parseNonComputedProperty = wrapTracking(extra.parseNonComputedProperty);
                    parseObjectProperty = wrapTracking(extra.parseObjectProperty);
                    parseObjectPropertyKey = wrapTracking(extra.parseObjectPropertyKey);
                    parsePostfixExpression = wrapTracking(extra.parsePostfixExpression);
                    parsePrimaryExpression = wrapTracking(extra.parsePrimaryExpression);
                    parseProgram = wrapTracking(extra.parseProgram);
                    parsePropertyFunction = wrapTracking(extra.parsePropertyFunction);
                    parseRelationalExpression = wrapTracking(extra.parseRelationalExpression);
                    parseStatement = wrapTracking(extra.parseStatement);
                    parseShiftExpression = wrapTracking(extra.parseShiftExpression);
                    parseSwitchCase = wrapTracking(extra.parseSwitchCase);
                    parseUnaryExpression = wrapTracking(extra.parseUnaryExpression);
                    parseVariableDeclaration = wrapTracking(extra.parseVariableDeclaration);
                    parseVariableIdentifier = wrapTracking(extra.parseVariableIdentifier);
                }
                if (typeof extra.tokens !== "undefined") {
                    extra.advance = advance;
                    extra.scanRegExp = scanRegExp;
                    advance = collectToken;
                    scanRegExp = collectRegex;
                }
            }
            function unpatch() {
                if (typeof extra.skipComment === "function") {
                    skipComment = extra.skipComment;
                }
                if (extra.raw) {
                    createLiteral = extra.createLiteral;
                }
                if (extra.range || extra.loc) {
                    parseAdditiveExpression = extra.parseAdditiveExpression;
                    parseAssignmentExpression = extra.parseAssignmentExpression;
                    parseBitwiseANDExpression = extra.parseBitwiseANDExpression;
                    parseBitwiseORExpression = extra.parseBitwiseORExpression;
                    parseBitwiseXORExpression = extra.parseBitwiseXORExpression;
                    parseBlock = extra.parseBlock;
                    parseFunctionSourceElements = extra.parseFunctionSourceElements;
                    parseCatchClause = extra.parseCatchClause;
                    parseComputedMember = extra.parseComputedMember;
                    parseConditionalExpression = extra.parseConditionalExpression;
                    parseConstLetDeclaration = extra.parseConstLetDeclaration;
                    parseEqualityExpression = extra.parseEqualityExpression;
                    parseExpression = extra.parseExpression;
                    parseForVariableDeclaration = extra.parseForVariableDeclaration;
                    parseFunctionDeclaration = extra.parseFunctionDeclaration;
                    parseFunctionExpression = extra.parseFunctionExpression;
                    parseGroupExpression = extra.parseGroupExpression;
                    parseLeftHandSideExpression = extra.parseLeftHandSideExpression;
                    parseLeftHandSideExpressionAllowCall = extra.parseLeftHandSideExpressionAllowCall;
                    parseLogicalANDExpression = extra.parseLogicalANDExpression;
                    parseLogicalORExpression = extra.parseLogicalORExpression;
                    parseMultiplicativeExpression = extra.parseMultiplicativeExpression;
                    parseNewExpression = extra.parseNewExpression;
                    parseNonComputedProperty = extra.parseNonComputedProperty;
                    parseObjectProperty = extra.parseObjectProperty;
                    parseObjectPropertyKey = extra.parseObjectPropertyKey;
                    parsePrimaryExpression = extra.parsePrimaryExpression;
                    parsePostfixExpression = extra.parsePostfixExpression;
                    parseProgram = extra.parseProgram;
                    parsePropertyFunction = extra.parsePropertyFunction;
                    parseRelationalExpression = extra.parseRelationalExpression;
                    parseStatement = extra.parseStatement;
                    parseShiftExpression = extra.parseShiftExpression;
                    parseSwitchCase = extra.parseSwitchCase;
                    parseUnaryExpression = extra.parseUnaryExpression;
                    parseVariableDeclaration = extra.parseVariableDeclaration;
                    parseVariableIdentifier = extra.parseVariableIdentifier;
                }
                if (typeof extra.scanRegExp === "function") {
                    advance = extra.advance;
                    scanRegExp = extra.scanRegExp;
                }
            }
            function stringToArray(str) {
                var length = str.length, result = [], i;
                for (i = 0; i < length; ++i) {
                    result[i] = str.charAt(i);
                }
                return result;
            }
            function parse(code, options) {
                var program, toString;
                toString = String;
                if (typeof code !== "string" && !(code instanceof String)) {
                    code = toString(code);
                }
                source = code;
                index = 0;
                lineNumber = source.length > 0 ? 1 : 0;
                lineStart = 0;
                length = source.length;
                buffer = null;
                state = {
                    allowIn: true,
                    labelSet: {},
                    inFunctionBody: false,
                    inIteration: false,
                    inSwitch: false
                };
                extra = {};
                if (typeof options !== "undefined") {
                    extra.range = typeof options.range === "boolean" && options.range;
                    extra.loc = typeof options.loc === "boolean" && options.loc;
                    extra.raw = typeof options.raw === "boolean" && options.raw;
                    if (typeof options.tokens === "boolean" && options.tokens) {
                        extra.tokens = [];
                    }
                    if (typeof options.comment === "boolean" && options.comment) {
                        extra.comments = [];
                    }
                    if (typeof options.tolerant === "boolean" && options.tolerant) {
                        extra.errors = [];
                    }
                }
                if (length > 0) {
                    if (typeof source[0] === "undefined") {
                        if (code instanceof String) {
                            source = code.valueOf();
                        }
                        if (typeof source[0] === "undefined") {
                            source = stringToArray(code);
                        }
                    }
                }
                patch();
                try {
                    program = parseProgram();
                    if (typeof extra.comments !== "undefined") {
                        filterCommentLocation();
                        program.comments = extra.comments;
                    }
                    if (typeof extra.tokens !== "undefined") {
                        filterTokenLocation();
                        program.tokens = extra.tokens;
                    }
                    if (typeof extra.errors !== "undefined") {
                        program.errors = extra.errors;
                    }
                    if (extra.range || extra.loc) {
                        program.body = filterGroup(program.body);
                    }
                } catch (e) {
                    throw e;
                } finally {
                    unpatch();
                    extra = {};
                }
                return program;
            }
            exports.version = "1.0.4";
            exports.parse = parse;
            exports.Syntax = function() {
                var name, types = {};
                if (typeof Object.create === "function") {
                    types = Object.create(null);
                }
                for (name in Syntax) {
                    if (Syntax.hasOwnProperty(name)) {
                        types[name] = Syntax[name];
                    }
                }
                if (typeof Object.freeze === "function") {
                    Object.freeze(types);
                }
                return types;
            }();
        });
    }, {} ],
    20: [ function(require, module, exports) {
        arguments[4][17][0].apply(exports, arguments);
    }, {
        dup: 17
    } ],
    21: [ function(require, module, exports) {
        "use strict";
        module.exports = require("./is-implemented")() ? Map : require("./polyfill");
    }, {
        "./is-implemented": 22,
        "./polyfill": 75
    } ],
    22: [ function(require, module, exports) {
        "use strict";
        module.exports = function() {
            var map, iterator, result;
            if (typeof Map !== "function") return false;
            try {
                map = new Map([ [ "raz", "one" ], [ "dwa", "two" ], [ "trzy", "three" ] ]);
            } catch (e) {
                return false;
            }
            if (map.size !== 3) return false;
            if (typeof map.clear !== "function") return false;
            if (typeof map.delete !== "function") return false;
            if (typeof map.entries !== "function") return false;
            if (typeof map.forEach !== "function") return false;
            if (typeof map.get !== "function") return false;
            if (typeof map.has !== "function") return false;
            if (typeof map.keys !== "function") return false;
            if (typeof map.set !== "function") return false;
            if (typeof map.values !== "function") return false;
            iterator = map.entries();
            result = iterator.next();
            if (result.done !== false) return false;
            if (!result.value) return false;
            if (result.value[0] !== "raz") return false;
            if (result.value[1] !== "one") return false;
            return true;
        };
    }, {} ],
    23: [ function(require, module, exports) {
        "use strict";
        module.exports = function() {
            if (typeof Map === "undefined") return false;
            return Object.prototype.toString.call(Map.prototype) === "[object Map]";
        }();
    }, {} ],
    24: [ function(require, module, exports) {
        "use strict";
        module.exports = require("es5-ext/object/primitive-set")("key", "value", "key+value");
    }, {
        "es5-ext/object/primitive-set": 49
    } ],
    25: [ function(require, module, exports) {
        "use strict";
        var setPrototypeOf = require("es5-ext/object/set-prototype-of"), d = require("d"), Iterator = require("es6-iterator"), toStringTagSymbol = require("es6-symbol").toStringTag, kinds = require("./iterator-kinds"), defineProperties = Object.defineProperties, unBind = Iterator.prototype._unBind, MapIterator;
        MapIterator = module.exports = function(map, kind) {
            if (!(this instanceof MapIterator)) return new MapIterator(map, kind);
            Iterator.call(this, map.__mapKeysData__, map);
            if (!kind || !kinds[kind]) kind = "key+value";
            defineProperties(this, {
                __kind__: d("", kind),
                __values__: d("w", map.__mapValuesData__)
            });
        };
        if (setPrototypeOf) setPrototypeOf(MapIterator, Iterator);
        MapIterator.prototype = Object.create(Iterator.prototype, {
            constructor: d(MapIterator),
            _resolve: d(function(i) {
                if (this.__kind__ === "value") return this.__values__[i];
                if (this.__kind__ === "key") return this.__list__[i];
                return [ this.__list__[i], this.__values__[i] ];
            }),
            _unBind: d(function() {
                this.__values__ = null;
                unBind.call(this);
            }),
            toString: d(function() {
                return "[object Map Iterator]";
            })
        });
        Object.defineProperty(MapIterator.prototype, toStringTagSymbol, d("c", "Map Iterator"));
    }, {
        "./iterator-kinds": 24,
        d: 27,
        "es5-ext/object/set-prototype-of": 50,
        "es6-iterator": 62,
        "es6-symbol": 71
    } ],
    26: [ function(require, module, exports) {
        "use strict";
        var copy = require("es5-ext/object/copy"), map = require("es5-ext/object/map"), callable = require("es5-ext/object/valid-callable"), validValue = require("es5-ext/object/valid-value"), bind = Function.prototype.bind, defineProperty = Object.defineProperty, hasOwnProperty = Object.prototype.hasOwnProperty, define;
        define = function(name, desc, bindTo) {
            var value = validValue(desc) && callable(desc.value), dgs;
            dgs = copy(desc);
            delete dgs.writable;
            delete dgs.value;
            dgs.get = function() {
                if (hasOwnProperty.call(this, name)) return value;
                desc.value = bind.call(value, bindTo == null ? this : this[bindTo]);
                defineProperty(this, name, desc);
                return this[name];
            };
            return dgs;
        };
        module.exports = function(props) {
            var bindTo = arguments[1];
            return map(props, function(desc, name) {
                return define(name, desc, bindTo);
            });
        };
    }, {
        "es5-ext/object/copy": 39,
        "es5-ext/object/map": 47,
        "es5-ext/object/valid-callable": 53,
        "es5-ext/object/valid-value": 54
    } ],
    27: [ function(require, module, exports) {
        "use strict";
        var assign = require("es5-ext/object/assign"), normalizeOpts = require("es5-ext/object/normalize-options"), isCallable = require("es5-ext/object/is-callable"), contains = require("es5-ext/string/#/contains"), d;
        d = module.exports = function(dscr, value) {
            var c, e, w, options, desc;
            if (arguments.length < 2 || typeof dscr !== "string") {
                options = value;
                value = dscr;
                dscr = null;
            } else {
                options = arguments[2];
            }
            if (dscr == null) {
                c = w = true;
                e = false;
            } else {
                c = contains.call(dscr, "c");
                e = contains.call(dscr, "e");
                w = contains.call(dscr, "w");
            }
            desc = {
                value: value,
                configurable: c,
                enumerable: e,
                writable: w
            };
            return !options ? desc : assign(normalizeOpts(options), desc);
        };
        d.gs = function(dscr, get, set) {
            var c, e, options, desc;
            if (typeof dscr !== "string") {
                options = set;
                set = get;
                get = dscr;
                dscr = null;
            } else {
                options = arguments[3];
            }
            if (get == null) {
                get = undefined;
            } else if (!isCallable(get)) {
                options = get;
                get = set = undefined;
            } else if (set == null) {
                set = undefined;
            } else if (!isCallable(set)) {
                options = set;
                set = undefined;
            }
            if (dscr == null) {
                c = true;
                e = false;
            } else {
                c = contains.call(dscr, "c");
                e = contains.call(dscr, "e");
            }
            desc = {
                get: get,
                set: set,
                configurable: c,
                enumerable: e
            };
            return !options ? desc : assign(normalizeOpts(options), desc);
        };
    }, {
        "es5-ext/object/assign": 36,
        "es5-ext/object/is-callable": 42,
        "es5-ext/object/normalize-options": 48,
        "es5-ext/string/#/contains": 55
    } ],
    28: [ function(require, module, exports) {
        "use strict";
        var value = require("../../object/valid-value");
        module.exports = function() {
            value(this).length = 0;
            return this;
        };
    }, {
        "../../object/valid-value": 54
    } ],
    29: [ function(require, module, exports) {
        "use strict";
        var toPosInt = require("../../number/to-pos-integer"), value = require("../../object/valid-value"), indexOf = Array.prototype.indexOf, hasOwnProperty = Object.prototype.hasOwnProperty, abs = Math.abs, floor = Math.floor;
        module.exports = function(searchElement) {
            var i, l, fromIndex, val;
            if (searchElement === searchElement) {
                return indexOf.apply(this, arguments);
            }
            l = toPosInt(value(this).length);
            fromIndex = arguments[1];
            if (isNaN(fromIndex)) fromIndex = 0; else if (fromIndex >= 0) fromIndex = floor(fromIndex); else fromIndex = toPosInt(this.length) - floor(abs(fromIndex));
            for (i = fromIndex; i < l; ++i) {
                if (hasOwnProperty.call(this, i)) {
                    val = this[i];
                    if (val !== val) return i;
                }
            }
            return -1;
        };
    }, {
        "../../number/to-pos-integer": 34,
        "../../object/valid-value": 54
    } ],
    30: [ function(require, module, exports) {
        "use strict";
        module.exports = require("./is-implemented")() ? Math.sign : require("./shim");
    }, {
        "./is-implemented": 31,
        "./shim": 32
    } ],
    31: [ function(require, module, exports) {
        "use strict";
        module.exports = function() {
            var sign = Math.sign;
            if (typeof sign !== "function") return false;
            return sign(10) === 1 && sign(-20) === -1;
        };
    }, {} ],
    32: [ function(require, module, exports) {
        "use strict";
        module.exports = function(value) {
            value = Number(value);
            if (isNaN(value) || value === 0) return value;
            return value > 0 ? 1 : -1;
        };
    }, {} ],
    33: [ function(require, module, exports) {
        "use strict";
        var sign = require("../math/sign"), abs = Math.abs, floor = Math.floor;
        module.exports = function(value) {
            if (isNaN(value)) return 0;
            value = Number(value);
            if (value === 0 || !isFinite(value)) return value;
            return sign(value) * floor(abs(value));
        };
    }, {
        "../math/sign": 30
    } ],
    34: [ function(require, module, exports) {
        "use strict";
        var toInteger = require("./to-integer"), max = Math.max;
        module.exports = function(value) {
            return max(0, toInteger(value));
        };
    }, {
        "./to-integer": 33
    } ],
    35: [ function(require, module, exports) {
        "use strict";
        var isCallable = require("./is-callable"), callable = require("./valid-callable"), value = require("./valid-value"), call = Function.prototype.call, keys = Object.keys, propertyIsEnumerable = Object.prototype.propertyIsEnumerable;
        module.exports = function(method, defVal) {
            return function(obj, cb) {
                var list, thisArg = arguments[2], compareFn = arguments[3];
                obj = Object(value(obj));
                callable(cb);
                list = keys(obj);
                if (compareFn) {
                    list.sort(isCallable(compareFn) ? compareFn.bind(obj) : undefined);
                }
                return list[method](function(key, index) {
                    if (!propertyIsEnumerable.call(obj, key)) return defVal;
                    return call.call(cb, thisArg, obj[key], key, obj, index);
                });
            };
        };
    }, {
        "./is-callable": 42,
        "./valid-callable": 53,
        "./valid-value": 54
    } ],
    36: [ function(require, module, exports) {
        "use strict";
        module.exports = require("./is-implemented")() ? Object.assign : require("./shim");
    }, {
        "./is-implemented": 37,
        "./shim": 38
    } ],
    37: [ function(require, module, exports) {
        "use strict";
        module.exports = function() {
            var assign = Object.assign, obj;
            if (typeof assign !== "function") return false;
            obj = {
                foo: "raz"
            };
            assign(obj, {
                bar: "dwa"
            }, {
                trzy: "trzy"
            });
            return obj.foo + obj.bar + obj.trzy === "razdwatrzy";
        };
    }, {} ],
    38: [ function(require, module, exports) {
        "use strict";
        var keys = require("../keys"), value = require("../valid-value"), max = Math.max;
        module.exports = function(dest, src) {
            var error, i, l = max(arguments.length, 2), assign;
            dest = Object(value(dest));
            assign = function(key) {
                try {
                    dest[key] = src[key];
                } catch (e) {
                    if (!error) error = e;
                }
            };
            for (i = 1; i < l; ++i) {
                src = arguments[i];
                keys(src).forEach(assign);
            }
            if (error !== undefined) throw error;
            return dest;
        };
    }, {
        "../keys": 44,
        "../valid-value": 54
    } ],
    39: [ function(require, module, exports) {
        "use strict";
        var assign = require("./assign"), value = require("./valid-value");
        module.exports = function(obj) {
            var copy = Object(value(obj));
            if (copy !== obj) return copy;
            return assign({}, obj);
        };
    }, {
        "./assign": 36,
        "./valid-value": 54
    } ],
    40: [ function(require, module, exports) {
        "use strict";
        var create = Object.create, shim;
        if (!require("./set-prototype-of/is-implemented")()) {
            shim = require("./set-prototype-of/shim");
        }
        module.exports = function() {
            var nullObject, props, desc;
            if (!shim) return create;
            if (shim.level !== 1) return create;
            nullObject = {};
            props = {};
            desc = {
                configurable: false,
                enumerable: false,
                writable: true,
                value: undefined
            };
            Object.getOwnPropertyNames(Object.prototype).forEach(function(name) {
                if (name === "__proto__") {
                    props[name] = {
                        configurable: true,
                        enumerable: false,
                        writable: true,
                        value: undefined
                    };
                    return;
                }
                props[name] = desc;
            });
            Object.defineProperties(nullObject, props);
            Object.defineProperty(shim, "nullPolyfill", {
                configurable: false,
                enumerable: false,
                writable: false,
                value: nullObject
            });
            return function(prototype, props) {
                return create(prototype === null ? nullObject : prototype, props);
            };
        }();
    }, {
        "./set-prototype-of/is-implemented": 51,
        "./set-prototype-of/shim": 52
    } ],
    41: [ function(require, module, exports) {
        "use strict";
        module.exports = require("./_iterate")("forEach");
    }, {
        "./_iterate": 35
    } ],
    42: [ function(require, module, exports) {
        "use strict";
        module.exports = function(obj) {
            return typeof obj === "function";
        };
    }, {} ],
    43: [ function(require, module, exports) {
        "use strict";
        var map = {
            "function": true,
            object: true
        };
        module.exports = function(x) {
            return x != null && map[typeof x] || false;
        };
    }, {} ],
    44: [ function(require, module, exports) {
        "use strict";
        module.exports = require("./is-implemented")() ? Object.keys : require("./shim");
    }, {
        "./is-implemented": 45,
        "./shim": 46
    } ],
    45: [ function(require, module, exports) {
        "use strict";
        module.exports = function() {
            try {
                Object.keys("primitive");
                return true;
            } catch (e) {
                return false;
            }
        };
    }, {} ],
    46: [ function(require, module, exports) {
        "use strict";
        var keys = Object.keys;
        module.exports = function(object) {
            return keys(object == null ? object : Object(object));
        };
    }, {} ],
    47: [ function(require, module, exports) {
        "use strict";
        var callable = require("./valid-callable"), forEach = require("./for-each"), call = Function.prototype.call;
        module.exports = function(obj, cb) {
            var o = {}, thisArg = arguments[2];
            callable(cb);
            forEach(obj, function(value, key, obj, index) {
                o[key] = call.call(cb, thisArg, value, key, obj, index);
            });
            return o;
        };
    }, {
        "./for-each": 41,
        "./valid-callable": 53
    } ],
    48: [ function(require, module, exports) {
        "use strict";
        var forEach = Array.prototype.forEach, create = Object.create;
        var process = function(src, obj) {
            var key;
            for (key in src) obj[key] = src[key];
        };
        module.exports = function(options) {
            var result = create(null);
            forEach.call(arguments, function(options) {
                if (options == null) return;
                process(Object(options), result);
            });
            return result;
        };
    }, {} ],
    49: [ function(require, module, exports) {
        "use strict";
        var forEach = Array.prototype.forEach, create = Object.create;
        module.exports = function(arg) {
            var set = create(null);
            forEach.call(arguments, function(name) {
                set[name] = true;
            });
            return set;
        };
    }, {} ],
    50: [ function(require, module, exports) {
        "use strict";
        module.exports = require("./is-implemented")() ? Object.setPrototypeOf : require("./shim");
    }, {
        "./is-implemented": 51,
        "./shim": 52
    } ],
    51: [ function(require, module, exports) {
        "use strict";
        var create = Object.create, getPrototypeOf = Object.getPrototypeOf, x = {};
        module.exports = function() {
            var setPrototypeOf = Object.setPrototypeOf, customCreate = arguments[0] || create;
            if (typeof setPrototypeOf !== "function") return false;
            return getPrototypeOf(setPrototypeOf(customCreate(null), x)) === x;
        };
    }, {} ],
    52: [ function(require, module, exports) {
        "use strict";
        var isObject = require("../is-object"), value = require("../valid-value"), isPrototypeOf = Object.prototype.isPrototypeOf, defineProperty = Object.defineProperty, nullDesc = {
            configurable: true,
            enumerable: false,
            writable: true,
            value: undefined
        }, validate;
        validate = function(obj, prototype) {
            value(obj);
            if (prototype === null || isObject(prototype)) return obj;
            throw new TypeError("Prototype must be null or an object");
        };
        module.exports = function(status) {
            var fn, set;
            if (!status) return null;
            if (status.level === 2) {
                if (status.set) {
                    set = status.set;
                    fn = function(obj, prototype) {
                        set.call(validate(obj, prototype), prototype);
                        return obj;
                    };
                } else {
                    fn = function(obj, prototype) {
                        validate(obj, prototype).__proto__ = prototype;
                        return obj;
                    };
                }
            } else {
                fn = function self(obj, prototype) {
                    var isNullBase;
                    validate(obj, prototype);
                    isNullBase = isPrototypeOf.call(self.nullPolyfill, obj);
                    if (isNullBase) delete self.nullPolyfill.__proto__;
                    if (prototype === null) prototype = self.nullPolyfill;
                    obj.__proto__ = prototype;
                    if (isNullBase) defineProperty(self.nullPolyfill, "__proto__", nullDesc);
                    return obj;
                };
            }
            return Object.defineProperty(fn, "level", {
                configurable: false,
                enumerable: false,
                writable: false,
                value: status.level
            });
        }(function() {
            var x = Object.create(null), y = {}, set, desc = Object.getOwnPropertyDescriptor(Object.prototype, "__proto__");
            if (desc) {
                try {
                    set = desc.set;
                    set.call(x, y);
                } catch (ignore) {}
                if (Object.getPrototypeOf(x) === y) return {
                    set: set,
                    level: 2
                };
            }
            x.__proto__ = y;
            if (Object.getPrototypeOf(x) === y) return {
                level: 2
            };
            x = {};
            x.__proto__ = y;
            if (Object.getPrototypeOf(x) === y) return {
                level: 1
            };
            return false;
        }());
        require("../create");
    }, {
        "../create": 40,
        "../is-object": 43,
        "../valid-value": 54
    } ],
    53: [ function(require, module, exports) {
        "use strict";
        module.exports = function(fn) {
            if (typeof fn !== "function") throw new TypeError(fn + " is not a function");
            return fn;
        };
    }, {} ],
    54: [ function(require, module, exports) {
        "use strict";
        module.exports = function(value) {
            if (value == null) throw new TypeError("Cannot use null or undefined");
            return value;
        };
    }, {} ],
    55: [ function(require, module, exports) {
        "use strict";
        module.exports = require("./is-implemented")() ? String.prototype.contains : require("./shim");
    }, {
        "./is-implemented": 56,
        "./shim": 57
    } ],
    56: [ function(require, module, exports) {
        "use strict";
        var str = "razdwatrzy";
        module.exports = function() {
            if (typeof str.contains !== "function") return false;
            return str.contains("dwa") === true && str.contains("foo") === false;
        };
    }, {} ],
    57: [ function(require, module, exports) {
        "use strict";
        var indexOf = String.prototype.indexOf;
        module.exports = function(searchString) {
            return indexOf.call(this, searchString, arguments[1]) > -1;
        };
    }, {} ],
    58: [ function(require, module, exports) {
        "use strict";
        var toString = Object.prototype.toString, id = toString.call("");
        module.exports = function(x) {
            return typeof x === "string" || x && typeof x === "object" && (x instanceof String || toString.call(x) === id) || false;
        };
    }, {} ],
    59: [ function(require, module, exports) {
        "use strict";
        var setPrototypeOf = require("es5-ext/object/set-prototype-of"), contains = require("es5-ext/string/#/contains"), d = require("d"), Iterator = require("./"), defineProperty = Object.defineProperty, ArrayIterator;
        ArrayIterator = module.exports = function(arr, kind) {
            if (!(this instanceof ArrayIterator)) return new ArrayIterator(arr, kind);
            Iterator.call(this, arr);
            if (!kind) kind = "value"; else if (contains.call(kind, "key+value")) kind = "key+value"; else if (contains.call(kind, "key")) kind = "key"; else kind = "value";
            defineProperty(this, "__kind__", d("", kind));
        };
        if (setPrototypeOf) setPrototypeOf(ArrayIterator, Iterator);
        ArrayIterator.prototype = Object.create(Iterator.prototype, {
            constructor: d(ArrayIterator),
            _resolve: d(function(i) {
                if (this.__kind__ === "value") return this.__list__[i];
                if (this.__kind__ === "key+value") return [ i, this.__list__[i] ];
                return i;
            }),
            toString: d(function() {
                return "[object Array Iterator]";
            })
        });
    }, {
        "./": 62,
        d: 27,
        "es5-ext/object/set-prototype-of": 50,
        "es5-ext/string/#/contains": 55
    } ],
    60: [ function(require, module, exports) {
        "use strict";
        var callable = require("es5-ext/object/valid-callable"), isString = require("es5-ext/string/is-string"), get = require("./get"), isArray = Array.isArray, call = Function.prototype.call;
        module.exports = function(iterable, cb) {
            var mode, thisArg = arguments[2], result, doBreak, broken, i, l, char, code;
            if (isArray(iterable)) mode = "array"; else if (isString(iterable)) mode = "string"; else iterable = get(iterable);
            callable(cb);
            doBreak = function() {
                broken = true;
            };
            if (mode === "array") {
                iterable.some(function(value) {
                    call.call(cb, thisArg, value, doBreak);
                    if (broken) return true;
                });
                return;
            }
            if (mode === "string") {
                l = iterable.length;
                for (i = 0; i < l; ++i) {
                    char = iterable[i];
                    if (i + 1 < l) {
                        code = char.charCodeAt(0);
                        if (code >= 55296 && code <= 56319) char += iterable[++i];
                    }
                    call.call(cb, thisArg, char, doBreak);
                    if (broken) break;
                }
                return;
            }
            result = iterable.next();
            while (!result.done) {
                call.call(cb, thisArg, result.value, doBreak);
                if (broken) return;
                result = iterable.next();
            }
        };
    }, {
        "./get": 61,
        "es5-ext/object/valid-callable": 53,
        "es5-ext/string/is-string": 58
    } ],
    61: [ function(require, module, exports) {
        "use strict";
        var isString = require("es5-ext/string/is-string"), ArrayIterator = require("./array"), StringIterator = require("./string"), iterable = require("./valid-iterable"), iteratorSymbol = require("es6-symbol").iterator;
        module.exports = function(obj) {
            if (typeof iterable(obj)[iteratorSymbol] === "function") return obj[iteratorSymbol]();
            if (isString(obj)) return new StringIterator(obj);
            return new ArrayIterator(obj);
        };
    }, {
        "./array": 59,
        "./string": 69,
        "./valid-iterable": 70,
        "es5-ext/string/is-string": 58,
        "es6-symbol": 64
    } ],
    62: [ function(require, module, exports) {
        "use strict";
        var clear = require("es5-ext/array/#/clear"), assign = require("es5-ext/object/assign"), callable = require("es5-ext/object/valid-callable"), value = require("es5-ext/object/valid-value"), d = require("d"), autoBind = require("d/auto-bind"), Symbol = require("es6-symbol"), defineProperty = Object.defineProperty, defineProperties = Object.defineProperties, Iterator;
        module.exports = Iterator = function(list, context) {
            if (!(this instanceof Iterator)) return new Iterator(list, context);
            defineProperties(this, {
                __list__: d("w", value(list)),
                __context__: d("w", context),
                __nextIndex__: d("w", 0)
            });
            if (!context) return;
            callable(context.on);
            context.on("_add", this._onAdd);
            context.on("_delete", this._onDelete);
            context.on("_clear", this._onClear);
        };
        defineProperties(Iterator.prototype, assign({
            constructor: d(Iterator),
            _next: d(function() {
                var i;
                if (!this.__list__) return;
                if (this.__redo__) {
                    i = this.__redo__.shift();
                    if (i !== undefined) return i;
                }
                if (this.__nextIndex__ < this.__list__.length) return this.__nextIndex__++;
                this._unBind();
            }),
            next: d(function() {
                return this._createResult(this._next());
            }),
            _createResult: d(function(i) {
                if (i === undefined) return {
                    done: true,
                    value: undefined
                };
                return {
                    done: false,
                    value: this._resolve(i)
                };
            }),
            _resolve: d(function(i) {
                return this.__list__[i];
            }),
            _unBind: d(function() {
                this.__list__ = null;
                delete this.__redo__;
                if (!this.__context__) return;
                this.__context__.off("_add", this._onAdd);
                this.__context__.off("_delete", this._onDelete);
                this.__context__.off("_clear", this._onClear);
                this.__context__ = null;
            }),
            toString: d(function() {
                return "[object Iterator]";
            })
        }, autoBind({
            _onAdd: d(function(index) {
                if (index >= this.__nextIndex__) return;
                ++this.__nextIndex__;
                if (!this.__redo__) {
                    defineProperty(this, "__redo__", d("c", [ index ]));
                    return;
                }
                this.__redo__.forEach(function(redo, i) {
                    if (redo >= index) this.__redo__[i] = ++redo;
                }, this);
                this.__redo__.push(index);
            }),
            _onDelete: d(function(index) {
                var i;
                if (index >= this.__nextIndex__) return;
                --this.__nextIndex__;
                if (!this.__redo__) return;
                i = this.__redo__.indexOf(index);
                if (i !== -1) this.__redo__.splice(i, 1);
                this.__redo__.forEach(function(redo, i) {
                    if (redo > index) this.__redo__[i] = --redo;
                }, this);
            }),
            _onClear: d(function() {
                if (this.__redo__) clear.call(this.__redo__);
                this.__nextIndex__ = 0;
            })
        })));
        defineProperty(Iterator.prototype, Symbol.iterator, d(function() {
            return this;
        }));
        defineProperty(Iterator.prototype, Symbol.toStringTag, d("", "Iterator"));
    }, {
        d: 27,
        "d/auto-bind": 26,
        "es5-ext/array/#/clear": 28,
        "es5-ext/object/assign": 36,
        "es5-ext/object/valid-callable": 53,
        "es5-ext/object/valid-value": 54,
        "es6-symbol": 64
    } ],
    63: [ function(require, module, exports) {
        "use strict";
        var isString = require("es5-ext/string/is-string"), iteratorSymbol = require("es6-symbol").iterator, isArray = Array.isArray;
        module.exports = function(value) {
            if (value == null) return false;
            if (isArray(value)) return true;
            if (isString(value)) return true;
            return typeof value[iteratorSymbol] === "function";
        };
    }, {
        "es5-ext/string/is-string": 58,
        "es6-symbol": 64
    } ],
    64: [ function(require, module, exports) {
        "use strict";
        module.exports = require("./is-implemented")() ? Symbol : require("./polyfill");
    }, {
        "./is-implemented": 65,
        "./polyfill": 67
    } ],
    65: [ function(require, module, exports) {
        "use strict";
        module.exports = function() {
            var symbol;
            if (typeof Symbol !== "function") return false;
            symbol = Symbol("test symbol");
            try {
                String(symbol);
            } catch (e) {
                return false;
            }
            if (typeof Symbol.iterator === "symbol") return true;
            if (typeof Symbol.isConcatSpreadable !== "object") return false;
            if (typeof Symbol.iterator !== "object") return false;
            if (typeof Symbol.toPrimitive !== "object") return false;
            if (typeof Symbol.toStringTag !== "object") return false;
            if (typeof Symbol.unscopables !== "object") return false;
            return true;
        };
    }, {} ],
    66: [ function(require, module, exports) {
        "use strict";
        module.exports = function(x) {
            return x && (typeof x === "symbol" || x["@@toStringTag"] === "Symbol") || false;
        };
    }, {} ],
    67: [ function(require, module, exports) {
        "use strict";
        var d = require("d"), validateSymbol = require("./validate-symbol"), create = Object.create, defineProperties = Object.defineProperties, defineProperty = Object.defineProperty, objPrototype = Object.prototype, Symbol, HiddenSymbol, globalSymbols = create(null);
        var generateName = function() {
            var created = create(null);
            return function(desc) {
                var postfix = 0, name;
                while (created[desc + (postfix || "")]) ++postfix;
                desc += postfix || "";
                created[desc] = true;
                name = "@@" + desc;
                defineProperty(objPrototype, name, d.gs(null, function(value) {
                    defineProperty(this, name, d(value));
                }));
                return name;
            };
        }();
        HiddenSymbol = function Symbol(description) {
            if (this instanceof HiddenSymbol) throw new TypeError("TypeError: Symbol is not a constructor");
            return Symbol(description);
        };
        module.exports = Symbol = function Symbol(description) {
            var symbol;
            if (this instanceof Symbol) throw new TypeError("TypeError: Symbol is not a constructor");
            symbol = create(HiddenSymbol.prototype);
            description = description === undefined ? "" : String(description);
            return defineProperties(symbol, {
                __description__: d("", description),
                __name__: d("", generateName(description))
            });
        };
        defineProperties(Symbol, {
            "for": d(function(key) {
                if (globalSymbols[key]) return globalSymbols[key];
                return globalSymbols[key] = Symbol(String(key));
            }),
            keyFor: d(function(s) {
                var key;
                validateSymbol(s);
                for (key in globalSymbols) if (globalSymbols[key] === s) return key;
            }),
            hasInstance: d("", Symbol("hasInstance")),
            isConcatSpreadable: d("", Symbol("isConcatSpreadable")),
            iterator: d("", Symbol("iterator")),
            match: d("", Symbol("match")),
            replace: d("", Symbol("replace")),
            search: d("", Symbol("search")),
            species: d("", Symbol("species")),
            split: d("", Symbol("split")),
            toPrimitive: d("", Symbol("toPrimitive")),
            toStringTag: d("", Symbol("toStringTag")),
            unscopables: d("", Symbol("unscopables"))
        });
        defineProperties(HiddenSymbol.prototype, {
            constructor: d(Symbol),
            toString: d("", function() {
                return this.__name__;
            })
        });
        defineProperties(Symbol.prototype, {
            toString: d(function() {
                return "Symbol (" + validateSymbol(this).__description__ + ")";
            }),
            valueOf: d(function() {
                return validateSymbol(this);
            })
        });
        defineProperty(Symbol.prototype, Symbol.toPrimitive, d("", function() {
            return validateSymbol(this);
        }));
        defineProperty(Symbol.prototype, Symbol.toStringTag, d("c", "Symbol"));
        defineProperty(HiddenSymbol.prototype, Symbol.toPrimitive, d("c", Symbol.prototype[Symbol.toPrimitive]));
        defineProperty(HiddenSymbol.prototype, Symbol.toStringTag, d("c", Symbol.prototype[Symbol.toStringTag]));
    }, {
        "./validate-symbol": 68,
        d: 27
    } ],
    68: [ function(require, module, exports) {
        "use strict";
        var isSymbol = require("./is-symbol");
        module.exports = function(value) {
            if (!isSymbol(value)) throw new TypeError(value + " is not a symbol");
            return value;
        };
    }, {
        "./is-symbol": 66
    } ],
    69: [ function(require, module, exports) {
        "use strict";
        var setPrototypeOf = require("es5-ext/object/set-prototype-of"), d = require("d"), Iterator = require("./"), defineProperty = Object.defineProperty, StringIterator;
        StringIterator = module.exports = function(str) {
            if (!(this instanceof StringIterator)) return new StringIterator(str);
            str = String(str);
            Iterator.call(this, str);
            defineProperty(this, "__length__", d("", str.length));
        };
        if (setPrototypeOf) setPrototypeOf(StringIterator, Iterator);
        StringIterator.prototype = Object.create(Iterator.prototype, {
            constructor: d(StringIterator),
            _next: d(function() {
                if (!this.__list__) return;
                if (this.__nextIndex__ < this.__length__) return this.__nextIndex__++;
                this._unBind();
            }),
            _resolve: d(function(i) {
                var char = this.__list__[i], code;
                if (this.__nextIndex__ === this.__length__) return char;
                code = char.charCodeAt(0);
                if (code >= 55296 && code <= 56319) return char + this.__list__[this.__nextIndex__++];
                return char;
            }),
            toString: d(function() {
                return "[object String Iterator]";
            })
        });
    }, {
        "./": 62,
        d: 27,
        "es5-ext/object/set-prototype-of": 50
    } ],
    70: [ function(require, module, exports) {
        "use strict";
        var isIterable = require("./is-iterable");
        module.exports = function(value) {
            if (!isIterable(value)) throw new TypeError(value + " is not iterable");
            return value;
        };
    }, {
        "./is-iterable": 63
    } ],
    71: [ function(require, module, exports) {
        arguments[4][64][0].apply(exports, arguments);
    }, {
        "./is-implemented": 72,
        "./polyfill": 73,
        dup: 64
    } ],
    72: [ function(require, module, exports) {
        "use strict";
        module.exports = function() {
            var symbol;
            if (typeof Symbol !== "function") return false;
            symbol = Symbol("test symbol");
            try {
                String(symbol);
            } catch (e) {
                return false;
            }
            if (typeof Symbol.iterator === "symbol") return true;
            if (typeof Symbol.isConcatSpreadable !== "object") return false;
            if (typeof Symbol.isRegExp !== "object") return false;
            if (typeof Symbol.iterator !== "object") return false;
            if (typeof Symbol.toPrimitive !== "object") return false;
            if (typeof Symbol.toStringTag !== "object") return false;
            if (typeof Symbol.unscopables !== "object") return false;
            return true;
        };
    }, {} ],
    73: [ function(require, module, exports) {
        "use strict";
        var d = require("d"), create = Object.create, defineProperties = Object.defineProperties, generateName, Symbol;
        generateName = function() {
            var created = create(null);
            return function(desc) {
                var postfix = 0;
                while (created[desc + (postfix || "")]) ++postfix;
                desc += postfix || "";
                created[desc] = true;
                return "@@" + desc;
            };
        }();
        module.exports = Symbol = function(description) {
            var symbol;
            if (this instanceof Symbol) {
                throw new TypeError("TypeError: Symbol is not a constructor");
            }
            symbol = create(Symbol.prototype);
            description = description === undefined ? "" : String(description);
            return defineProperties(symbol, {
                __description__: d("", description),
                __name__: d("", generateName(description))
            });
        };
        Object.defineProperties(Symbol, {
            create: d("", Symbol("create")),
            hasInstance: d("", Symbol("hasInstance")),
            isConcatSpreadable: d("", Symbol("isConcatSpreadable")),
            isRegExp: d("", Symbol("isRegExp")),
            iterator: d("", Symbol("iterator")),
            toPrimitive: d("", Symbol("toPrimitive")),
            toStringTag: d("", Symbol("toStringTag")),
            unscopables: d("", Symbol("unscopables"))
        });
        defineProperties(Symbol.prototype, {
            properToString: d(function() {
                return "Symbol (" + this.__description__ + ")";
            }),
            toString: d("", function() {
                return this.__name__;
            })
        });
        Object.defineProperty(Symbol.prototype, Symbol.toPrimitive, d("", function(hint) {
            throw new TypeError("Conversion of symbol objects is not allowed");
        }));
        Object.defineProperty(Symbol.prototype, Symbol.toStringTag, d("c", "Symbol"));
    }, {
        d: 27
    } ],
    74: [ function(require, module, exports) {
        "use strict";
        var d = require("d"), callable = require("es5-ext/object/valid-callable"), apply = Function.prototype.apply, call = Function.prototype.call, create = Object.create, defineProperty = Object.defineProperty, defineProperties = Object.defineProperties, hasOwnProperty = Object.prototype.hasOwnProperty, descriptor = {
            configurable: true,
            enumerable: false,
            writable: true
        }, on, once, off, emit, methods, descriptors, base;
        on = function(type, listener) {
            var data;
            callable(listener);
            if (!hasOwnProperty.call(this, "__ee__")) {
                data = descriptor.value = create(null);
                defineProperty(this, "__ee__", descriptor);
                descriptor.value = null;
            } else {
                data = this.__ee__;
            }
            if (!data[type]) data[type] = listener; else if (typeof data[type] === "object") data[type].push(listener); else data[type] = [ data[type], listener ];
            return this;
        };
        once = function(type, listener) {
            var once, self;
            callable(listener);
            self = this;
            on.call(this, type, once = function() {
                off.call(self, type, once);
                apply.call(listener, this, arguments);
            });
            once.__eeOnceListener__ = listener;
            return this;
        };
        off = function(type, listener) {
            var data, listeners, candidate, i;
            callable(listener);
            if (!hasOwnProperty.call(this, "__ee__")) return this;
            data = this.__ee__;
            if (!data[type]) return this;
            listeners = data[type];
            if (typeof listeners === "object") {
                for (i = 0; candidate = listeners[i]; ++i) {
                    if (candidate === listener || candidate.__eeOnceListener__ === listener) {
                        if (listeners.length === 2) data[type] = listeners[i ? 0 : 1]; else listeners.splice(i, 1);
                    }
                }
            } else {
                if (listeners === listener || listeners.__eeOnceListener__ === listener) {
                    delete data[type];
                }
            }
            return this;
        };
        emit = function(type) {
            var i, l, listener, listeners, args;
            if (!hasOwnProperty.call(this, "__ee__")) return;
            listeners = this.__ee__[type];
            if (!listeners) return;
            if (typeof listeners === "object") {
                l = arguments.length;
                args = new Array(l - 1);
                for (i = 1; i < l; ++i) args[i - 1] = arguments[i];
                listeners = listeners.slice();
                for (i = 0; listener = listeners[i]; ++i) {
                    apply.call(listener, this, args);
                }
            } else {
                switch (arguments.length) {
                  case 1:
                    call.call(listeners, this);
                    break;

                  case 2:
                    call.call(listeners, this, arguments[1]);
                    break;

                  case 3:
                    call.call(listeners, this, arguments[1], arguments[2]);
                    break;

                  default:
                    l = arguments.length;
                    args = new Array(l - 1);
                    for (i = 1; i < l; ++i) {
                        args[i - 1] = arguments[i];
                    }
                    apply.call(listeners, this, args);
                }
            }
        };
        methods = {
            on: on,
            once: once,
            off: off,
            emit: emit
        };
        descriptors = {
            on: d(on),
            once: d(once),
            off: d(off),
            emit: d(emit)
        };
        base = defineProperties({}, descriptors);
        module.exports = exports = function(o) {
            return o == null ? create(base) : defineProperties(Object(o), descriptors);
        };
        exports.methods = methods;
    }, {
        d: 27,
        "es5-ext/object/valid-callable": 53
    } ],
    75: [ function(require, module, exports) {
        "use strict";
        var clear = require("es5-ext/array/#/clear"), eIndexOf = require("es5-ext/array/#/e-index-of"), setPrototypeOf = require("es5-ext/object/set-prototype-of"), callable = require("es5-ext/object/valid-callable"), validValue = require("es5-ext/object/valid-value"), d = require("d"), ee = require("event-emitter"), Symbol = require("es6-symbol"), iterator = require("es6-iterator/valid-iterable"), forOf = require("es6-iterator/for-of"), Iterator = require("./lib/iterator"), isNative = require("./is-native-implemented"), call = Function.prototype.call, defineProperties = Object.defineProperties, MapPoly;
        module.exports = MapPoly = function() {
            var iterable = arguments[0], keys, values;
            if (!(this instanceof MapPoly)) return new MapPoly(iterable);
            if (this.__mapKeysData__ !== undefined) {
                throw new TypeError(this + " cannot be reinitialized");
            }
            if (iterable != null) iterator(iterable);
            defineProperties(this, {
                __mapKeysData__: d("c", keys = []),
                __mapValuesData__: d("c", values = [])
            });
            if (!iterable) return;
            forOf(iterable, function(value) {
                var key = validValue(value)[0];
                value = value[1];
                if (eIndexOf.call(keys, key) !== -1) return;
                keys.push(key);
                values.push(value);
            }, this);
        };
        if (isNative) {
            if (setPrototypeOf) setPrototypeOf(MapPoly, Map);
            MapPoly.prototype = Object.create(Map.prototype, {
                constructor: d(MapPoly)
            });
        }
        ee(defineProperties(MapPoly.prototype, {
            clear: d(function() {
                if (!this.__mapKeysData__.length) return;
                clear.call(this.__mapKeysData__);
                clear.call(this.__mapValuesData__);
                this.emit("_clear");
            }),
            "delete": d(function(key) {
                var index = eIndexOf.call(this.__mapKeysData__, key);
                if (index === -1) return false;
                this.__mapKeysData__.splice(index, 1);
                this.__mapValuesData__.splice(index, 1);
                this.emit("_delete", index, key);
                return true;
            }),
            entries: d(function() {
                return new Iterator(this, "key+value");
            }),
            forEach: d(function(cb) {
                var thisArg = arguments[1], iterator, result;
                callable(cb);
                iterator = this.entries();
                result = iterator._next();
                while (result !== undefined) {
                    call.call(cb, thisArg, this.__mapValuesData__[result], this.__mapKeysData__[result], this);
                    result = iterator._next();
                }
            }),
            get: d(function(key) {
                var index = eIndexOf.call(this.__mapKeysData__, key);
                if (index === -1) return;
                return this.__mapValuesData__[index];
            }),
            has: d(function(key) {
                return eIndexOf.call(this.__mapKeysData__, key) !== -1;
            }),
            keys: d(function() {
                return new Iterator(this, "key");
            }),
            set: d(function(key, value) {
                var index = eIndexOf.call(this.__mapKeysData__, key), emit;
                if (index === -1) {
                    index = this.__mapKeysData__.push(key) - 1;
                    emit = true;
                }
                this.__mapValuesData__[index] = value;
                if (emit) this.emit("_add", index, key);
                return this;
            }),
            size: d.gs(function() {
                return this.__mapKeysData__.length;
            }),
            values: d(function() {
                return new Iterator(this, "value");
            }),
            toString: d(function() {
                return "[object Map]";
            })
        }));
        Object.defineProperty(MapPoly.prototype, Symbol.iterator, d(function() {
            return this.entries();
        }));
        Object.defineProperty(MapPoly.prototype, Symbol.toStringTag, d("c", "Map"));
    }, {
        "./is-native-implemented": 23,
        "./lib/iterator": 25,
        d: 27,
        "es5-ext/array/#/clear": 28,
        "es5-ext/array/#/e-index-of": 29,
        "es5-ext/object/set-prototype-of": 50,
        "es5-ext/object/valid-callable": 53,
        "es5-ext/object/valid-value": 54,
        "es6-iterator/for-of": 60,
        "es6-iterator/valid-iterable": 70,
        "es6-symbol": 71,
        "event-emitter": 74
    } ],
    76: [ function(require, module, exports) {
        var Gaussian = function(mean, variance) {
            if (variance <= 0) {
                throw new Error("Variance must be > 0 (but was " + variance + ")");
            }
            var stddev = Math.sqrt(variance);
            var precision = 1 / variance;
            var precisionmean = precision * mean;
            var erfc = function(x) {
                var z = Math.abs(x);
                var t = 1 / (1 + z / 2);
                var r = t * Math.exp(-z * z - 1.26551223 + t * (1.00002368 + t * (.37409196 + t * (.09678418 + t * (-.18628806 + t * (.27886807 + t * (-1.13520398 + t * (1.48851587 + t * (-.82215223 + t * .17087277)))))))));
                return x >= 0 ? r : 2 - r;
            };
            var ierfc = function(x) {
                if (x >= 2) {
                    return -100;
                }
                if (x <= 0) {
                    return 100;
                }
                var xx = x < 1 ? x : 2 - x;
                var t = Math.sqrt(-2 * Math.log(xx / 2));
                var r = -.70711 * ((2.30753 + t * .27061) / (1 + t * (.99229 + t * .04481)) - t);
                for (var j = 0; j < 2; j++) {
                    var err = erfc(r) - xx;
                    r += err / (1.1283791670955126 * Math.exp(-(r * r)) - r * err);
                }
                return x < 1 ? r : -r;
            };
            var fromPrecisionMean = function(precision, precisionmean) {
                var mean = precisionmean / precision;
                var variance = 1 / precision;
                return new Gaussian(mean, variance);
            };
            return {
                mean: mean,
                variance: variance,
                standardDeviation: stddev,
                precision: precision,
                precisionmean: precisionmean,
                pdf: function(x) {
                    var m = stddev * Math.sqrt(2 * Math.PI);
                    var e = Math.exp(-Math.pow(x - mean, 2) / (2 * variance));
                    return e / m;
                },
                cdf: function(x) {
                    return .5 * erfc(-(x - mean) / (stddev * Math.sqrt(2)));
                },
                ppf: function(x) {
                    return mean - stddev * Math.sqrt(2) * ierfc(2 * x);
                },
                mul: function(d) {
                    return fromPrecisionMean(precision + d.precision, precisionmean + d.precisionmean);
                },
                div: function(d) {
                    return fromPrecisionMean(precision - d.precision, precisionmean - d.precisionmean);
                }
            };
        };
        module.exports = function(mean, variance) {
            return new Gaussian(mean, variance);
        };
    }, {} ],
    77: [ function(require, module, exports) {
        (function(global) {
            (function() {
                var undefined;
                var VERSION = "3.6.0";
                var BIND_FLAG = 1, BIND_KEY_FLAG = 2, CURRY_BOUND_FLAG = 4, CURRY_FLAG = 8, CURRY_RIGHT_FLAG = 16, PARTIAL_FLAG = 32, PARTIAL_RIGHT_FLAG = 64, ARY_FLAG = 128, REARG_FLAG = 256;
                var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
                var HOT_COUNT = 150, HOT_SPAN = 16;
                var LAZY_DROP_WHILE_FLAG = 0, LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2;
                var FUNC_ERROR_TEXT = "Expected a function";
                var PLACEHOLDER = "__lodash_placeholder__";
                var argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag = "[object Object]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", weakMapTag = "[object WeakMap]";
                var arrayBufferTag = "[object ArrayBuffer]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
                var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
                var reEscapedHtml = /&(?:amp|lt|gt|quot|#39|#96);/g, reUnescapedHtml = /[&<>"'`]/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
                var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
                var reComboMarks = /[\u0300-\u036f\ufe20-\ufe23]/g;
                var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
                var reFlags = /\w*$/;
                var reHexPrefix = /^0[xX]/;
                var reHostCtor = /^\[object .+?Constructor\]$/;
                var reLatin1 = /[\xc0-\xd6\xd8-\xde\xdf-\xf6\xf8-\xff]/g;
                var reNoMatch = /($^)/;
                var reRegExpChars = /[.*+?^${}()|[\]\/\\]/g, reHasRegExpChars = RegExp(reRegExpChars.source);
                var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
                var reWords = function() {
                    var upper = "[A-Z\\xc0-\\xd6\\xd8-\\xde]", lower = "[a-z\\xdf-\\xf6\\xf8-\\xff]+";
                    return RegExp(upper + "+(?=" + upper + lower + ")|" + upper + "?" + lower + "|" + upper + "+|[0-9]+", "g");
                }();
                var whitespace = " 	\f \ufeff" + "\n\r\u2028\u2029" + " ᠎             　";
                var contextProps = [ "Array", "ArrayBuffer", "Date", "Error", "Float32Array", "Float64Array", "Function", "Int8Array", "Int16Array", "Int32Array", "Math", "Number", "Object", "RegExp", "Set", "String", "_", "clearTimeout", "document", "isFinite", "parseInt", "setTimeout", "TypeError", "Uint8Array", "Uint8ClampedArray", "Uint16Array", "Uint32Array", "WeakMap", "window" ];
                var templateCounter = -1;
                var typedArrayTags = {};
                typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
                typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
                var cloneableTags = {};
                cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[stringTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
                cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[mapTag] = cloneableTags[setTag] = cloneableTags[weakMapTag] = false;
                var debounceOptions = {
                    leading: false,
                    maxWait: 0,
                    trailing: false
                };
                var deburredLetters = {
                    "À": "A",
                    "Á": "A",
                    "Â": "A",
                    "Ã": "A",
                    "Ä": "A",
                    "Å": "A",
                    "à": "a",
                    "á": "a",
                    "â": "a",
                    "ã": "a",
                    "ä": "a",
                    "å": "a",
                    "Ç": "C",
                    "ç": "c",
                    "Ð": "D",
                    "ð": "d",
                    "È": "E",
                    "É": "E",
                    "Ê": "E",
                    "Ë": "E",
                    "è": "e",
                    "é": "e",
                    "ê": "e",
                    "ë": "e",
                    "Ì": "I",
                    "Í": "I",
                    "Î": "I",
                    "Ï": "I",
                    "ì": "i",
                    "í": "i",
                    "î": "i",
                    "ï": "i",
                    "Ñ": "N",
                    "ñ": "n",
                    "Ò": "O",
                    "Ó": "O",
                    "Ô": "O",
                    "Õ": "O",
                    "Ö": "O",
                    "Ø": "O",
                    "ò": "o",
                    "ó": "o",
                    "ô": "o",
                    "õ": "o",
                    "ö": "o",
                    "ø": "o",
                    "Ù": "U",
                    "Ú": "U",
                    "Û": "U",
                    "Ü": "U",
                    "ù": "u",
                    "ú": "u",
                    "û": "u",
                    "ü": "u",
                    "Ý": "Y",
                    "ý": "y",
                    "ÿ": "y",
                    "Æ": "Ae",
                    "æ": "ae",
                    "Þ": "Th",
                    "þ": "th",
                    "ß": "ss"
                };
                var htmlEscapes = {
                    "&": "&amp;",
                    "<": "&lt;",
                    ">": "&gt;",
                    '"': "&quot;",
                    "'": "&#39;",
                    "`": "&#96;"
                };
                var htmlUnescapes = {
                    "&amp;": "&",
                    "&lt;": "<",
                    "&gt;": ">",
                    "&quot;": '"',
                    "&#39;": "'",
                    "&#96;": "`"
                };
                var objectTypes = {
                    "function": true,
                    object: true
                };
                var stringEscapes = {
                    "\\": "\\",
                    "'": "'",
                    "\n": "n",
                    "\r": "r",
                    "\u2028": "u2028",
                    "\u2029": "u2029"
                };
                var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;
                var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;
                var freeGlobal = freeExports && freeModule && typeof global == "object" && global;
                var freeSelf = objectTypes[typeof self] && self && self.Object && self;
                var freeWindow = objectTypes[typeof window] && window && window.Object && window;
                var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;
                var root = freeGlobal || freeWindow !== (this && this.window) && freeWindow || freeSelf || this;
                function baseCompareAscending(value, other) {
                    if (value !== other) {
                        var valIsReflexive = value === value, othIsReflexive = other === other;
                        if (value > other || !valIsReflexive || typeof value == "undefined" && othIsReflexive) {
                            return 1;
                        }
                        if (value < other || !othIsReflexive || typeof other == "undefined" && valIsReflexive) {
                            return -1;
                        }
                    }
                    return 0;
                }
                function baseFindIndex(array, predicate, fromRight) {
                    var length = array.length, index = fromRight ? length : -1;
                    while (fromRight ? index-- : ++index < length) {
                        if (predicate(array[index], index, array)) {
                            return index;
                        }
                    }
                    return -1;
                }
                function baseIndexOf(array, value, fromIndex) {
                    if (value !== value) {
                        return indexOfNaN(array, fromIndex);
                    }
                    var index = fromIndex - 1, length = array.length;
                    while (++index < length) {
                        if (array[index] === value) {
                            return index;
                        }
                    }
                    return -1;
                }
                function baseIsFunction(value) {
                    return typeof value == "function" || false;
                }
                function baseToString(value) {
                    if (typeof value == "string") {
                        return value;
                    }
                    return value == null ? "" : value + "";
                }
                function charAtCallback(string) {
                    return string.charCodeAt(0);
                }
                function charsLeftIndex(string, chars) {
                    var index = -1, length = string.length;
                    while (++index < length && chars.indexOf(string.charAt(index)) > -1) {}
                    return index;
                }
                function charsRightIndex(string, chars) {
                    var index = string.length;
                    while (index-- && chars.indexOf(string.charAt(index)) > -1) {}
                    return index;
                }
                function compareAscending(object, other) {
                    return baseCompareAscending(object.criteria, other.criteria) || object.index - other.index;
                }
                function compareMultiple(object, other, orders) {
                    var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
                    while (++index < length) {
                        var result = baseCompareAscending(objCriteria[index], othCriteria[index]);
                        if (result) {
                            if (index >= ordersLength) {
                                return result;
                            }
                            return result * (orders[index] ? 1 : -1);
                        }
                    }
                    return object.index - other.index;
                }
                function deburrLetter(letter) {
                    return deburredLetters[letter];
                }
                function escapeHtmlChar(chr) {
                    return htmlEscapes[chr];
                }
                function escapeStringChar(chr) {
                    return "\\" + stringEscapes[chr];
                }
                function indexOfNaN(array, fromIndex, fromRight) {
                    var length = array.length, index = fromIndex + (fromRight ? 0 : -1);
                    while (fromRight ? index-- : ++index < length) {
                        var other = array[index];
                        if (other !== other) {
                            return index;
                        }
                    }
                    return -1;
                }
                function isObjectLike(value) {
                    return !!value && typeof value == "object";
                }
                function isSpace(charCode) {
                    return charCode <= 160 && (charCode >= 9 && charCode <= 13) || charCode == 32 || charCode == 160 || charCode == 5760 || charCode == 6158 || charCode >= 8192 && (charCode <= 8202 || charCode == 8232 || charCode == 8233 || charCode == 8239 || charCode == 8287 || charCode == 12288 || charCode == 65279);
                }
                function replaceHolders(array, placeholder) {
                    var index = -1, length = array.length, resIndex = -1, result = [];
                    while (++index < length) {
                        if (array[index] === placeholder) {
                            array[index] = PLACEHOLDER;
                            result[++resIndex] = index;
                        }
                    }
                    return result;
                }
                function sortedUniq(array, iteratee) {
                    var seen, index = -1, length = array.length, resIndex = -1, result = [];
                    while (++index < length) {
                        var value = array[index], computed = iteratee ? iteratee(value, index, array) : value;
                        if (!index || seen !== computed) {
                            seen = computed;
                            result[++resIndex] = value;
                        }
                    }
                    return result;
                }
                function trimmedLeftIndex(string) {
                    var index = -1, length = string.length;
                    while (++index < length && isSpace(string.charCodeAt(index))) {}
                    return index;
                }
                function trimmedRightIndex(string) {
                    var index = string.length;
                    while (index-- && isSpace(string.charCodeAt(index))) {}
                    return index;
                }
                function unescapeHtmlChar(chr) {
                    return htmlUnescapes[chr];
                }
                function runInContext(context) {
                    context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;
                    var Array = context.Array, Date = context.Date, Error = context.Error, Function = context.Function, Math = context.Math, Number = context.Number, Object = context.Object, RegExp = context.RegExp, String = context.String, TypeError = context.TypeError;
                    var arrayProto = Array.prototype, objectProto = Object.prototype, stringProto = String.prototype;
                    var document = (document = context.window) && document.document;
                    var fnToString = Function.prototype.toString;
                    var getLength = baseProperty("length");
                    var hasOwnProperty = objectProto.hasOwnProperty;
                    var idCounter = 0;
                    var objToString = objectProto.toString;
                    var oldDash = context._;
                    var reNative = RegExp("^" + escapeRegExp(objToString).replace(/toString|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
                    var ArrayBuffer = isNative(ArrayBuffer = context.ArrayBuffer) && ArrayBuffer, bufferSlice = isNative(bufferSlice = ArrayBuffer && new ArrayBuffer(0).slice) && bufferSlice, ceil = Math.ceil, clearTimeout = context.clearTimeout, floor = Math.floor, getPrototypeOf = isNative(getPrototypeOf = Object.getPrototypeOf) && getPrototypeOf, push = arrayProto.push, propertyIsEnumerable = objectProto.propertyIsEnumerable, Set = isNative(Set = context.Set) && Set, setTimeout = context.setTimeout, splice = arrayProto.splice, Uint8Array = isNative(Uint8Array = context.Uint8Array) && Uint8Array, WeakMap = isNative(WeakMap = context.WeakMap) && WeakMap;
                    var Float64Array = function() {
                        try {
                            var func = isNative(func = context.Float64Array) && func, result = new func(new ArrayBuffer(10), 0, 1) && func;
                        } catch (e) {}
                        return result;
                    }();
                    var nativeIsArray = isNative(nativeIsArray = Array.isArray) && nativeIsArray, nativeCreate = isNative(nativeCreate = Object.create) && nativeCreate, nativeIsFinite = context.isFinite, nativeKeys = isNative(nativeKeys = Object.keys) && nativeKeys, nativeMax = Math.max, nativeMin = Math.min, nativeNow = isNative(nativeNow = Date.now) && nativeNow, nativeNumIsFinite = isNative(nativeNumIsFinite = Number.isFinite) && nativeNumIsFinite, nativeParseInt = context.parseInt, nativeRandom = Math.random;
                    var NEGATIVE_INFINITY = Number.NEGATIVE_INFINITY, POSITIVE_INFINITY = Number.POSITIVE_INFINITY;
                    var MAX_ARRAY_LENGTH = Math.pow(2, 32) - 1, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
                    var FLOAT64_BYTES_PER_ELEMENT = Float64Array ? Float64Array.BYTES_PER_ELEMENT : 0;
                    var MAX_SAFE_INTEGER = Math.pow(2, 53) - 1;
                    var metaMap = WeakMap && new WeakMap();
                    var realNames = {};
                    function lodash(value) {
                        if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
                            if (value instanceof LodashWrapper) {
                                return value;
                            }
                            if (hasOwnProperty.call(value, "__chain__") && hasOwnProperty.call(value, "__wrapped__")) {
                                return wrapperClone(value);
                            }
                        }
                        return new LodashWrapper(value);
                    }
                    function baseLodash() {}
                    function LodashWrapper(value, chainAll, actions) {
                        this.__wrapped__ = value;
                        this.__actions__ = actions || [];
                        this.__chain__ = !!chainAll;
                    }
                    var support = lodash.support = {};
                    (function(x) {
                        support.funcDecomp = /\bthis\b/.test(function() {
                            return this;
                        });
                        support.funcNames = typeof Function.name == "string";
                        try {
                            support.dom = document.createDocumentFragment().nodeType === 11;
                        } catch (e) {
                            support.dom = false;
                        }
                        try {
                            support.nonEnumArgs = !propertyIsEnumerable.call(arguments, 1);
                        } catch (e) {
                            support.nonEnumArgs = true;
                        }
                    })(0, 0);
                    lodash.templateSettings = {
                        escape: reEscape,
                        evaluate: reEvaluate,
                        interpolate: reInterpolate,
                        variable: "",
                        imports: {
                            _: lodash
                        }
                    };
                    function LazyWrapper(value) {
                        this.__wrapped__ = value;
                        this.__actions__ = null;
                        this.__dir__ = 1;
                        this.__dropCount__ = 0;
                        this.__filtered__ = false;
                        this.__iteratees__ = null;
                        this.__takeCount__ = POSITIVE_INFINITY;
                        this.__views__ = null;
                    }
                    function lazyClone() {
                        var actions = this.__actions__, iteratees = this.__iteratees__, views = this.__views__, result = new LazyWrapper(this.__wrapped__);
                        result.__actions__ = actions ? arrayCopy(actions) : null;
                        result.__dir__ = this.__dir__;
                        result.__filtered__ = this.__filtered__;
                        result.__iteratees__ = iteratees ? arrayCopy(iteratees) : null;
                        result.__takeCount__ = this.__takeCount__;
                        result.__views__ = views ? arrayCopy(views) : null;
                        return result;
                    }
                    function lazyReverse() {
                        if (this.__filtered__) {
                            var result = new LazyWrapper(this);
                            result.__dir__ = -1;
                            result.__filtered__ = true;
                        } else {
                            result = this.clone();
                            result.__dir__ *= -1;
                        }
                        return result;
                    }
                    function lazyValue() {
                        var array = this.__wrapped__.value();
                        if (!isArray(array)) {
                            return baseWrapperValue(array, this.__actions__);
                        }
                        var dir = this.__dir__, isRight = dir < 0, view = getView(0, array.length, this.__views__), start = view.start, end = view.end, length = end - start, index = isRight ? end : start - 1, takeCount = nativeMin(length, this.__takeCount__), iteratees = this.__iteratees__, iterLength = iteratees ? iteratees.length : 0, resIndex = 0, result = [];
                        outer: while (length-- && resIndex < takeCount) {
                            index += dir;
                            var iterIndex = -1, value = array[index];
                            while (++iterIndex < iterLength) {
                                var data = iteratees[iterIndex], iteratee = data.iteratee, type = data.type;
                                if (type == LAZY_DROP_WHILE_FLAG) {
                                    if (data.done && (isRight ? index > data.index : index < data.index)) {
                                        data.count = 0;
                                        data.done = false;
                                    }
                                    data.index = index;
                                    if (!data.done) {
                                        var limit = data.limit;
                                        if (!(data.done = limit > -1 ? data.count++ >= limit : !iteratee(value))) {
                                            continue outer;
                                        }
                                    }
                                } else {
                                    var computed = iteratee(value);
                                    if (type == LAZY_MAP_FLAG) {
                                        value = computed;
                                    } else if (!computed) {
                                        if (type == LAZY_FILTER_FLAG) {
                                            continue outer;
                                        } else {
                                            break outer;
                                        }
                                    }
                                }
                            }
                            result[resIndex++] = value;
                        }
                        return result;
                    }
                    function MapCache() {
                        this.__data__ = {};
                    }
                    function mapDelete(key) {
                        return this.has(key) && delete this.__data__[key];
                    }
                    function mapGet(key) {
                        return key == "__proto__" ? undefined : this.__data__[key];
                    }
                    function mapHas(key) {
                        return key != "__proto__" && hasOwnProperty.call(this.__data__, key);
                    }
                    function mapSet(key, value) {
                        if (key != "__proto__") {
                            this.__data__[key] = value;
                        }
                        return this;
                    }
                    function SetCache(values) {
                        var length = values ? values.length : 0;
                        this.data = {
                            hash: nativeCreate(null),
                            set: new Set()
                        };
                        while (length--) {
                            this.push(values[length]);
                        }
                    }
                    function cacheIndexOf(cache, value) {
                        var data = cache.data, result = typeof value == "string" || isObject(value) ? data.set.has(value) : data.hash[value];
                        return result ? 0 : -1;
                    }
                    function cachePush(value) {
                        var data = this.data;
                        if (typeof value == "string" || isObject(value)) {
                            data.set.add(value);
                        } else {
                            data.hash[value] = true;
                        }
                    }
                    function arrayCopy(source, array) {
                        var index = -1, length = source.length;
                        array || (array = Array(length));
                        while (++index < length) {
                            array[index] = source[index];
                        }
                        return array;
                    }
                    function arrayEach(array, iteratee) {
                        var index = -1, length = array.length;
                        while (++index < length) {
                            if (iteratee(array[index], index, array) === false) {
                                break;
                            }
                        }
                        return array;
                    }
                    function arrayEachRight(array, iteratee) {
                        var length = array.length;
                        while (length--) {
                            if (iteratee(array[length], length, array) === false) {
                                break;
                            }
                        }
                        return array;
                    }
                    function arrayEvery(array, predicate) {
                        var index = -1, length = array.length;
                        while (++index < length) {
                            if (!predicate(array[index], index, array)) {
                                return false;
                            }
                        }
                        return true;
                    }
                    function arrayFilter(array, predicate) {
                        var index = -1, length = array.length, resIndex = -1, result = [];
                        while (++index < length) {
                            var value = array[index];
                            if (predicate(value, index, array)) {
                                result[++resIndex] = value;
                            }
                        }
                        return result;
                    }
                    function arrayMap(array, iteratee) {
                        var index = -1, length = array.length, result = Array(length);
                        while (++index < length) {
                            result[index] = iteratee(array[index], index, array);
                        }
                        return result;
                    }
                    function arrayMax(array) {
                        var index = -1, length = array.length, result = NEGATIVE_INFINITY;
                        while (++index < length) {
                            var value = array[index];
                            if (value > result) {
                                result = value;
                            }
                        }
                        return result;
                    }
                    function arrayMin(array) {
                        var index = -1, length = array.length, result = POSITIVE_INFINITY;
                        while (++index < length) {
                            var value = array[index];
                            if (value < result) {
                                result = value;
                            }
                        }
                        return result;
                    }
                    function arrayReduce(array, iteratee, accumulator, initFromArray) {
                        var index = -1, length = array.length;
                        if (initFromArray && length) {
                            accumulator = array[++index];
                        }
                        while (++index < length) {
                            accumulator = iteratee(accumulator, array[index], index, array);
                        }
                        return accumulator;
                    }
                    function arrayReduceRight(array, iteratee, accumulator, initFromArray) {
                        var length = array.length;
                        if (initFromArray && length) {
                            accumulator = array[--length];
                        }
                        while (length--) {
                            accumulator = iteratee(accumulator, array[length], length, array);
                        }
                        return accumulator;
                    }
                    function arraySome(array, predicate) {
                        var index = -1, length = array.length;
                        while (++index < length) {
                            if (predicate(array[index], index, array)) {
                                return true;
                            }
                        }
                        return false;
                    }
                    function arraySum(array) {
                        var length = array.length, result = 0;
                        while (length--) {
                            result += +array[length] || 0;
                        }
                        return result;
                    }
                    function assignDefaults(objectValue, sourceValue) {
                        return typeof objectValue == "undefined" ? sourceValue : objectValue;
                    }
                    function assignOwnDefaults(objectValue, sourceValue, key, object) {
                        return typeof objectValue == "undefined" || !hasOwnProperty.call(object, key) ? sourceValue : objectValue;
                    }
                    function baseAssign(object, source, customizer) {
                        var props = keys(source);
                        if (!customizer) {
                            return baseCopy(source, object, props);
                        }
                        var index = -1, length = props.length;
                        while (++index < length) {
                            var key = props[index], value = object[key], result = customizer(value, source[key], key, object, source);
                            if ((result === result ? result !== value : value === value) || typeof value == "undefined" && !(key in object)) {
                                object[key] = result;
                            }
                        }
                        return object;
                    }
                    function baseAt(collection, props) {
                        var index = -1, length = collection.length, isArr = isLength(length), propsLength = props.length, result = Array(propsLength);
                        while (++index < propsLength) {
                            var key = props[index];
                            if (isArr) {
                                key = parseFloat(key);
                                result[index] = isIndex(key, length) ? collection[key] : undefined;
                            } else {
                                result[index] = collection[key];
                            }
                        }
                        return result;
                    }
                    function baseCopy(source, object, props) {
                        if (!props) {
                            props = object;
                            object = {};
                        }
                        var index = -1, length = props.length;
                        while (++index < length) {
                            var key = props[index];
                            object[key] = source[key];
                        }
                        return object;
                    }
                    function baseCallback(func, thisArg, argCount) {
                        var type = typeof func;
                        if (type == "function") {
                            return typeof thisArg == "undefined" ? func : bindCallback(func, thisArg, argCount);
                        }
                        if (func == null) {
                            return identity;
                        }
                        if (type == "object") {
                            return baseMatches(func);
                        }
                        return typeof thisArg == "undefined" ? baseProperty(func + "") : baseMatchesProperty(func + "", thisArg);
                    }
                    function baseClone(value, isDeep, customizer, key, object, stackA, stackB) {
                        var result;
                        if (customizer) {
                            result = object ? customizer(value, key, object) : customizer(value);
                        }
                        if (typeof result != "undefined") {
                            return result;
                        }
                        if (!isObject(value)) {
                            return value;
                        }
                        var isArr = isArray(value);
                        if (isArr) {
                            result = initCloneArray(value);
                            if (!isDeep) {
                                return arrayCopy(value, result);
                            }
                        } else {
                            var tag = objToString.call(value), isFunc = tag == funcTag;
                            if (tag == objectTag || tag == argsTag || isFunc && !object) {
                                result = initCloneObject(isFunc ? {} : value);
                                if (!isDeep) {
                                    return baseCopy(value, result, keys(value));
                                }
                            } else {
                                return cloneableTags[tag] ? initCloneByTag(value, tag, isDeep) : object ? value : {};
                            }
                        }
                        stackA || (stackA = []);
                        stackB || (stackB = []);
                        var length = stackA.length;
                        while (length--) {
                            if (stackA[length] == value) {
                                return stackB[length];
                            }
                        }
                        stackA.push(value);
                        stackB.push(result);
                        (isArr ? arrayEach : baseForOwn)(value, function(subValue, key) {
                            result[key] = baseClone(subValue, isDeep, customizer, key, value, stackA, stackB);
                        });
                        return result;
                    }
                    var baseCreate = function() {
                        function Object() {}
                        return function(prototype) {
                            if (isObject(prototype)) {
                                Object.prototype = prototype;
                                var result = new Object();
                                Object.prototype = null;
                            }
                            return result || context.Object();
                        };
                    }();
                    function baseDelay(func, wait, args) {
                        if (typeof func != "function") {
                            throw new TypeError(FUNC_ERROR_TEXT);
                        }
                        return setTimeout(function() {
                            func.apply(undefined, args);
                        }, wait);
                    }
                    function baseDifference(array, values) {
                        var length = array ? array.length : 0, result = [];
                        if (!length) {
                            return result;
                        }
                        var index = -1, indexOf = getIndexOf(), isCommon = indexOf == baseIndexOf, cache = isCommon && values.length >= 200 ? createCache(values) : null, valuesLength = values.length;
                        if (cache) {
                            indexOf = cacheIndexOf;
                            isCommon = false;
                            values = cache;
                        }
                        outer: while (++index < length) {
                            var value = array[index];
                            if (isCommon && value === value) {
                                var valuesIndex = valuesLength;
                                while (valuesIndex--) {
                                    if (values[valuesIndex] === value) {
                                        continue outer;
                                    }
                                }
                                result.push(value);
                            } else if (indexOf(values, value, 0) < 0) {
                                result.push(value);
                            }
                        }
                        return result;
                    }
                    var baseEach = createBaseEach(baseForOwn);
                    var baseEachRight = createBaseEach(baseForOwnRight, true);
                    function baseEvery(collection, predicate) {
                        var result = true;
                        baseEach(collection, function(value, index, collection) {
                            result = !!predicate(value, index, collection);
                            return result;
                        });
                        return result;
                    }
                    function baseFill(array, value, start, end) {
                        var length = array.length;
                        start = start == null ? 0 : +start || 0;
                        if (start < 0) {
                            start = -start > length ? 0 : length + start;
                        }
                        end = typeof end == "undefined" || end > length ? length : +end || 0;
                        if (end < 0) {
                            end += length;
                        }
                        length = start > end ? 0 : end >>> 0;
                        start >>>= 0;
                        while (start < length) {
                            array[start++] = value;
                        }
                        return array;
                    }
                    function baseFilter(collection, predicate) {
                        var result = [];
                        baseEach(collection, function(value, index, collection) {
                            if (predicate(value, index, collection)) {
                                result.push(value);
                            }
                        });
                        return result;
                    }
                    function baseFind(collection, predicate, eachFunc, retKey) {
                        var result;
                        eachFunc(collection, function(value, key, collection) {
                            if (predicate(value, key, collection)) {
                                result = retKey ? key : value;
                                return false;
                            }
                        });
                        return result;
                    }
                    function baseFlatten(array, isDeep, isStrict) {
                        var index = -1, length = array.length, resIndex = -1, result = [];
                        while (++index < length) {
                            var value = array[index];
                            if (isObjectLike(value) && isLength(value.length) && (isArray(value) || isArguments(value))) {
                                if (isDeep) {
                                    value = baseFlatten(value, isDeep, isStrict);
                                }
                                var valIndex = -1, valLength = value.length;
                                result.length += valLength;
                                while (++valIndex < valLength) {
                                    result[++resIndex] = value[valIndex];
                                }
                            } else if (!isStrict) {
                                result[++resIndex] = value;
                            }
                        }
                        return result;
                    }
                    var baseFor = createBaseFor();
                    var baseForRight = createBaseFor(true);
                    function baseForIn(object, iteratee) {
                        return baseFor(object, iteratee, keysIn);
                    }
                    function baseForOwn(object, iteratee) {
                        return baseFor(object, iteratee, keys);
                    }
                    function baseForOwnRight(object, iteratee) {
                        return baseForRight(object, iteratee, keys);
                    }
                    function baseFunctions(object, props) {
                        var index = -1, length = props.length, resIndex = -1, result = [];
                        while (++index < length) {
                            var key = props[index];
                            if (isFunction(object[key])) {
                                result[++resIndex] = key;
                            }
                        }
                        return result;
                    }
                    function baseIsEqual(value, other, customizer, isLoose, stackA, stackB) {
                        if (value === other) {
                            return value !== 0 || 1 / value == 1 / other;
                        }
                        var valType = typeof value, othType = typeof other;
                        if (valType != "function" && valType != "object" && othType != "function" && othType != "object" || value == null || other == null) {
                            return value !== value && other !== other;
                        }
                        return baseIsEqualDeep(value, other, baseIsEqual, customizer, isLoose, stackA, stackB);
                    }
                    function baseIsEqualDeep(object, other, equalFunc, customizer, isLoose, stackA, stackB) {
                        var objIsArr = isArray(object), othIsArr = isArray(other), objTag = arrayTag, othTag = arrayTag;
                        if (!objIsArr) {
                            objTag = objToString.call(object);
                            if (objTag == argsTag) {
                                objTag = objectTag;
                            } else if (objTag != objectTag) {
                                objIsArr = isTypedArray(object);
                            }
                        }
                        if (!othIsArr) {
                            othTag = objToString.call(other);
                            if (othTag == argsTag) {
                                othTag = objectTag;
                            } else if (othTag != objectTag) {
                                othIsArr = isTypedArray(other);
                            }
                        }
                        var objIsObj = objTag == objectTag || isLoose && objTag == funcTag, othIsObj = othTag == objectTag || isLoose && othTag == funcTag, isSameTag = objTag == othTag;
                        if (isSameTag && !(objIsArr || objIsObj)) {
                            return equalByTag(object, other, objTag);
                        }
                        if (isLoose) {
                            if (!isSameTag && !(objIsObj && othIsObj)) {
                                return false;
                            }
                        } else {
                            var valWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
                            if (valWrapped || othWrapped) {
                                return equalFunc(valWrapped ? object.value() : object, othWrapped ? other.value() : other, customizer, isLoose, stackA, stackB);
                            }
                            if (!isSameTag) {
                                return false;
                            }
                        }
                        stackA || (stackA = []);
                        stackB || (stackB = []);
                        var length = stackA.length;
                        while (length--) {
                            if (stackA[length] == object) {
                                return stackB[length] == other;
                            }
                        }
                        stackA.push(object);
                        stackB.push(other);
                        var result = (objIsArr ? equalArrays : equalObjects)(object, other, equalFunc, customizer, isLoose, stackA, stackB);
                        stackA.pop();
                        stackB.pop();
                        return result;
                    }
                    function baseIsMatch(object, props, values, strictCompareFlags, customizer) {
                        var index = -1, length = props.length, noCustomizer = !customizer;
                        while (++index < length) {
                            if (noCustomizer && strictCompareFlags[index] ? values[index] !== object[props[index]] : !(props[index] in object)) {
                                return false;
                            }
                        }
                        index = -1;
                        while (++index < length) {
                            var key = props[index], objValue = object[key], srcValue = values[index];
                            if (noCustomizer && strictCompareFlags[index]) {
                                var result = typeof objValue != "undefined" || key in object;
                            } else {
                                result = customizer ? customizer(objValue, srcValue, key) : undefined;
                                if (typeof result == "undefined") {
                                    result = baseIsEqual(srcValue, objValue, customizer, true);
                                }
                            }
                            if (!result) {
                                return false;
                            }
                        }
                        return true;
                    }
                    function baseMap(collection, iteratee) {
                        var result = [];
                        baseEach(collection, function(value, key, collection) {
                            result.push(iteratee(value, key, collection));
                        });
                        return result;
                    }
                    function baseMatches(source) {
                        var props = keys(source), length = props.length;
                        if (!length) {
                            return constant(true);
                        }
                        if (length == 1) {
                            var key = props[0], value = source[key];
                            if (isStrictComparable(value)) {
                                return function(object) {
                                    return object != null && object[key] === value && (typeof value != "undefined" || key in toObject(object));
                                };
                            }
                        }
                        var values = Array(length), strictCompareFlags = Array(length);
                        while (length--) {
                            value = source[props[length]];
                            values[length] = value;
                            strictCompareFlags[length] = isStrictComparable(value);
                        }
                        return function(object) {
                            return object != null && baseIsMatch(toObject(object), props, values, strictCompareFlags);
                        };
                    }
                    function baseMatchesProperty(key, value) {
                        if (isStrictComparable(value)) {
                            return function(object) {
                                return object != null && object[key] === value && (typeof value != "undefined" || key in toObject(object));
                            };
                        }
                        return function(object) {
                            return object != null && baseIsEqual(value, object[key], null, true);
                        };
                    }
                    function baseMerge(object, source, customizer, stackA, stackB) {
                        if (!isObject(object)) {
                            return object;
                        }
                        var isSrcArr = isLength(source.length) && (isArray(source) || isTypedArray(source));
                        (isSrcArr ? arrayEach : baseForOwn)(source, function(srcValue, key, source) {
                            if (isObjectLike(srcValue)) {
                                stackA || (stackA = []);
                                stackB || (stackB = []);
                                return baseMergeDeep(object, source, key, baseMerge, customizer, stackA, stackB);
                            }
                            var value = object[key], result = customizer ? customizer(value, srcValue, key, object, source) : undefined, isCommon = typeof result == "undefined";
                            if (isCommon) {
                                result = srcValue;
                            }
                            if ((isSrcArr || typeof result != "undefined") && (isCommon || (result === result ? result !== value : value === value))) {
                                object[key] = result;
                            }
                        });
                        return object;
                    }
                    function baseMergeDeep(object, source, key, mergeFunc, customizer, stackA, stackB) {
                        var length = stackA.length, srcValue = source[key];
                        while (length--) {
                            if (stackA[length] == srcValue) {
                                object[key] = stackB[length];
                                return;
                            }
                        }
                        var value = object[key], result = customizer ? customizer(value, srcValue, key, object, source) : undefined, isCommon = typeof result == "undefined";
                        if (isCommon) {
                            result = srcValue;
                            if (isLength(srcValue.length) && (isArray(srcValue) || isTypedArray(srcValue))) {
                                result = isArray(value) ? value : value && value.length ? arrayCopy(value) : [];
                            } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
                                result = isArguments(value) ? toPlainObject(value) : isPlainObject(value) ? value : {};
                            } else {
                                isCommon = false;
                            }
                        }
                        stackA.push(srcValue);
                        stackB.push(result);
                        if (isCommon) {
                            object[key] = mergeFunc(result, srcValue, customizer, stackA, stackB);
                        } else if (result === result ? result !== value : value === value) {
                            object[key] = result;
                        }
                    }
                    function baseProperty(key) {
                        return function(object) {
                            return object == null ? undefined : object[key];
                        };
                    }
                    function baseRandom(min, max) {
                        return min + floor(nativeRandom() * (max - min + 1));
                    }
                    function baseReduce(collection, iteratee, accumulator, initFromCollection, eachFunc) {
                        eachFunc(collection, function(value, index, collection) {
                            accumulator = initFromCollection ? (initFromCollection = false, value) : iteratee(accumulator, value, index, collection);
                        });
                        return accumulator;
                    }
                    var baseSetData = !metaMap ? identity : function(func, data) {
                        metaMap.set(func, data);
                        return func;
                    };
                    function baseSlice(array, start, end) {
                        var index = -1, length = array.length;
                        start = start == null ? 0 : +start || 0;
                        if (start < 0) {
                            start = -start > length ? 0 : length + start;
                        }
                        end = typeof end == "undefined" || end > length ? length : +end || 0;
                        if (end < 0) {
                            end += length;
                        }
                        length = start > end ? 0 : end - start >>> 0;
                        start >>>= 0;
                        var result = Array(length);
                        while (++index < length) {
                            result[index] = array[index + start];
                        }
                        return result;
                    }
                    function baseSome(collection, predicate) {
                        var result;
                        baseEach(collection, function(value, index, collection) {
                            result = predicate(value, index, collection);
                            return !result;
                        });
                        return !!result;
                    }
                    function baseSortBy(array, comparer) {
                        var length = array.length;
                        array.sort(comparer);
                        while (length--) {
                            array[length] = array[length].value;
                        }
                        return array;
                    }
                    function baseSortByOrder(collection, props, orders) {
                        var index = -1, length = collection.length, result = isLength(length) ? Array(length) : [];
                        baseEach(collection, function(value) {
                            var length = props.length, criteria = Array(length);
                            while (length--) {
                                criteria[length] = value == null ? undefined : value[props[length]];
                            }
                            result[++index] = {
                                criteria: criteria,
                                index: index,
                                value: value
                            };
                        });
                        return baseSortBy(result, function(object, other) {
                            return compareMultiple(object, other, orders);
                        });
                    }
                    function baseSum(collection, iteratee) {
                        var result = 0;
                        baseEach(collection, function(value, index, collection) {
                            result += +iteratee(value, index, collection) || 0;
                        });
                        return result;
                    }
                    function baseUniq(array, iteratee) {
                        var index = -1, indexOf = getIndexOf(), length = array.length, isCommon = indexOf == baseIndexOf, isLarge = isCommon && length >= 200, seen = isLarge ? createCache() : null, result = [];
                        if (seen) {
                            indexOf = cacheIndexOf;
                            isCommon = false;
                        } else {
                            isLarge = false;
                            seen = iteratee ? [] : result;
                        }
                        outer: while (++index < length) {
                            var value = array[index], computed = iteratee ? iteratee(value, index, array) : value;
                            if (isCommon && value === value) {
                                var seenIndex = seen.length;
                                while (seenIndex--) {
                                    if (seen[seenIndex] === computed) {
                                        continue outer;
                                    }
                                }
                                if (iteratee) {
                                    seen.push(computed);
                                }
                                result.push(value);
                            } else if (indexOf(seen, computed, 0) < 0) {
                                if (iteratee || isLarge) {
                                    seen.push(computed);
                                }
                                result.push(value);
                            }
                        }
                        return result;
                    }
                    function baseValues(object, props) {
                        var index = -1, length = props.length, result = Array(length);
                        while (++index < length) {
                            result[index] = object[props[index]];
                        }
                        return result;
                    }
                    function baseWhile(array, predicate, isDrop, fromRight) {
                        var length = array.length, index = fromRight ? length : -1;
                        while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {}
                        return isDrop ? baseSlice(array, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array, fromRight ? index + 1 : 0, fromRight ? length : index);
                    }
                    function baseWrapperValue(value, actions) {
                        var result = value;
                        if (result instanceof LazyWrapper) {
                            result = result.value();
                        }
                        var index = -1, length = actions.length;
                        while (++index < length) {
                            var args = [ result ], action = actions[index];
                            push.apply(args, action.args);
                            result = action.func.apply(action.thisArg, args);
                        }
                        return result;
                    }
                    function binaryIndex(array, value, retHighest) {
                        var low = 0, high = array ? array.length : low;
                        if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
                            while (low < high) {
                                var mid = low + high >>> 1, computed = array[mid];
                                if (retHighest ? computed <= value : computed < value) {
                                    low = mid + 1;
                                } else {
                                    high = mid;
                                }
                            }
                            return high;
                        }
                        return binaryIndexBy(array, value, identity, retHighest);
                    }
                    function binaryIndexBy(array, value, iteratee, retHighest) {
                        value = iteratee(value);
                        var low = 0, high = array ? array.length : 0, valIsNaN = value !== value, valIsUndef = typeof value == "undefined";
                        while (low < high) {
                            var mid = floor((low + high) / 2), computed = iteratee(array[mid]), isReflexive = computed === computed;
                            if (valIsNaN) {
                                var setLow = isReflexive || retHighest;
                            } else if (valIsUndef) {
                                setLow = isReflexive && (retHighest || typeof computed != "undefined");
                            } else {
                                setLow = retHighest ? computed <= value : computed < value;
                            }
                            if (setLow) {
                                low = mid + 1;
                            } else {
                                high = mid;
                            }
                        }
                        return nativeMin(high, MAX_ARRAY_INDEX);
                    }
                    function bindCallback(func, thisArg, argCount) {
                        if (typeof func != "function") {
                            return identity;
                        }
                        if (typeof thisArg == "undefined") {
                            return func;
                        }
                        switch (argCount) {
                          case 1:
                            return function(value) {
                                return func.call(thisArg, value);
                            };

                          case 3:
                            return function(value, index, collection) {
                                return func.call(thisArg, value, index, collection);
                            };

                          case 4:
                            return function(accumulator, value, index, collection) {
                                return func.call(thisArg, accumulator, value, index, collection);
                            };

                          case 5:
                            return function(value, other, key, object, source) {
                                return func.call(thisArg, value, other, key, object, source);
                            };
                        }
                        return function() {
                            return func.apply(thisArg, arguments);
                        };
                    }
                    function bufferClone(buffer) {
                        return bufferSlice.call(buffer, 0);
                    }
                    if (!bufferSlice) {
                        bufferClone = !(ArrayBuffer && Uint8Array) ? constant(null) : function(buffer) {
                            var byteLength = buffer.byteLength, floatLength = Float64Array ? floor(byteLength / FLOAT64_BYTES_PER_ELEMENT) : 0, offset = floatLength * FLOAT64_BYTES_PER_ELEMENT, result = new ArrayBuffer(byteLength);
                            if (floatLength) {
                                var view = new Float64Array(result, 0, floatLength);
                                view.set(new Float64Array(buffer, 0, floatLength));
                            }
                            if (byteLength != offset) {
                                view = new Uint8Array(result, offset);
                                view.set(new Uint8Array(buffer, offset));
                            }
                            return result;
                        };
                    }
                    function composeArgs(args, partials, holders) {
                        var holdersLength = holders.length, argsIndex = -1, argsLength = nativeMax(args.length - holdersLength, 0), leftIndex = -1, leftLength = partials.length, result = Array(argsLength + leftLength);
                        while (++leftIndex < leftLength) {
                            result[leftIndex] = partials[leftIndex];
                        }
                        while (++argsIndex < holdersLength) {
                            result[holders[argsIndex]] = args[argsIndex];
                        }
                        while (argsLength--) {
                            result[leftIndex++] = args[argsIndex++];
                        }
                        return result;
                    }
                    function composeArgsRight(args, partials, holders) {
                        var holdersIndex = -1, holdersLength = holders.length, argsIndex = -1, argsLength = nativeMax(args.length - holdersLength, 0), rightIndex = -1, rightLength = partials.length, result = Array(argsLength + rightLength);
                        while (++argsIndex < argsLength) {
                            result[argsIndex] = args[argsIndex];
                        }
                        var pad = argsIndex;
                        while (++rightIndex < rightLength) {
                            result[pad + rightIndex] = partials[rightIndex];
                        }
                        while (++holdersIndex < holdersLength) {
                            result[pad + holders[holdersIndex]] = args[argsIndex++];
                        }
                        return result;
                    }
                    function createAggregator(setter, initializer) {
                        return function(collection, iteratee, thisArg) {
                            var result = initializer ? initializer() : {};
                            iteratee = getCallback(iteratee, thisArg, 3);
                            if (isArray(collection)) {
                                var index = -1, length = collection.length;
                                while (++index < length) {
                                    var value = collection[index];
                                    setter(result, value, iteratee(value, index, collection), collection);
                                }
                            } else {
                                baseEach(collection, function(value, key, collection) {
                                    setter(result, value, iteratee(value, key, collection), collection);
                                });
                            }
                            return result;
                        };
                    }
                    function createAssigner(assigner) {
                        return function() {
                            var args = arguments, length = args.length, object = args[0];
                            if (length < 2 || object == null) {
                                return object;
                            }
                            var customizer = args[length - 2], thisArg = args[length - 1], guard = args[3];
                            if (length > 3 && typeof customizer == "function") {
                                customizer = bindCallback(customizer, thisArg, 5);
                                length -= 2;
                            } else {
                                customizer = length > 2 && typeof thisArg == "function" ? thisArg : null;
                                length -= customizer ? 1 : 0;
                            }
                            if (guard && isIterateeCall(args[1], args[2], guard)) {
                                customizer = length == 3 ? null : customizer;
                                length = 2;
                            }
                            var index = 0;
                            while (++index < length) {
                                var source = args[index];
                                if (source) {
                                    assigner(object, source, customizer);
                                }
                            }
                            return object;
                        };
                    }
                    function createBaseEach(eachFunc, fromRight) {
                        return function(collection, iteratee) {
                            var length = collection ? collection.length : 0;
                            if (!isLength(length)) {
                                return eachFunc(collection, iteratee);
                            }
                            var index = fromRight ? length : -1, iterable = toObject(collection);
                            while (fromRight ? index-- : ++index < length) {
                                if (iteratee(iterable[index], index, iterable) === false) {
                                    break;
                                }
                            }
                            return collection;
                        };
                    }
                    function createBaseFor(fromRight) {
                        return function(object, iteratee, keysFunc) {
                            var iterable = toObject(object), props = keysFunc(object), length = props.length, index = fromRight ? length : -1;
                            while (fromRight ? index-- : ++index < length) {
                                var key = props[index];
                                if (iteratee(iterable[key], key, iterable) === false) {
                                    break;
                                }
                            }
                            return object;
                        };
                    }
                    function createBindWrapper(func, thisArg) {
                        var Ctor = createCtorWrapper(func);
                        function wrapper() {
                            var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
                            return fn.apply(thisArg, arguments);
                        }
                        return wrapper;
                    }
                    var createCache = !(nativeCreate && Set) ? constant(null) : function(values) {
                        return new SetCache(values);
                    };
                    function createCompounder(callback) {
                        return function(string) {
                            var index = -1, array = words(deburr(string)), length = array.length, result = "";
                            while (++index < length) {
                                result = callback(result, array[index], index);
                            }
                            return result;
                        };
                    }
                    function createCtorWrapper(Ctor) {
                        return function() {
                            var thisBinding = baseCreate(Ctor.prototype), result = Ctor.apply(thisBinding, arguments);
                            return isObject(result) ? result : thisBinding;
                        };
                    }
                    function createCurry(flag) {
                        function curryFunc(func, arity, guard) {
                            if (guard && isIterateeCall(func, arity, guard)) {
                                arity = null;
                            }
                            var result = createWrapper(func, flag, null, null, null, null, null, arity);
                            result.placeholder = curryFunc.placeholder;
                            return result;
                        }
                        return curryFunc;
                    }
                    function createExtremum(arrayFunc, isMin) {
                        return function(collection, iteratee, thisArg) {
                            if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
                                iteratee = null;
                            }
                            var func = getCallback(), noIteratee = iteratee == null;
                            if (!(func === baseCallback && noIteratee)) {
                                noIteratee = false;
                                iteratee = func(iteratee, thisArg, 3);
                            }
                            if (noIteratee) {
                                var isArr = isArray(collection);
                                if (!isArr && isString(collection)) {
                                    iteratee = charAtCallback;
                                } else {
                                    return arrayFunc(isArr ? collection : toIterable(collection));
                                }
                            }
                            return extremumBy(collection, iteratee, isMin);
                        };
                    }
                    function createFind(eachFunc, fromRight) {
                        return function(collection, predicate, thisArg) {
                            predicate = getCallback(predicate, thisArg, 3);
                            if (isArray(collection)) {
                                var index = baseFindIndex(collection, predicate, fromRight);
                                return index > -1 ? collection[index] : undefined;
                            }
                            return baseFind(collection, predicate, eachFunc);
                        };
                    }
                    function createFindIndex(fromRight) {
                        return function(array, predicate, thisArg) {
                            if (!(array && array.length)) {
                                return -1;
                            }
                            predicate = getCallback(predicate, thisArg, 3);
                            return baseFindIndex(array, predicate, fromRight);
                        };
                    }
                    function createFindKey(objectFunc) {
                        return function(object, predicate, thisArg) {
                            predicate = getCallback(predicate, thisArg, 3);
                            return baseFind(object, predicate, objectFunc, true);
                        };
                    }
                    function createFlow(fromRight) {
                        return function() {
                            var length = arguments.length;
                            if (!length) {
                                return function() {
                                    return arguments[0];
                                };
                            }
                            var wrapper, index = fromRight ? length : -1, leftIndex = 0, funcs = Array(length);
                            while (fromRight ? index-- : ++index < length) {
                                var func = funcs[leftIndex++] = arguments[index];
                                if (typeof func != "function") {
                                    throw new TypeError(FUNC_ERROR_TEXT);
                                }
                                var funcName = wrapper ? "" : getFuncName(func);
                                wrapper = funcName == "wrapper" ? new LodashWrapper([]) : wrapper;
                            }
                            index = wrapper ? -1 : length;
                            while (++index < length) {
                                func = funcs[index];
                                funcName = getFuncName(func);
                                var data = funcName == "wrapper" ? getData(func) : null;
                                if (data && isLaziable(data[0])) {
                                    wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
                                } else {
                                    wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
                                }
                            }
                            return function() {
                                var args = arguments;
                                if (wrapper && args.length == 1 && isArray(args[0])) {
                                    return wrapper.plant(args[0]).value();
                                }
                                var index = 0, result = funcs[index].apply(this, args);
                                while (++index < length) {
                                    result = funcs[index].call(this, result);
                                }
                                return result;
                            };
                        };
                    }
                    function createForEach(arrayFunc, eachFunc) {
                        return function(collection, iteratee, thisArg) {
                            return typeof iteratee == "function" && typeof thisArg == "undefined" && isArray(collection) ? arrayFunc(collection, iteratee) : eachFunc(collection, bindCallback(iteratee, thisArg, 3));
                        };
                    }
                    function createForIn(objectFunc) {
                        return function(object, iteratee, thisArg) {
                            if (typeof iteratee != "function" || typeof thisArg != "undefined") {
                                iteratee = bindCallback(iteratee, thisArg, 3);
                            }
                            return objectFunc(object, iteratee, keysIn);
                        };
                    }
                    function createForOwn(objectFunc) {
                        return function(object, iteratee, thisArg) {
                            if (typeof iteratee != "function" || typeof thisArg != "undefined") {
                                iteratee = bindCallback(iteratee, thisArg, 3);
                            }
                            return objectFunc(object, iteratee);
                        };
                    }
                    function createPadDir(fromRight) {
                        return function(string, length, chars) {
                            string = baseToString(string);
                            return string && (fromRight ? string : "") + createPadding(string, length, chars) + (fromRight ? "" : string);
                        };
                    }
                    function createPartial(flag) {
                        var partialFunc = restParam(function(func, partials) {
                            var holders = replaceHolders(partials, partialFunc.placeholder);
                            return createWrapper(func, flag, null, partials, holders);
                        });
                        return partialFunc;
                    }
                    function createReduce(arrayFunc, eachFunc) {
                        return function(collection, iteratee, accumulator, thisArg) {
                            var initFromArray = arguments.length < 3;
                            return typeof iteratee == "function" && typeof thisArg == "undefined" && isArray(collection) ? arrayFunc(collection, iteratee, accumulator, initFromArray) : baseReduce(collection, getCallback(iteratee, thisArg, 4), accumulator, initFromArray, eachFunc);
                        };
                    }
                    function createHybridWrapper(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
                        var isAry = bitmask & ARY_FLAG, isBind = bitmask & BIND_FLAG, isBindKey = bitmask & BIND_KEY_FLAG, isCurry = bitmask & CURRY_FLAG, isCurryBound = bitmask & CURRY_BOUND_FLAG, isCurryRight = bitmask & CURRY_RIGHT_FLAG;
                        var Ctor = !isBindKey && createCtorWrapper(func), key = func;
                        function wrapper() {
                            var length = arguments.length, index = length, args = Array(length);
                            while (index--) {
                                args[index] = arguments[index];
                            }
                            if (partials) {
                                args = composeArgs(args, partials, holders);
                            }
                            if (partialsRight) {
                                args = composeArgsRight(args, partialsRight, holdersRight);
                            }
                            if (isCurry || isCurryRight) {
                                var placeholder = wrapper.placeholder, argsHolders = replaceHolders(args, placeholder);
                                length -= argsHolders.length;
                                if (length < arity) {
                                    var newArgPos = argPos ? arrayCopy(argPos) : null, newArity = nativeMax(arity - length, 0), newsHolders = isCurry ? argsHolders : null, newHoldersRight = isCurry ? null : argsHolders, newPartials = isCurry ? args : null, newPartialsRight = isCurry ? null : args;
                                    bitmask |= isCurry ? PARTIAL_FLAG : PARTIAL_RIGHT_FLAG;
                                    bitmask &= ~(isCurry ? PARTIAL_RIGHT_FLAG : PARTIAL_FLAG);
                                    if (!isCurryBound) {
                                        bitmask &= ~(BIND_FLAG | BIND_KEY_FLAG);
                                    }
                                    var newData = [ func, bitmask, thisArg, newPartials, newsHolders, newPartialsRight, newHoldersRight, newArgPos, ary, newArity ], result = createHybridWrapper.apply(undefined, newData);
                                    if (isLaziable(func)) {
                                        setData(result, newData);
                                    }
                                    result.placeholder = placeholder;
                                    return result;
                                }
                            }
                            var thisBinding = isBind ? thisArg : this;
                            if (isBindKey) {
                                func = thisBinding[key];
                            }
                            if (argPos) {
                                args = reorder(args, argPos);
                            }
                            if (isAry && ary < args.length) {
                                args.length = ary;
                            }
                            var fn = this && this !== root && this instanceof wrapper ? Ctor || createCtorWrapper(func) : func;
                            return fn.apply(thisBinding, args);
                        }
                        return wrapper;
                    }
                    function createPadding(string, length, chars) {
                        var strLength = string.length;
                        length = +length;
                        if (strLength >= length || !nativeIsFinite(length)) {
                            return "";
                        }
                        var padLength = length - strLength;
                        chars = chars == null ? " " : chars + "";
                        return repeat(chars, ceil(padLength / chars.length)).slice(0, padLength);
                    }
                    function createPartialWrapper(func, bitmask, thisArg, partials) {
                        var isBind = bitmask & BIND_FLAG, Ctor = createCtorWrapper(func);
                        function wrapper() {
                            var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array(argsLength + leftLength);
                            while (++leftIndex < leftLength) {
                                args[leftIndex] = partials[leftIndex];
                            }
                            while (argsLength--) {
                                args[leftIndex++] = arguments[++argsIndex];
                            }
                            var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
                            return fn.apply(isBind ? thisArg : this, args);
                        }
                        return wrapper;
                    }
                    function createSortedIndex(retHighest) {
                        return function(array, value, iteratee, thisArg) {
                            var func = getCallback(iteratee);
                            return func === baseCallback && iteratee == null ? binaryIndex(array, value, retHighest) : binaryIndexBy(array, value, func(iteratee, thisArg, 1), retHighest);
                        };
                    }
                    function createWrapper(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
                        var isBindKey = bitmask & BIND_KEY_FLAG;
                        if (!isBindKey && typeof func != "function") {
                            throw new TypeError(FUNC_ERROR_TEXT);
                        }
                        var length = partials ? partials.length : 0;
                        if (!length) {
                            bitmask &= ~(PARTIAL_FLAG | PARTIAL_RIGHT_FLAG);
                            partials = holders = null;
                        }
                        length -= holders ? holders.length : 0;
                        if (bitmask & PARTIAL_RIGHT_FLAG) {
                            var partialsRight = partials, holdersRight = holders;
                            partials = holders = null;
                        }
                        var data = isBindKey ? null : getData(func), newData = [ func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity ];
                        if (data) {
                            mergeData(newData, data);
                            bitmask = newData[1];
                            arity = newData[9];
                        }
                        newData[9] = arity == null ? isBindKey ? 0 : func.length : nativeMax(arity - length, 0) || 0;
                        if (bitmask == BIND_FLAG) {
                            var result = createBindWrapper(newData[0], newData[2]);
                        } else if ((bitmask == PARTIAL_FLAG || bitmask == (BIND_FLAG | PARTIAL_FLAG)) && !newData[4].length) {
                            result = createPartialWrapper.apply(undefined, newData);
                        } else {
                            result = createHybridWrapper.apply(undefined, newData);
                        }
                        var setter = data ? baseSetData : setData;
                        return setter(result, newData);
                    }
                    function equalArrays(array, other, equalFunc, customizer, isLoose, stackA, stackB) {
                        var index = -1, arrLength = array.length, othLength = other.length, result = true;
                        if (arrLength != othLength && !(isLoose && othLength > arrLength)) {
                            return false;
                        }
                        while (result && ++index < arrLength) {
                            var arrValue = array[index], othValue = other[index];
                            result = undefined;
                            if (customizer) {
                                result = isLoose ? customizer(othValue, arrValue, index) : customizer(arrValue, othValue, index);
                            }
                            if (typeof result == "undefined") {
                                if (isLoose) {
                                    var othIndex = othLength;
                                    while (othIndex--) {
                                        othValue = other[othIndex];
                                        result = arrValue && arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB);
                                        if (result) {
                                            break;
                                        }
                                    }
                                } else {
                                    result = arrValue && arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB);
                                }
                            }
                        }
                        return !!result;
                    }
                    function equalByTag(object, other, tag) {
                        switch (tag) {
                          case boolTag:
                          case dateTag:
                            return +object == +other;

                          case errorTag:
                            return object.name == other.name && object.message == other.message;

                          case numberTag:
                            return object != +object ? other != +other : object == 0 ? 1 / object == 1 / other : object == +other;

                          case regexpTag:
                          case stringTag:
                            return object == other + "";
                        }
                        return false;
                    }
                    function equalObjects(object, other, equalFunc, customizer, isLoose, stackA, stackB) {
                        var objProps = keys(object), objLength = objProps.length, othProps = keys(other), othLength = othProps.length;
                        if (objLength != othLength && !isLoose) {
                            return false;
                        }
                        var skipCtor = isLoose, index = -1;
                        while (++index < objLength) {
                            var key = objProps[index], result = isLoose ? key in other : hasOwnProperty.call(other, key);
                            if (result) {
                                var objValue = object[key], othValue = other[key];
                                result = undefined;
                                if (customizer) {
                                    result = isLoose ? customizer(othValue, objValue, key) : customizer(objValue, othValue, key);
                                }
                                if (typeof result == "undefined") {
                                    result = objValue && objValue === othValue || equalFunc(objValue, othValue, customizer, isLoose, stackA, stackB);
                                }
                            }
                            if (!result) {
                                return false;
                            }
                            skipCtor || (skipCtor = key == "constructor");
                        }
                        if (!skipCtor) {
                            var objCtor = object.constructor, othCtor = other.constructor;
                            if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
                                return false;
                            }
                        }
                        return true;
                    }
                    function extremumBy(collection, iteratee, isMin) {
                        var exValue = isMin ? POSITIVE_INFINITY : NEGATIVE_INFINITY, computed = exValue, result = computed;
                        baseEach(collection, function(value, index, collection) {
                            var current = iteratee(value, index, collection);
                            if ((isMin ? current < computed : current > computed) || current === exValue && current === result) {
                                computed = current;
                                result = value;
                            }
                        });
                        return result;
                    }
                    function getCallback(func, thisArg, argCount) {
                        var result = lodash.callback || callback;
                        result = result === callback ? baseCallback : result;
                        return argCount ? result(func, thisArg, argCount) : result;
                    }
                    var getData = !metaMap ? noop : function(func) {
                        return metaMap.get(func);
                    };
                    var getFuncName = function() {
                        if (!support.funcNames) {
                            return constant("");
                        }
                        if (constant.name == "constant") {
                            return baseProperty("name");
                        }
                        return function(func) {
                            var result = func.name, array = realNames[result], length = array ? array.length : 0;
                            while (length--) {
                                var data = array[length], otherFunc = data.func;
                                if (otherFunc == null || otherFunc == func) {
                                    return data.name;
                                }
                            }
                            return result;
                        };
                    }();
                    function getIndexOf(collection, target, fromIndex) {
                        var result = lodash.indexOf || indexOf;
                        result = result === indexOf ? baseIndexOf : result;
                        return collection ? result(collection, target, fromIndex) : result;
                    }
                    function getView(start, end, transforms) {
                        var index = -1, length = transforms ? transforms.length : 0;
                        while (++index < length) {
                            var data = transforms[index], size = data.size;
                            switch (data.type) {
                              case "drop":
                                start += size;
                                break;

                              case "dropRight":
                                end -= size;
                                break;

                              case "take":
                                end = nativeMin(end, start + size);
                                break;

                              case "takeRight":
                                start = nativeMax(start, end - size);
                                break;
                            }
                        }
                        return {
                            start: start,
                            end: end
                        };
                    }
                    function initCloneArray(array) {
                        var length = array.length, result = new array.constructor(length);
                        if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
                            result.index = array.index;
                            result.input = array.input;
                        }
                        return result;
                    }
                    function initCloneObject(object) {
                        var Ctor = object.constructor;
                        if (!(typeof Ctor == "function" && Ctor instanceof Ctor)) {
                            Ctor = Object;
                        }
                        return new Ctor();
                    }
                    function initCloneByTag(object, tag, isDeep) {
                        var Ctor = object.constructor;
                        switch (tag) {
                          case arrayBufferTag:
                            return bufferClone(object);

                          case boolTag:
                          case dateTag:
                            return new Ctor(+object);

                          case float32Tag:
                          case float64Tag:
                          case int8Tag:
                          case int16Tag:
                          case int32Tag:
                          case uint8Tag:
                          case uint8ClampedTag:
                          case uint16Tag:
                          case uint32Tag:
                            var buffer = object.buffer;
                            return new Ctor(isDeep ? bufferClone(buffer) : buffer, object.byteOffset, object.length);

                          case numberTag:
                          case stringTag:
                            return new Ctor(object);

                          case regexpTag:
                            var result = new Ctor(object.source, reFlags.exec(object));
                            result.lastIndex = object.lastIndex;
                        }
                        return result;
                    }
                    function isIndex(value, length) {
                        value = +value;
                        length = length == null ? MAX_SAFE_INTEGER : length;
                        return value > -1 && value % 1 == 0 && value < length;
                    }
                    function isIterateeCall(value, index, object) {
                        if (!isObject(object)) {
                            return false;
                        }
                        var type = typeof index;
                        if (type == "number") {
                            var length = object.length, prereq = isLength(length) && isIndex(index, length);
                        } else {
                            prereq = type == "string" && index in object;
                        }
                        if (prereq) {
                            var other = object[index];
                            return value === value ? value === other : other !== other;
                        }
                        return false;
                    }
                    function isLaziable(func) {
                        var funcName = getFuncName(func);
                        return !!funcName && func === lodash[funcName] && funcName in LazyWrapper.prototype;
                    }
                    function isLength(value) {
                        return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
                    }
                    function isStrictComparable(value) {
                        return value === value && (value === 0 ? 1 / value > 0 : !isObject(value));
                    }
                    function mergeData(data, source) {
                        var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < ARY_FLAG;
                        var isCombo = srcBitmask == ARY_FLAG && bitmask == CURRY_FLAG || srcBitmask == ARY_FLAG && bitmask == REARG_FLAG && data[7].length <= source[8] || srcBitmask == (ARY_FLAG | REARG_FLAG) && bitmask == CURRY_FLAG;
                        if (!(isCommon || isCombo)) {
                            return data;
                        }
                        if (srcBitmask & BIND_FLAG) {
                            data[2] = source[2];
                            newBitmask |= bitmask & BIND_FLAG ? 0 : CURRY_BOUND_FLAG;
                        }
                        var value = source[3];
                        if (value) {
                            var partials = data[3];
                            data[3] = partials ? composeArgs(partials, value, source[4]) : arrayCopy(value);
                            data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : arrayCopy(source[4]);
                        }
                        value = source[5];
                        if (value) {
                            partials = data[5];
                            data[5] = partials ? composeArgsRight(partials, value, source[6]) : arrayCopy(value);
                            data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : arrayCopy(source[6]);
                        }
                        value = source[7];
                        if (value) {
                            data[7] = arrayCopy(value);
                        }
                        if (srcBitmask & ARY_FLAG) {
                            data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
                        }
                        if (data[9] == null) {
                            data[9] = source[9];
                        }
                        data[0] = source[0];
                        data[1] = newBitmask;
                        return data;
                    }
                    function pickByArray(object, props) {
                        object = toObject(object);
                        var index = -1, length = props.length, result = {};
                        while (++index < length) {
                            var key = props[index];
                            if (key in object) {
                                result[key] = object[key];
                            }
                        }
                        return result;
                    }
                    function pickByCallback(object, predicate) {
                        var result = {};
                        baseForIn(object, function(value, key, object) {
                            if (predicate(value, key, object)) {
                                result[key] = value;
                            }
                        });
                        return result;
                    }
                    function reorder(array, indexes) {
                        var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = arrayCopy(array);
                        while (length--) {
                            var index = indexes[length];
                            array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
                        }
                        return array;
                    }
                    var setData = function() {
                        var count = 0, lastCalled = 0;
                        return function(key, value) {
                            var stamp = now(), remaining = HOT_SPAN - (stamp - lastCalled);
                            lastCalled = stamp;
                            if (remaining > 0) {
                                if (++count >= HOT_COUNT) {
                                    return key;
                                }
                            } else {
                                count = 0;
                            }
                            return baseSetData(key, value);
                        };
                    }();
                    function shimIsPlainObject(value) {
                        var Ctor, support = lodash.support;
                        if (!(isObjectLike(value) && objToString.call(value) == objectTag) || !hasOwnProperty.call(value, "constructor") && (Ctor = value.constructor, 
                        typeof Ctor == "function" && !(Ctor instanceof Ctor))) {
                            return false;
                        }
                        var result;
                        baseForIn(value, function(subValue, key) {
                            result = key;
                        });
                        return typeof result == "undefined" || hasOwnProperty.call(value, result);
                    }
                    function shimKeys(object) {
                        var props = keysIn(object), propsLength = props.length, length = propsLength && object.length, support = lodash.support;
                        var allowIndexes = length && isLength(length) && (isArray(object) || support.nonEnumArgs && isArguments(object));
                        var index = -1, result = [];
                        while (++index < propsLength) {
                            var key = props[index];
                            if (allowIndexes && isIndex(key, length) || hasOwnProperty.call(object, key)) {
                                result.push(key);
                            }
                        }
                        return result;
                    }
                    function toIterable(value) {
                        if (value == null) {
                            return [];
                        }
                        if (!isLength(value.length)) {
                            return values(value);
                        }
                        return isObject(value) ? value : Object(value);
                    }
                    function toObject(value) {
                        return isObject(value) ? value : Object(value);
                    }
                    function wrapperClone(wrapper) {
                        return wrapper instanceof LazyWrapper ? wrapper.clone() : new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__, arrayCopy(wrapper.__actions__));
                    }
                    function chunk(array, size, guard) {
                        if (guard ? isIterateeCall(array, size, guard) : size == null) {
                            size = 1;
                        } else {
                            size = nativeMax(+size || 1, 1);
                        }
                        var index = 0, length = array ? array.length : 0, resIndex = -1, result = Array(ceil(length / size));
                        while (index < length) {
                            result[++resIndex] = baseSlice(array, index, index += size);
                        }
                        return result;
                    }
                    function compact(array) {
                        var index = -1, length = array ? array.length : 0, resIndex = -1, result = [];
                        while (++index < length) {
                            var value = array[index];
                            if (value) {
                                result[++resIndex] = value;
                            }
                        }
                        return result;
                    }
                    var difference = restParam(function(array, values) {
                        return isArray(array) || isArguments(array) ? baseDifference(array, baseFlatten(values, false, true)) : [];
                    });
                    function drop(array, n, guard) {
                        var length = array ? array.length : 0;
                        if (!length) {
                            return [];
                        }
                        if (guard ? isIterateeCall(array, n, guard) : n == null) {
                            n = 1;
                        }
                        return baseSlice(array, n < 0 ? 0 : n);
                    }
                    function dropRight(array, n, guard) {
                        var length = array ? array.length : 0;
                        if (!length) {
                            return [];
                        }
                        if (guard ? isIterateeCall(array, n, guard) : n == null) {
                            n = 1;
                        }
                        n = length - (+n || 0);
                        return baseSlice(array, 0, n < 0 ? 0 : n);
                    }
                    function dropRightWhile(array, predicate, thisArg) {
                        return array && array.length ? baseWhile(array, getCallback(predicate, thisArg, 3), true, true) : [];
                    }
                    function dropWhile(array, predicate, thisArg) {
                        return array && array.length ? baseWhile(array, getCallback(predicate, thisArg, 3), true) : [];
                    }
                    function fill(array, value, start, end) {
                        var length = array ? array.length : 0;
                        if (!length) {
                            return [];
                        }
                        if (start && typeof start != "number" && isIterateeCall(array, value, start)) {
                            start = 0;
                            end = length;
                        }
                        return baseFill(array, value, start, end);
                    }
                    var findIndex = createFindIndex();
                    var findLastIndex = createFindIndex(true);
                    function first(array) {
                        return array ? array[0] : undefined;
                    }
                    function flatten(array, isDeep, guard) {
                        var length = array ? array.length : 0;
                        if (guard && isIterateeCall(array, isDeep, guard)) {
                            isDeep = false;
                        }
                        return length ? baseFlatten(array, isDeep) : [];
                    }
                    function flattenDeep(array) {
                        var length = array ? array.length : 0;
                        return length ? baseFlatten(array, true) : [];
                    }
                    function indexOf(array, value, fromIndex) {
                        var length = array ? array.length : 0;
                        if (!length) {
                            return -1;
                        }
                        if (typeof fromIndex == "number") {
                            fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : fromIndex;
                        } else if (fromIndex) {
                            var index = binaryIndex(array, value), other = array[index];
                            if (value === value ? value === other : other !== other) {
                                return index;
                            }
                            return -1;
                        }
                        return baseIndexOf(array, value, fromIndex || 0);
                    }
                    function initial(array) {
                        return dropRight(array, 1);
                    }
                    function intersection() {
                        var args = [], argsIndex = -1, argsLength = arguments.length, caches = [], indexOf = getIndexOf(), isCommon = indexOf == baseIndexOf;
                        while (++argsIndex < argsLength) {
                            var value = arguments[argsIndex];
                            if (isArray(value) || isArguments(value)) {
                                args.push(value);
                                caches.push(isCommon && value.length >= 120 ? createCache(argsIndex && value) : null);
                            }
                        }
                        argsLength = args.length;
                        var array = args[0], index = -1, length = array ? array.length : 0, result = [], seen = caches[0];
                        outer: while (++index < length) {
                            value = array[index];
                            if ((seen ? cacheIndexOf(seen, value) : indexOf(result, value, 0)) < 0) {
                                argsIndex = argsLength;
                                while (--argsIndex) {
                                    var cache = caches[argsIndex];
                                    if ((cache ? cacheIndexOf(cache, value) : indexOf(args[argsIndex], value, 0)) < 0) {
                                        continue outer;
                                    }
                                }
                                if (seen) {
                                    seen.push(value);
                                }
                                result.push(value);
                            }
                        }
                        return result;
                    }
                    function last(array) {
                        var length = array ? array.length : 0;
                        return length ? array[length - 1] : undefined;
                    }
                    function lastIndexOf(array, value, fromIndex) {
                        var length = array ? array.length : 0;
                        if (!length) {
                            return -1;
                        }
                        var index = length;
                        if (typeof fromIndex == "number") {
                            index = (fromIndex < 0 ? nativeMax(length + fromIndex, 0) : nativeMin(fromIndex || 0, length - 1)) + 1;
                        } else if (fromIndex) {
                            index = binaryIndex(array, value, true) - 1;
                            var other = array[index];
                            if (value === value ? value === other : other !== other) {
                                return index;
                            }
                            return -1;
                        }
                        if (value !== value) {
                            return indexOfNaN(array, index, true);
                        }
                        while (index--) {
                            if (array[index] === value) {
                                return index;
                            }
                        }
                        return -1;
                    }
                    function pull() {
                        var args = arguments, array = args[0];
                        if (!(array && array.length)) {
                            return array;
                        }
                        var index = 0, indexOf = getIndexOf(), length = args.length;
                        while (++index < length) {
                            var fromIndex = 0, value = args[index];
                            while ((fromIndex = indexOf(array, value, fromIndex)) > -1) {
                                splice.call(array, fromIndex, 1);
                            }
                        }
                        return array;
                    }
                    var pullAt = restParam(function(array, indexes) {
                        array || (array = []);
                        indexes = baseFlatten(indexes);
                        var length = indexes.length, result = baseAt(array, indexes);
                        indexes.sort(baseCompareAscending);
                        while (length--) {
                            var index = parseFloat(indexes[length]);
                            if (index != previous && isIndex(index)) {
                                var previous = index;
                                splice.call(array, index, 1);
                            }
                        }
                        return result;
                    });
                    function remove(array, predicate, thisArg) {
                        var index = -1, length = array ? array.length : 0, result = [];
                        predicate = getCallback(predicate, thisArg, 3);
                        while (++index < length) {
                            var value = array[index];
                            if (predicate(value, index, array)) {
                                result.push(value);
                                splice.call(array, index--, 1);
                                length--;
                            }
                        }
                        return result;
                    }
                    function rest(array) {
                        return drop(array, 1);
                    }
                    function slice(array, start, end) {
                        var length = array ? array.length : 0;
                        if (!length) {
                            return [];
                        }
                        if (end && typeof end != "number" && isIterateeCall(array, start, end)) {
                            start = 0;
                            end = length;
                        }
                        return baseSlice(array, start, end);
                    }
                    var sortedIndex = createSortedIndex();
                    var sortedLastIndex = createSortedIndex(true);
                    function take(array, n, guard) {
                        var length = array ? array.length : 0;
                        if (!length) {
                            return [];
                        }
                        if (guard ? isIterateeCall(array, n, guard) : n == null) {
                            n = 1;
                        }
                        return baseSlice(array, 0, n < 0 ? 0 : n);
                    }
                    function takeRight(array, n, guard) {
                        var length = array ? array.length : 0;
                        if (!length) {
                            return [];
                        }
                        if (guard ? isIterateeCall(array, n, guard) : n == null) {
                            n = 1;
                        }
                        n = length - (+n || 0);
                        return baseSlice(array, n < 0 ? 0 : n);
                    }
                    function takeRightWhile(array, predicate, thisArg) {
                        return array && array.length ? baseWhile(array, getCallback(predicate, thisArg, 3), false, true) : [];
                    }
                    function takeWhile(array, predicate, thisArg) {
                        return array && array.length ? baseWhile(array, getCallback(predicate, thisArg, 3)) : [];
                    }
                    var union = restParam(function(arrays) {
                        return baseUniq(baseFlatten(arrays, false, true));
                    });
                    function uniq(array, isSorted, iteratee, thisArg) {
                        var length = array ? array.length : 0;
                        if (!length) {
                            return [];
                        }
                        if (isSorted != null && typeof isSorted != "boolean") {
                            thisArg = iteratee;
                            iteratee = isIterateeCall(array, isSorted, thisArg) ? null : isSorted;
                            isSorted = false;
                        }
                        var func = getCallback();
                        if (!(func === baseCallback && iteratee == null)) {
                            iteratee = func(iteratee, thisArg, 3);
                        }
                        return isSorted && getIndexOf() == baseIndexOf ? sortedUniq(array, iteratee) : baseUniq(array, iteratee);
                    }
                    function unzip(array) {
                        var index = -1, length = (array && array.length && arrayMax(arrayMap(array, getLength))) >>> 0, result = Array(length);
                        while (++index < length) {
                            result[index] = arrayMap(array, baseProperty(index));
                        }
                        return result;
                    }
                    var without = restParam(function(array, values) {
                        return isArray(array) || isArguments(array) ? baseDifference(array, values) : [];
                    });
                    function xor() {
                        var index = -1, length = arguments.length;
                        while (++index < length) {
                            var array = arguments[index];
                            if (isArray(array) || isArguments(array)) {
                                var result = result ? baseDifference(result, array).concat(baseDifference(array, result)) : array;
                            }
                        }
                        return result ? baseUniq(result) : [];
                    }
                    var zip = restParam(unzip);
                    function zipObject(props, values) {
                        var index = -1, length = props ? props.length : 0, result = {};
                        if (length && !values && !isArray(props[0])) {
                            values = [];
                        }
                        while (++index < length) {
                            var key = props[index];
                            if (values) {
                                result[key] = values[index];
                            } else if (key) {
                                result[key[0]] = key[1];
                            }
                        }
                        return result;
                    }
                    function chain(value) {
                        var result = lodash(value);
                        result.__chain__ = true;
                        return result;
                    }
                    function tap(value, interceptor, thisArg) {
                        interceptor.call(thisArg, value);
                        return value;
                    }
                    function thru(value, interceptor, thisArg) {
                        return interceptor.call(thisArg, value);
                    }
                    function wrapperChain() {
                        return chain(this);
                    }
                    function wrapperCommit() {
                        return new LodashWrapper(this.value(), this.__chain__);
                    }
                    function wrapperPlant(value) {
                        var result, parent = this;
                        while (parent instanceof baseLodash) {
                            var clone = wrapperClone(parent);
                            if (result) {
                                previous.__wrapped__ = clone;
                            } else {
                                result = clone;
                            }
                            var previous = clone;
                            parent = parent.__wrapped__;
                        }
                        previous.__wrapped__ = value;
                        return result;
                    }
                    function wrapperReverse() {
                        var value = this.__wrapped__;
                        if (value instanceof LazyWrapper) {
                            if (this.__actions__.length) {
                                value = new LazyWrapper(this);
                            }
                            return new LodashWrapper(value.reverse(), this.__chain__);
                        }
                        return this.thru(function(value) {
                            return value.reverse();
                        });
                    }
                    function wrapperToString() {
                        return this.value() + "";
                    }
                    function wrapperValue() {
                        return baseWrapperValue(this.__wrapped__, this.__actions__);
                    }
                    var at = restParam(function(collection, props) {
                        var length = collection ? collection.length : 0;
                        if (isLength(length)) {
                            collection = toIterable(collection);
                        }
                        return baseAt(collection, baseFlatten(props));
                    });
                    var countBy = createAggregator(function(result, value, key) {
                        hasOwnProperty.call(result, key) ? ++result[key] : result[key] = 1;
                    });
                    function every(collection, predicate, thisArg) {
                        var func = isArray(collection) ? arrayEvery : baseEvery;
                        if (thisArg && isIterateeCall(collection, predicate, thisArg)) {
                            predicate = null;
                        }
                        if (typeof predicate != "function" || typeof thisArg != "undefined") {
                            predicate = getCallback(predicate, thisArg, 3);
                        }
                        return func(collection, predicate);
                    }
                    function filter(collection, predicate, thisArg) {
                        var func = isArray(collection) ? arrayFilter : baseFilter;
                        predicate = getCallback(predicate, thisArg, 3);
                        return func(collection, predicate);
                    }
                    var find = createFind(baseEach);
                    var findLast = createFind(baseEachRight, true);
                    function findWhere(collection, source) {
                        return find(collection, baseMatches(source));
                    }
                    var forEach = createForEach(arrayEach, baseEach);
                    var forEachRight = createForEach(arrayEachRight, baseEachRight);
                    var groupBy = createAggregator(function(result, value, key) {
                        if (hasOwnProperty.call(result, key)) {
                            result[key].push(value);
                        } else {
                            result[key] = [ value ];
                        }
                    });
                    function includes(collection, target, fromIndex, guard) {
                        var length = collection ? collection.length : 0;
                        if (!isLength(length)) {
                            collection = values(collection);
                            length = collection.length;
                        }
                        if (!length) {
                            return false;
                        }
                        if (typeof fromIndex != "number" || guard && isIterateeCall(target, fromIndex, guard)) {
                            fromIndex = 0;
                        } else {
                            fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : fromIndex || 0;
                        }
                        return typeof collection == "string" || !isArray(collection) && isString(collection) ? fromIndex < length && collection.indexOf(target, fromIndex) > -1 : getIndexOf(collection, target, fromIndex) > -1;
                    }
                    var indexBy = createAggregator(function(result, value, key) {
                        result[key] = value;
                    });
                    var invoke = restParam(function(collection, methodName, args) {
                        var index = -1, isFunc = typeof methodName == "function", length = collection ? collection.length : 0, result = isLength(length) ? Array(length) : [];
                        baseEach(collection, function(value) {
                            var func = isFunc ? methodName : value != null && value[methodName];
                            result[++index] = func ? func.apply(value, args) : undefined;
                        });
                        return result;
                    });
                    function map(collection, iteratee, thisArg) {
                        var func = isArray(collection) ? arrayMap : baseMap;
                        iteratee = getCallback(iteratee, thisArg, 3);
                        return func(collection, iteratee);
                    }
                    var partition = createAggregator(function(result, value, key) {
                        result[key ? 0 : 1].push(value);
                    }, function() {
                        return [ [], [] ];
                    });
                    function pluck(collection, key) {
                        return map(collection, baseProperty(key));
                    }
                    var reduce = createReduce(arrayReduce, baseEach);
                    var reduceRight = createReduce(arrayReduceRight, baseEachRight);
                    function reject(collection, predicate, thisArg) {
                        var func = isArray(collection) ? arrayFilter : baseFilter;
                        predicate = getCallback(predicate, thisArg, 3);
                        return func(collection, function(value, index, collection) {
                            return !predicate(value, index, collection);
                        });
                    }
                    function sample(collection, n, guard) {
                        if (guard ? isIterateeCall(collection, n, guard) : n == null) {
                            collection = toIterable(collection);
                            var length = collection.length;
                            return length > 0 ? collection[baseRandom(0, length - 1)] : undefined;
                        }
                        var result = shuffle(collection);
                        result.length = nativeMin(n < 0 ? 0 : +n || 0, result.length);
                        return result;
                    }
                    function shuffle(collection) {
                        collection = toIterable(collection);
                        var index = -1, length = collection.length, result = Array(length);
                        while (++index < length) {
                            var rand = baseRandom(0, index);
                            if (index != rand) {
                                result[index] = result[rand];
                            }
                            result[rand] = collection[index];
                        }
                        return result;
                    }
                    function size(collection) {
                        var length = collection ? collection.length : 0;
                        return isLength(length) ? length : keys(collection).length;
                    }
                    function some(collection, predicate, thisArg) {
                        var func = isArray(collection) ? arraySome : baseSome;
                        if (thisArg && isIterateeCall(collection, predicate, thisArg)) {
                            predicate = null;
                        }
                        if (typeof predicate != "function" || typeof thisArg != "undefined") {
                            predicate = getCallback(predicate, thisArg, 3);
                        }
                        return func(collection, predicate);
                    }
                    function sortBy(collection, iteratee, thisArg) {
                        if (collection == null) {
                            return [];
                        }
                        var index = -1, length = collection.length, result = isLength(length) ? Array(length) : [];
                        if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
                            iteratee = null;
                        }
                        iteratee = getCallback(iteratee, thisArg, 3);
                        baseEach(collection, function(value, key, collection) {
                            result[++index] = {
                                criteria: iteratee(value, key, collection),
                                index: index,
                                value: value
                            };
                        });
                        return baseSortBy(result, compareAscending);
                    }
                    function sortByAll() {
                        var args = arguments, collection = args[0], guard = args[3], index = 0, length = args.length - 1;
                        if (collection == null) {
                            return [];
                        }
                        var props = Array(length);
                        while (index < length) {
                            props[index] = args[++index];
                        }
                        if (guard && isIterateeCall(args[1], args[2], guard)) {
                            props = args[1];
                        }
                        return baseSortByOrder(collection, baseFlatten(props), []);
                    }
                    function sortByOrder(collection, props, orders, guard) {
                        if (collection == null) {
                            return [];
                        }
                        if (guard && isIterateeCall(props, orders, guard)) {
                            orders = null;
                        }
                        if (!isArray(props)) {
                            props = props == null ? [] : [ props ];
                        }
                        if (!isArray(orders)) {
                            orders = orders == null ? [] : [ orders ];
                        }
                        return baseSortByOrder(collection, props, orders);
                    }
                    function where(collection, source) {
                        return filter(collection, baseMatches(source));
                    }
                    var now = nativeNow || function() {
                        return new Date().getTime();
                    };
                    function after(n, func) {
                        if (typeof func != "function") {
                            if (typeof n == "function") {
                                var temp = n;
                                n = func;
                                func = temp;
                            } else {
                                throw new TypeError(FUNC_ERROR_TEXT);
                            }
                        }
                        n = nativeIsFinite(n = +n) ? n : 0;
                        return function() {
                            if (--n < 1) {
                                return func.apply(this, arguments);
                            }
                        };
                    }
                    function ary(func, n, guard) {
                        if (guard && isIterateeCall(func, n, guard)) {
                            n = null;
                        }
                        n = func && n == null ? func.length : nativeMax(+n || 0, 0);
                        return createWrapper(func, ARY_FLAG, null, null, null, null, n);
                    }
                    function before(n, func) {
                        var result;
                        if (typeof func != "function") {
                            if (typeof n == "function") {
                                var temp = n;
                                n = func;
                                func = temp;
                            } else {
                                throw new TypeError(FUNC_ERROR_TEXT);
                            }
                        }
                        return function() {
                            if (--n > 0) {
                                result = func.apply(this, arguments);
                            } else {
                                func = null;
                            }
                            return result;
                        };
                    }
                    var bind = restParam(function(func, thisArg, partials) {
                        var bitmask = BIND_FLAG;
                        if (partials.length) {
                            var holders = replaceHolders(partials, bind.placeholder);
                            bitmask |= PARTIAL_FLAG;
                        }
                        return createWrapper(func, bitmask, thisArg, partials, holders);
                    });
                    var bindAll = restParam(function(object, methodNames) {
                        methodNames = methodNames.length ? baseFlatten(methodNames) : functions(object);
                        var index = -1, length = methodNames.length;
                        while (++index < length) {
                            var key = methodNames[index];
                            object[key] = createWrapper(object[key], BIND_FLAG, object);
                        }
                        return object;
                    });
                    var bindKey = restParam(function(object, key, partials) {
                        var bitmask = BIND_FLAG | BIND_KEY_FLAG;
                        if (partials.length) {
                            var holders = replaceHolders(partials, bindKey.placeholder);
                            bitmask |= PARTIAL_FLAG;
                        }
                        return createWrapper(key, bitmask, object, partials, holders);
                    });
                    var curry = createCurry(CURRY_FLAG);
                    var curryRight = createCurry(CURRY_RIGHT_FLAG);
                    function debounce(func, wait, options) {
                        var args, maxTimeoutId, result, stamp, thisArg, timeoutId, trailingCall, lastCalled = 0, maxWait = false, trailing = true;
                        if (typeof func != "function") {
                            throw new TypeError(FUNC_ERROR_TEXT);
                        }
                        wait = wait < 0 ? 0 : +wait || 0;
                        if (options === true) {
                            var leading = true;
                            trailing = false;
                        } else if (isObject(options)) {
                            leading = options.leading;
                            maxWait = "maxWait" in options && nativeMax(+options.maxWait || 0, wait);
                            trailing = "trailing" in options ? options.trailing : trailing;
                        }
                        function cancel() {
                            if (timeoutId) {
                                clearTimeout(timeoutId);
                            }
                            if (maxTimeoutId) {
                                clearTimeout(maxTimeoutId);
                            }
                            maxTimeoutId = timeoutId = trailingCall = undefined;
                        }
                        function delayed() {
                            var remaining = wait - (now() - stamp);
                            if (remaining <= 0 || remaining > wait) {
                                if (maxTimeoutId) {
                                    clearTimeout(maxTimeoutId);
                                }
                                var isCalled = trailingCall;
                                maxTimeoutId = timeoutId = trailingCall = undefined;
                                if (isCalled) {
                                    lastCalled = now();
                                    result = func.apply(thisArg, args);
                                    if (!timeoutId && !maxTimeoutId) {
                                        args = thisArg = null;
                                    }
                                }
                            } else {
                                timeoutId = setTimeout(delayed, remaining);
                            }
                        }
                        function maxDelayed() {
                            if (timeoutId) {
                                clearTimeout(timeoutId);
                            }
                            maxTimeoutId = timeoutId = trailingCall = undefined;
                            if (trailing || maxWait !== wait) {
                                lastCalled = now();
                                result = func.apply(thisArg, args);
                                if (!timeoutId && !maxTimeoutId) {
                                    args = thisArg = null;
                                }
                            }
                        }
                        function debounced() {
                            args = arguments;
                            stamp = now();
                            thisArg = this;
                            trailingCall = trailing && (timeoutId || !leading);
                            if (maxWait === false) {
                                var leadingCall = leading && !timeoutId;
                            } else {
                                if (!maxTimeoutId && !leading) {
                                    lastCalled = stamp;
                                }
                                var remaining = maxWait - (stamp - lastCalled), isCalled = remaining <= 0 || remaining > maxWait;
                                if (isCalled) {
                                    if (maxTimeoutId) {
                                        maxTimeoutId = clearTimeout(maxTimeoutId);
                                    }
                                    lastCalled = stamp;
                                    result = func.apply(thisArg, args);
                                } else if (!maxTimeoutId) {
                                    maxTimeoutId = setTimeout(maxDelayed, remaining);
                                }
                            }
                            if (isCalled && timeoutId) {
                                timeoutId = clearTimeout(timeoutId);
                            } else if (!timeoutId && wait !== maxWait) {
                                timeoutId = setTimeout(delayed, wait);
                            }
                            if (leadingCall) {
                                isCalled = true;
                                result = func.apply(thisArg, args);
                            }
                            if (isCalled && !timeoutId && !maxTimeoutId) {
                                args = thisArg = null;
                            }
                            return result;
                        }
                        debounced.cancel = cancel;
                        return debounced;
                    }
                    var defer = restParam(function(func, args) {
                        return baseDelay(func, 1, args);
                    });
                    var delay = restParam(function(func, wait, args) {
                        return baseDelay(func, wait, args);
                    });
                    var flow = createFlow();
                    var flowRight = createFlow(true);
                    function memoize(func, resolver) {
                        if (typeof func != "function" || resolver && typeof resolver != "function") {
                            throw new TypeError(FUNC_ERROR_TEXT);
                        }
                        var memoized = function() {
                            var args = arguments, cache = memoized.cache, key = resolver ? resolver.apply(this, args) : args[0];
                            if (cache.has(key)) {
                                return cache.get(key);
                            }
                            var result = func.apply(this, args);
                            cache.set(key, result);
                            return result;
                        };
                        memoized.cache = new memoize.Cache();
                        return memoized;
                    }
                    function negate(predicate) {
                        if (typeof predicate != "function") {
                            throw new TypeError(FUNC_ERROR_TEXT);
                        }
                        return function() {
                            return !predicate.apply(this, arguments);
                        };
                    }
                    function once(func) {
                        return before(func, 2);
                    }
                    var partial = createPartial(PARTIAL_FLAG);
                    var partialRight = createPartial(PARTIAL_RIGHT_FLAG);
                    var rearg = restParam(function(func, indexes) {
                        return createWrapper(func, REARG_FLAG, null, null, null, baseFlatten(indexes));
                    });
                    function restParam(func, start) {
                        if (typeof func != "function") {
                            throw new TypeError(FUNC_ERROR_TEXT);
                        }
                        start = nativeMax(typeof start == "undefined" ? func.length - 1 : +start || 0, 0);
                        return function() {
                            var args = arguments, index = -1, length = nativeMax(args.length - start, 0), rest = Array(length);
                            while (++index < length) {
                                rest[index] = args[start + index];
                            }
                            switch (start) {
                              case 0:
                                return func.call(this, rest);

                              case 1:
                                return func.call(this, args[0], rest);

                              case 2:
                                return func.call(this, args[0], args[1], rest);
                            }
                            var otherArgs = Array(start + 1);
                            index = -1;
                            while (++index < start) {
                                otherArgs[index] = args[index];
                            }
                            otherArgs[start] = rest;
                            return func.apply(this, otherArgs);
                        };
                    }
                    function spread(func) {
                        if (typeof func != "function") {
                            throw new TypeError(FUNC_ERROR_TEXT);
                        }
                        return function(array) {
                            return func.apply(this, array);
                        };
                    }
                    function throttle(func, wait, options) {
                        var leading = true, trailing = true;
                        if (typeof func != "function") {
                            throw new TypeError(FUNC_ERROR_TEXT);
                        }
                        if (options === false) {
                            leading = false;
                        } else if (isObject(options)) {
                            leading = "leading" in options ? !!options.leading : leading;
                            trailing = "trailing" in options ? !!options.trailing : trailing;
                        }
                        debounceOptions.leading = leading;
                        debounceOptions.maxWait = +wait;
                        debounceOptions.trailing = trailing;
                        return debounce(func, wait, debounceOptions);
                    }
                    function wrap(value, wrapper) {
                        wrapper = wrapper == null ? identity : wrapper;
                        return createWrapper(wrapper, PARTIAL_FLAG, null, [ value ], []);
                    }
                    function clone(value, isDeep, customizer, thisArg) {
                        if (isDeep && typeof isDeep != "boolean" && isIterateeCall(value, isDeep, customizer)) {
                            isDeep = false;
                        } else if (typeof isDeep == "function") {
                            thisArg = customizer;
                            customizer = isDeep;
                            isDeep = false;
                        }
                        customizer = typeof customizer == "function" && bindCallback(customizer, thisArg, 1);
                        return baseClone(value, isDeep, customizer);
                    }
                    function cloneDeep(value, customizer, thisArg) {
                        customizer = typeof customizer == "function" && bindCallback(customizer, thisArg, 1);
                        return baseClone(value, true, customizer);
                    }
                    function isArguments(value) {
                        var length = isObjectLike(value) ? value.length : undefined;
                        return isLength(length) && objToString.call(value) == argsTag;
                    }
                    var isArray = nativeIsArray || function(value) {
                        return isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag;
                    };
                    function isBoolean(value) {
                        return value === true || value === false || isObjectLike(value) && objToString.call(value) == boolTag;
                    }
                    function isDate(value) {
                        return isObjectLike(value) && objToString.call(value) == dateTag;
                    }
                    function isElement(value) {
                        return !!value && value.nodeType === 1 && isObjectLike(value) && objToString.call(value).indexOf("Element") > -1;
                    }
                    if (!support.dom) {
                        isElement = function(value) {
                            return !!value && value.nodeType === 1 && isObjectLike(value) && !isPlainObject(value);
                        };
                    }
                    function isEmpty(value) {
                        if (value == null) {
                            return true;
                        }
                        var length = value.length;
                        if (isLength(length) && (isArray(value) || isString(value) || isArguments(value) || isObjectLike(value) && isFunction(value.splice))) {
                            return !length;
                        }
                        return !keys(value).length;
                    }
                    function isEqual(value, other, customizer, thisArg) {
                        customizer = typeof customizer == "function" && bindCallback(customizer, thisArg, 3);
                        if (!customizer && isStrictComparable(value) && isStrictComparable(other)) {
                            return value === other;
                        }
                        var result = customizer ? customizer(value, other) : undefined;
                        return typeof result == "undefined" ? baseIsEqual(value, other, customizer) : !!result;
                    }
                    function isError(value) {
                        return isObjectLike(value) && typeof value.message == "string" && objToString.call(value) == errorTag;
                    }
                    var isFinite = nativeNumIsFinite || function(value) {
                        return typeof value == "number" && nativeIsFinite(value);
                    };
                    var isFunction = !(baseIsFunction(/x/) || Uint8Array && !baseIsFunction(Uint8Array)) ? baseIsFunction : function(value) {
                        return objToString.call(value) == funcTag;
                    };
                    function isObject(value) {
                        var type = typeof value;
                        return type == "function" || !!value && type == "object";
                    }
                    function isMatch(object, source, customizer, thisArg) {
                        var props = keys(source), length = props.length;
                        if (!length) {
                            return true;
                        }
                        if (object == null) {
                            return false;
                        }
                        customizer = typeof customizer == "function" && bindCallback(customizer, thisArg, 3);
                        if (!customizer && length == 1) {
                            var key = props[0], value = source[key];
                            if (isStrictComparable(value)) {
                                return value === object[key] && (typeof value != "undefined" || key in toObject(object));
                            }
                        }
                        var values = Array(length), strictCompareFlags = Array(length);
                        while (length--) {
                            value = values[length] = source[props[length]];
                            strictCompareFlags[length] = isStrictComparable(value);
                        }
                        return baseIsMatch(toObject(object), props, values, strictCompareFlags, customizer);
                    }
                    function isNaN(value) {
                        return isNumber(value) && value != +value;
                    }
                    function isNative(value) {
                        if (value == null) {
                            return false;
                        }
                        if (objToString.call(value) == funcTag) {
                            return reNative.test(fnToString.call(value));
                        }
                        return isObjectLike(value) && reHostCtor.test(value);
                    }
                    function isNull(value) {
                        return value === null;
                    }
                    function isNumber(value) {
                        return typeof value == "number" || isObjectLike(value) && objToString.call(value) == numberTag;
                    }
                    var isPlainObject = !getPrototypeOf ? shimIsPlainObject : function(value) {
                        if (!(value && objToString.call(value) == objectTag)) {
                            return false;
                        }
                        var valueOf = value.valueOf, objProto = isNative(valueOf) && (objProto = getPrototypeOf(valueOf)) && getPrototypeOf(objProto);
                        return objProto ? value == objProto || getPrototypeOf(value) == objProto : shimIsPlainObject(value);
                    };
                    function isRegExp(value) {
                        return isObjectLike(value) && objToString.call(value) == regexpTag || false;
                    }
                    function isString(value) {
                        return typeof value == "string" || isObjectLike(value) && objToString.call(value) == stringTag;
                    }
                    function isTypedArray(value) {
                        return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objToString.call(value)];
                    }
                    function isUndefined(value) {
                        return typeof value == "undefined";
                    }
                    function toArray(value) {
                        var length = value ? value.length : 0;
                        if (!isLength(length)) {
                            return values(value);
                        }
                        if (!length) {
                            return [];
                        }
                        return arrayCopy(value);
                    }
                    function toPlainObject(value) {
                        return baseCopy(value, keysIn(value));
                    }
                    var assign = createAssigner(baseAssign);
                    function create(prototype, properties, guard) {
                        var result = baseCreate(prototype);
                        if (guard && isIterateeCall(prototype, properties, guard)) {
                            properties = null;
                        }
                        return properties ? baseCopy(properties, result, keys(properties)) : result;
                    }
                    var defaults = restParam(function(args) {
                        var object = args[0];
                        if (object == null) {
                            return object;
                        }
                        args.push(assignDefaults);
                        return assign.apply(undefined, args);
                    });
                    var findKey = createFindKey(baseForOwn);
                    var findLastKey = createFindKey(baseForOwnRight);
                    var forIn = createForIn(baseFor);
                    var forInRight = createForIn(baseForRight);
                    var forOwn = createForOwn(baseForOwn);
                    var forOwnRight = createForOwn(baseForOwnRight);
                    function functions(object) {
                        return baseFunctions(object, keysIn(object));
                    }
                    function has(object, key) {
                        return object ? hasOwnProperty.call(object, key) : false;
                    }
                    function invert(object, multiValue, guard) {
                        if (guard && isIterateeCall(object, multiValue, guard)) {
                            multiValue = null;
                        }
                        var index = -1, props = keys(object), length = props.length, result = {};
                        while (++index < length) {
                            var key = props[index], value = object[key];
                            if (multiValue) {
                                if (hasOwnProperty.call(result, value)) {
                                    result[value].push(key);
                                } else {
                                    result[value] = [ key ];
                                }
                            } else {
                                result[value] = key;
                            }
                        }
                        return result;
                    }
                    var keys = !nativeKeys ? shimKeys : function(object) {
                        if (object) {
                            var Ctor = object.constructor, length = object.length;
                        }
                        if (typeof Ctor == "function" && Ctor.prototype === object || typeof object != "function" && (length && isLength(length))) {
                            return shimKeys(object);
                        }
                        return isObject(object) ? nativeKeys(object) : [];
                    };
                    function keysIn(object) {
                        if (object == null) {
                            return [];
                        }
                        if (!isObject(object)) {
                            object = Object(object);
                        }
                        var length = object.length;
                        length = length && isLength(length) && (isArray(object) || support.nonEnumArgs && isArguments(object)) && length || 0;
                        var Ctor = object.constructor, index = -1, isProto = typeof Ctor == "function" && Ctor.prototype === object, result = Array(length), skipIndexes = length > 0;
                        while (++index < length) {
                            result[index] = index + "";
                        }
                        for (var key in object) {
                            if (!(skipIndexes && isIndex(key, length)) && !(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
                                result.push(key);
                            }
                        }
                        return result;
                    }
                    function mapValues(object, iteratee, thisArg) {
                        var result = {};
                        iteratee = getCallback(iteratee, thisArg, 3);
                        baseForOwn(object, function(value, key, object) {
                            result[key] = iteratee(value, key, object);
                        });
                        return result;
                    }
                    var merge = createAssigner(baseMerge);
                    var omit = restParam(function(object, props) {
                        if (object == null) {
                            return {};
                        }
                        if (typeof props[0] != "function") {
                            var props = arrayMap(baseFlatten(props), String);
                            return pickByArray(object, baseDifference(keysIn(object), props));
                        }
                        var predicate = bindCallback(props[0], props[1], 3);
                        return pickByCallback(object, function(value, key, object) {
                            return !predicate(value, key, object);
                        });
                    });
                    function pairs(object) {
                        var index = -1, props = keys(object), length = props.length, result = Array(length);
                        while (++index < length) {
                            var key = props[index];
                            result[index] = [ key, object[key] ];
                        }
                        return result;
                    }
                    var pick = restParam(function(object, props) {
                        if (object == null) {
                            return {};
                        }
                        return typeof props[0] == "function" ? pickByCallback(object, bindCallback(props[0], props[1], 3)) : pickByArray(object, baseFlatten(props));
                    });
                    function result(object, key, defaultValue) {
                        var value = object == null ? undefined : object[key];
                        if (typeof value == "undefined") {
                            value = defaultValue;
                        }
                        return isFunction(value) ? value.call(object) : value;
                    }
                    function transform(object, iteratee, accumulator, thisArg) {
                        var isArr = isArray(object) || isTypedArray(object);
                        iteratee = getCallback(iteratee, thisArg, 4);
                        if (accumulator == null) {
                            if (isArr || isObject(object)) {
                                var Ctor = object.constructor;
                                if (isArr) {
                                    accumulator = isArray(object) ? new Ctor() : [];
                                } else {
                                    accumulator = baseCreate(isFunction(Ctor) && Ctor.prototype);
                                }
                            } else {
                                accumulator = {};
                            }
                        }
                        (isArr ? arrayEach : baseForOwn)(object, function(value, index, object) {
                            return iteratee(accumulator, value, index, object);
                        });
                        return accumulator;
                    }
                    function values(object) {
                        return baseValues(object, keys(object));
                    }
                    function valuesIn(object) {
                        return baseValues(object, keysIn(object));
                    }
                    function inRange(value, start, end) {
                        start = +start || 0;
                        if (typeof end === "undefined") {
                            end = start;
                            start = 0;
                        } else {
                            end = +end || 0;
                        }
                        return value >= start && value < end;
                    }
                    function random(min, max, floating) {
                        if (floating && isIterateeCall(min, max, floating)) {
                            max = floating = null;
                        }
                        var noMin = min == null, noMax = max == null;
                        if (floating == null) {
                            if (noMax && typeof min == "boolean") {
                                floating = min;
                                min = 1;
                            } else if (typeof max == "boolean") {
                                floating = max;
                                noMax = true;
                            }
                        }
                        if (noMin && noMax) {
                            max = 1;
                            noMax = false;
                        }
                        min = +min || 0;
                        if (noMax) {
                            max = min;
                            min = 0;
                        } else {
                            max = +max || 0;
                        }
                        if (floating || min % 1 || max % 1) {
                            var rand = nativeRandom();
                            return nativeMin(min + rand * (max - min + parseFloat("1e-" + ((rand + "").length - 1))), max);
                        }
                        return baseRandom(min, max);
                    }
                    var camelCase = createCompounder(function(result, word, index) {
                        word = word.toLowerCase();
                        return result + (index ? word.charAt(0).toUpperCase() + word.slice(1) : word);
                    });
                    function capitalize(string) {
                        string = baseToString(string);
                        return string && string.charAt(0).toUpperCase() + string.slice(1);
                    }
                    function deburr(string) {
                        string = baseToString(string);
                        return string && string.replace(reLatin1, deburrLetter).replace(reComboMarks, "");
                    }
                    function endsWith(string, target, position) {
                        string = baseToString(string);
                        target = target + "";
                        var length = string.length;
                        position = typeof position == "undefined" ? length : nativeMin(position < 0 ? 0 : +position || 0, length);
                        position -= target.length;
                        return position >= 0 && string.indexOf(target, position) == position;
                    }
                    function escape(string) {
                        string = baseToString(string);
                        return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
                    }
                    function escapeRegExp(string) {
                        string = baseToString(string);
                        return string && reHasRegExpChars.test(string) ? string.replace(reRegExpChars, "\\$&") : string;
                    }
                    var kebabCase = createCompounder(function(result, word, index) {
                        return result + (index ? "-" : "") + word.toLowerCase();
                    });
                    function pad(string, length, chars) {
                        string = baseToString(string);
                        length = +length;
                        var strLength = string.length;
                        if (strLength >= length || !nativeIsFinite(length)) {
                            return string;
                        }
                        var mid = (length - strLength) / 2, leftLength = floor(mid), rightLength = ceil(mid);
                        chars = createPadding("", rightLength, chars);
                        return chars.slice(0, leftLength) + string + chars;
                    }
                    var padLeft = createPadDir();
                    var padRight = createPadDir(true);
                    function parseInt(string, radix, guard) {
                        if (guard && isIterateeCall(string, radix, guard)) {
                            radix = 0;
                        }
                        return nativeParseInt(string, radix);
                    }
                    if (nativeParseInt(whitespace + "08") != 8) {
                        parseInt = function(string, radix, guard) {
                            if (guard ? isIterateeCall(string, radix, guard) : radix == null) {
                                radix = 0;
                            } else if (radix) {
                                radix = +radix;
                            }
                            string = trim(string);
                            return nativeParseInt(string, radix || (reHexPrefix.test(string) ? 16 : 10));
                        };
                    }
                    function repeat(string, n) {
                        var result = "";
                        string = baseToString(string);
                        n = +n;
                        if (n < 1 || !string || !nativeIsFinite(n)) {
                            return result;
                        }
                        do {
                            if (n % 2) {
                                result += string;
                            }
                            n = floor(n / 2);
                            string += string;
                        } while (n);
                        return result;
                    }
                    var snakeCase = createCompounder(function(result, word, index) {
                        return result + (index ? "_" : "") + word.toLowerCase();
                    });
                    var startCase = createCompounder(function(result, word, index) {
                        return result + (index ? " " : "") + (word.charAt(0).toUpperCase() + word.slice(1));
                    });
                    function startsWith(string, target, position) {
                        string = baseToString(string);
                        position = position == null ? 0 : nativeMin(position < 0 ? 0 : +position || 0, string.length);
                        return string.lastIndexOf(target, position) == position;
                    }
                    function template(string, options, otherOptions) {
                        var settings = lodash.templateSettings;
                        if (otherOptions && isIterateeCall(string, options, otherOptions)) {
                            options = otherOptions = null;
                        }
                        string = baseToString(string);
                        options = baseAssign(baseAssign({}, otherOptions || options), settings, assignOwnDefaults);
                        var imports = baseAssign(baseAssign({}, options.imports), settings.imports, assignOwnDefaults), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
                        var isEscaping, isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
                        var reDelimiters = RegExp((options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$", "g");
                        var sourceURL = "//# sourceURL=" + ("sourceURL" in options ? options.sourceURL : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
                        string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
                            interpolateValue || (interpolateValue = esTemplateValue);
                            source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);
                            if (escapeValue) {
                                isEscaping = true;
                                source += "' +\n__e(" + escapeValue + ") +\n'";
                            }
                            if (evaluateValue) {
                                isEvaluating = true;
                                source += "';\n" + evaluateValue + ";\n__p += '";
                            }
                            if (interpolateValue) {
                                source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
                            }
                            index = offset + match.length;
                            return match;
                        });
                        source += "';\n";
                        var variable = options.variable;
                        if (!variable) {
                            source = "with (obj) {\n" + source + "\n}\n";
                        }
                        source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
                        source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\n" + "function print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
                        var result = attempt(function() {
                            return Function(importsKeys, sourceURL + "return " + source).apply(undefined, importsValues);
                        });
                        result.source = source;
                        if (isError(result)) {
                            throw result;
                        }
                        return result;
                    }
                    function trim(string, chars, guard) {
                        var value = string;
                        string = baseToString(string);
                        if (!string) {
                            return string;
                        }
                        if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
                            return string.slice(trimmedLeftIndex(string), trimmedRightIndex(string) + 1);
                        }
                        chars = chars + "";
                        return string.slice(charsLeftIndex(string, chars), charsRightIndex(string, chars) + 1);
                    }
                    function trimLeft(string, chars, guard) {
                        var value = string;
                        string = baseToString(string);
                        if (!string) {
                            return string;
                        }
                        if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
                            return string.slice(trimmedLeftIndex(string));
                        }
                        return string.slice(charsLeftIndex(string, chars + ""));
                    }
                    function trimRight(string, chars, guard) {
                        var value = string;
                        string = baseToString(string);
                        if (!string) {
                            return string;
                        }
                        if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
                            return string.slice(0, trimmedRightIndex(string) + 1);
                        }
                        return string.slice(0, charsRightIndex(string, chars + "") + 1);
                    }
                    function trunc(string, options, guard) {
                        if (guard && isIterateeCall(string, options, guard)) {
                            options = null;
                        }
                        var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
                        if (options != null) {
                            if (isObject(options)) {
                                var separator = "separator" in options ? options.separator : separator;
                                length = "length" in options ? +options.length || 0 : length;
                                omission = "omission" in options ? baseToString(options.omission) : omission;
                            } else {
                                length = +options || 0;
                            }
                        }
                        string = baseToString(string);
                        if (length >= string.length) {
                            return string;
                        }
                        var end = length - omission.length;
                        if (end < 1) {
                            return omission;
                        }
                        var result = string.slice(0, end);
                        if (separator == null) {
                            return result + omission;
                        }
                        if (isRegExp(separator)) {
                            if (string.slice(end).search(separator)) {
                                var match, newEnd, substring = string.slice(0, end);
                                if (!separator.global) {
                                    separator = RegExp(separator.source, (reFlags.exec(separator) || "") + "g");
                                }
                                separator.lastIndex = 0;
                                while (match = separator.exec(substring)) {
                                    newEnd = match.index;
                                }
                                result = result.slice(0, newEnd == null ? end : newEnd);
                            }
                        } else if (string.indexOf(separator, end) != end) {
                            var index = result.lastIndexOf(separator);
                            if (index > -1) {
                                result = result.slice(0, index);
                            }
                        }
                        return result + omission;
                    }
                    function unescape(string) {
                        string = baseToString(string);
                        return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
                    }
                    function words(string, pattern, guard) {
                        if (guard && isIterateeCall(string, pattern, guard)) {
                            pattern = null;
                        }
                        string = baseToString(string);
                        return string.match(pattern || reWords) || [];
                    }
                    var attempt = restParam(function(func, args) {
                        try {
                            return func.apply(undefined, args);
                        } catch (e) {
                            return isError(e) ? e : new Error(e);
                        }
                    });
                    function callback(func, thisArg, guard) {
                        if (guard && isIterateeCall(func, thisArg, guard)) {
                            thisArg = null;
                        }
                        return isObjectLike(func) ? matches(func) : baseCallback(func, thisArg);
                    }
                    function constant(value) {
                        return function() {
                            return value;
                        };
                    }
                    function identity(value) {
                        return value;
                    }
                    function matches(source) {
                        return baseMatches(baseClone(source, true));
                    }
                    function matchesProperty(key, value) {
                        return baseMatchesProperty(key + "", baseClone(value, true));
                    }
                    function mixin(object, source, options) {
                        if (options == null) {
                            var isObj = isObject(source), props = isObj && keys(source), methodNames = props && props.length && baseFunctions(source, props);
                            if (!(methodNames ? methodNames.length : isObj)) {
                                methodNames = false;
                                options = source;
                                source = object;
                                object = this;
                            }
                        }
                        if (!methodNames) {
                            methodNames = baseFunctions(source, keys(source));
                        }
                        var chain = true, index = -1, isFunc = isFunction(object), length = methodNames.length;
                        if (options === false) {
                            chain = false;
                        } else if (isObject(options) && "chain" in options) {
                            chain = options.chain;
                        }
                        while (++index < length) {
                            var methodName = methodNames[index], func = source[methodName];
                            object[methodName] = func;
                            if (isFunc) {
                                object.prototype[methodName] = function(func) {
                                    return function() {
                                        var chainAll = this.__chain__;
                                        if (chain || chainAll) {
                                            var result = object(this.__wrapped__), actions = result.__actions__ = arrayCopy(this.__actions__);
                                            actions.push({
                                                func: func,
                                                args: arguments,
                                                thisArg: object
                                            });
                                            result.__chain__ = chainAll;
                                            return result;
                                        }
                                        var args = [ this.value() ];
                                        push.apply(args, arguments);
                                        return func.apply(object, args);
                                    };
                                }(func);
                            }
                        }
                        return object;
                    }
                    function noConflict() {
                        context._ = oldDash;
                        return this;
                    }
                    function noop() {}
                    function property(key) {
                        return baseProperty(key + "");
                    }
                    function propertyOf(object) {
                        return function(key) {
                            return object == null ? undefined : object[key];
                        };
                    }
                    function range(start, end, step) {
                        if (step && isIterateeCall(start, end, step)) {
                            end = step = null;
                        }
                        start = +start || 0;
                        step = step == null ? 1 : +step || 0;
                        if (end == null) {
                            end = start;
                            start = 0;
                        } else {
                            end = +end || 0;
                        }
                        var index = -1, length = nativeMax(ceil((end - start) / (step || 1)), 0), result = Array(length);
                        while (++index < length) {
                            result[index] = start;
                            start += step;
                        }
                        return result;
                    }
                    function times(n, iteratee, thisArg) {
                        n = +n;
                        if (n < 1 || !nativeIsFinite(n)) {
                            return [];
                        }
                        var index = -1, result = Array(nativeMin(n, MAX_ARRAY_LENGTH));
                        iteratee = bindCallback(iteratee, thisArg, 1);
                        while (++index < n) {
                            if (index < MAX_ARRAY_LENGTH) {
                                result[index] = iteratee(index);
                            } else {
                                iteratee(index);
                            }
                        }
                        return result;
                    }
                    function uniqueId(prefix) {
                        var id = ++idCounter;
                        return baseToString(prefix) + id;
                    }
                    function add(augend, addend) {
                        return augend + addend;
                    }
                    var max = createExtremum(arrayMax);
                    var min = createExtremum(arrayMin, true);
                    function sum(collection, iteratee, thisArg) {
                        if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
                            iteratee = null;
                        }
                        var func = getCallback(), noIteratee = iteratee == null;
                        if (!(func === baseCallback && noIteratee)) {
                            noIteratee = false;
                            iteratee = func(iteratee, thisArg, 3);
                        }
                        return noIteratee ? arraySum(isArray(collection) ? collection : toIterable(collection)) : baseSum(collection, iteratee);
                    }
                    lodash.prototype = baseLodash.prototype;
                    LodashWrapper.prototype = baseCreate(baseLodash.prototype);
                    LodashWrapper.prototype.constructor = LodashWrapper;
                    LazyWrapper.prototype = baseCreate(baseLodash.prototype);
                    LazyWrapper.prototype.constructor = LazyWrapper;
                    MapCache.prototype["delete"] = mapDelete;
                    MapCache.prototype.get = mapGet;
                    MapCache.prototype.has = mapHas;
                    MapCache.prototype.set = mapSet;
                    SetCache.prototype.push = cachePush;
                    memoize.Cache = MapCache;
                    lodash.after = after;
                    lodash.ary = ary;
                    lodash.assign = assign;
                    lodash.at = at;
                    lodash.before = before;
                    lodash.bind = bind;
                    lodash.bindAll = bindAll;
                    lodash.bindKey = bindKey;
                    lodash.callback = callback;
                    lodash.chain = chain;
                    lodash.chunk = chunk;
                    lodash.compact = compact;
                    lodash.constant = constant;
                    lodash.countBy = countBy;
                    lodash.create = create;
                    lodash.curry = curry;
                    lodash.curryRight = curryRight;
                    lodash.debounce = debounce;
                    lodash.defaults = defaults;
                    lodash.defer = defer;
                    lodash.delay = delay;
                    lodash.difference = difference;
                    lodash.drop = drop;
                    lodash.dropRight = dropRight;
                    lodash.dropRightWhile = dropRightWhile;
                    lodash.dropWhile = dropWhile;
                    lodash.fill = fill;
                    lodash.filter = filter;
                    lodash.flatten = flatten;
                    lodash.flattenDeep = flattenDeep;
                    lodash.flow = flow;
                    lodash.flowRight = flowRight;
                    lodash.forEach = forEach;
                    lodash.forEachRight = forEachRight;
                    lodash.forIn = forIn;
                    lodash.forInRight = forInRight;
                    lodash.forOwn = forOwn;
                    lodash.forOwnRight = forOwnRight;
                    lodash.functions = functions;
                    lodash.groupBy = groupBy;
                    lodash.indexBy = indexBy;
                    lodash.initial = initial;
                    lodash.intersection = intersection;
                    lodash.invert = invert;
                    lodash.invoke = invoke;
                    lodash.keys = keys;
                    lodash.keysIn = keysIn;
                    lodash.map = map;
                    lodash.mapValues = mapValues;
                    lodash.matches = matches;
                    lodash.matchesProperty = matchesProperty;
                    lodash.memoize = memoize;
                    lodash.merge = merge;
                    lodash.mixin = mixin;
                    lodash.negate = negate;
                    lodash.omit = omit;
                    lodash.once = once;
                    lodash.pairs = pairs;
                    lodash.partial = partial;
                    lodash.partialRight = partialRight;
                    lodash.partition = partition;
                    lodash.pick = pick;
                    lodash.pluck = pluck;
                    lodash.property = property;
                    lodash.propertyOf = propertyOf;
                    lodash.pull = pull;
                    lodash.pullAt = pullAt;
                    lodash.range = range;
                    lodash.rearg = rearg;
                    lodash.reject = reject;
                    lodash.remove = remove;
                    lodash.rest = rest;
                    lodash.restParam = restParam;
                    lodash.shuffle = shuffle;
                    lodash.slice = slice;
                    lodash.sortBy = sortBy;
                    lodash.sortByAll = sortByAll;
                    lodash.sortByOrder = sortByOrder;
                    lodash.spread = spread;
                    lodash.take = take;
                    lodash.takeRight = takeRight;
                    lodash.takeRightWhile = takeRightWhile;
                    lodash.takeWhile = takeWhile;
                    lodash.tap = tap;
                    lodash.throttle = throttle;
                    lodash.thru = thru;
                    lodash.times = times;
                    lodash.toArray = toArray;
                    lodash.toPlainObject = toPlainObject;
                    lodash.transform = transform;
                    lodash.union = union;
                    lodash.uniq = uniq;
                    lodash.unzip = unzip;
                    lodash.values = values;
                    lodash.valuesIn = valuesIn;
                    lodash.where = where;
                    lodash.without = without;
                    lodash.wrap = wrap;
                    lodash.xor = xor;
                    lodash.zip = zip;
                    lodash.zipObject = zipObject;
                    lodash.backflow = flowRight;
                    lodash.collect = map;
                    lodash.compose = flowRight;
                    lodash.each = forEach;
                    lodash.eachRight = forEachRight;
                    lodash.extend = assign;
                    lodash.iteratee = callback;
                    lodash.methods = functions;
                    lodash.object = zipObject;
                    lodash.select = filter;
                    lodash.tail = rest;
                    lodash.unique = uniq;
                    mixin(lodash, lodash);
                    lodash.add = add;
                    lodash.attempt = attempt;
                    lodash.camelCase = camelCase;
                    lodash.capitalize = capitalize;
                    lodash.clone = clone;
                    lodash.cloneDeep = cloneDeep;
                    lodash.deburr = deburr;
                    lodash.endsWith = endsWith;
                    lodash.escape = escape;
                    lodash.escapeRegExp = escapeRegExp;
                    lodash.every = every;
                    lodash.find = find;
                    lodash.findIndex = findIndex;
                    lodash.findKey = findKey;
                    lodash.findLast = findLast;
                    lodash.findLastIndex = findLastIndex;
                    lodash.findLastKey = findLastKey;
                    lodash.findWhere = findWhere;
                    lodash.first = first;
                    lodash.has = has;
                    lodash.identity = identity;
                    lodash.includes = includes;
                    lodash.indexOf = indexOf;
                    lodash.inRange = inRange;
                    lodash.isArguments = isArguments;
                    lodash.isArray = isArray;
                    lodash.isBoolean = isBoolean;
                    lodash.isDate = isDate;
                    lodash.isElement = isElement;
                    lodash.isEmpty = isEmpty;
                    lodash.isEqual = isEqual;
                    lodash.isError = isError;
                    lodash.isFinite = isFinite;
                    lodash.isFunction = isFunction;
                    lodash.isMatch = isMatch;
                    lodash.isNaN = isNaN;
                    lodash.isNative = isNative;
                    lodash.isNull = isNull;
                    lodash.isNumber = isNumber;
                    lodash.isObject = isObject;
                    lodash.isPlainObject = isPlainObject;
                    lodash.isRegExp = isRegExp;
                    lodash.isString = isString;
                    lodash.isTypedArray = isTypedArray;
                    lodash.isUndefined = isUndefined;
                    lodash.kebabCase = kebabCase;
                    lodash.last = last;
                    lodash.lastIndexOf = lastIndexOf;
                    lodash.max = max;
                    lodash.min = min;
                    lodash.noConflict = noConflict;
                    lodash.noop = noop;
                    lodash.now = now;
                    lodash.pad = pad;
                    lodash.padLeft = padLeft;
                    lodash.padRight = padRight;
                    lodash.parseInt = parseInt;
                    lodash.random = random;
                    lodash.reduce = reduce;
                    lodash.reduceRight = reduceRight;
                    lodash.repeat = repeat;
                    lodash.result = result;
                    lodash.runInContext = runInContext;
                    lodash.size = size;
                    lodash.snakeCase = snakeCase;
                    lodash.some = some;
                    lodash.sortedIndex = sortedIndex;
                    lodash.sortedLastIndex = sortedLastIndex;
                    lodash.startCase = startCase;
                    lodash.startsWith = startsWith;
                    lodash.sum = sum;
                    lodash.template = template;
                    lodash.trim = trim;
                    lodash.trimLeft = trimLeft;
                    lodash.trimRight = trimRight;
                    lodash.trunc = trunc;
                    lodash.unescape = unescape;
                    lodash.uniqueId = uniqueId;
                    lodash.words = words;
                    lodash.all = every;
                    lodash.any = some;
                    lodash.contains = includes;
                    lodash.detect = find;
                    lodash.foldl = reduce;
                    lodash.foldr = reduceRight;
                    lodash.head = first;
                    lodash.include = includes;
                    lodash.inject = reduce;
                    mixin(lodash, function() {
                        var source = {};
                        baseForOwn(lodash, function(func, methodName) {
                            if (!lodash.prototype[methodName]) {
                                source[methodName] = func;
                            }
                        });
                        return source;
                    }(), false);
                    lodash.sample = sample;
                    lodash.prototype.sample = function(n) {
                        if (!this.__chain__ && n == null) {
                            return sample(this.value());
                        }
                        return this.thru(function(value) {
                            return sample(value, n);
                        });
                    };
                    lodash.VERSION = VERSION;
                    arrayEach([ "bind", "bindKey", "curry", "curryRight", "partial", "partialRight" ], function(methodName) {
                        lodash[methodName].placeholder = lodash;
                    });
                    arrayEach([ "dropWhile", "filter", "map", "takeWhile" ], function(methodName, type) {
                        var isFilter = type != LAZY_MAP_FLAG, isDropWhile = type == LAZY_DROP_WHILE_FLAG;
                        LazyWrapper.prototype[methodName] = function(iteratee, thisArg) {
                            var filtered = this.__filtered__, result = filtered && isDropWhile ? new LazyWrapper(this) : this.clone(), iteratees = result.__iteratees__ || (result.__iteratees__ = []);
                            iteratees.push({
                                done: false,
                                count: 0,
                                index: 0,
                                iteratee: getCallback(iteratee, thisArg, 1),
                                limit: -1,
                                type: type
                            });
                            result.__filtered__ = filtered || isFilter;
                            return result;
                        };
                    });
                    arrayEach([ "drop", "take" ], function(methodName, index) {
                        var whileName = methodName + "While";
                        LazyWrapper.prototype[methodName] = function(n) {
                            var filtered = this.__filtered__, result = filtered && !index ? this.dropWhile() : this.clone();
                            n = n == null ? 1 : nativeMax(floor(n) || 0, 0);
                            if (filtered) {
                                if (index) {
                                    result.__takeCount__ = nativeMin(result.__takeCount__, n);
                                } else {
                                    last(result.__iteratees__).limit = n;
                                }
                            } else {
                                var views = result.__views__ || (result.__views__ = []);
                                views.push({
                                    size: n,
                                    type: methodName + (result.__dir__ < 0 ? "Right" : "")
                                });
                            }
                            return result;
                        };
                        LazyWrapper.prototype[methodName + "Right"] = function(n) {
                            return this.reverse()[methodName](n).reverse();
                        };
                        LazyWrapper.prototype[methodName + "RightWhile"] = function(predicate, thisArg) {
                            return this.reverse()[whileName](predicate, thisArg).reverse();
                        };
                    });
                    arrayEach([ "first", "last" ], function(methodName, index) {
                        var takeName = "take" + (index ? "Right" : "");
                        LazyWrapper.prototype[methodName] = function() {
                            return this[takeName](1).value()[0];
                        };
                    });
                    arrayEach([ "initial", "rest" ], function(methodName, index) {
                        var dropName = "drop" + (index ? "" : "Right");
                        LazyWrapper.prototype[methodName] = function() {
                            return this[dropName](1);
                        };
                    });
                    arrayEach([ "pluck", "where" ], function(methodName, index) {
                        var operationName = index ? "filter" : "map", createCallback = index ? baseMatches : baseProperty;
                        LazyWrapper.prototype[methodName] = function(value) {
                            return this[operationName](createCallback(value));
                        };
                    });
                    LazyWrapper.prototype.compact = function() {
                        return this.filter(identity);
                    };
                    LazyWrapper.prototype.reject = function(predicate, thisArg) {
                        predicate = getCallback(predicate, thisArg, 1);
                        return this.filter(function(value) {
                            return !predicate(value);
                        });
                    };
                    LazyWrapper.prototype.slice = function(start, end) {
                        start = start == null ? 0 : +start || 0;
                        var result = start < 0 ? this.takeRight(-start) : this.drop(start);
                        if (typeof end != "undefined") {
                            end = +end || 0;
                            result = end < 0 ? result.dropRight(-end) : result.take(end - start);
                        }
                        return result;
                    };
                    LazyWrapper.prototype.toArray = function() {
                        return this.drop(0);
                    };
                    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
                        var lodashFunc = lodash[methodName];
                        if (!lodashFunc) {
                            return;
                        }
                        var checkIteratee = /^(?:filter|map|reject)|While$/.test(methodName), retUnwrapped = /^(?:first|last)$/.test(methodName);
                        lodash.prototype[methodName] = function() {
                            var args = arguments, length = args.length, chainAll = this.__chain__, value = this.__wrapped__, isHybrid = !!this.__actions__.length, isLazy = value instanceof LazyWrapper, iteratee = args[0], useLazy = isLazy || isArray(value);
                            if (useLazy && checkIteratee && typeof iteratee == "function" && iteratee.length != 1) {
                                isLazy = useLazy = false;
                            }
                            var onlyLazy = isLazy && !isHybrid;
                            if (retUnwrapped && !chainAll) {
                                return onlyLazy ? func.call(value) : lodashFunc.call(lodash, this.value());
                            }
                            var interceptor = function(value) {
                                var otherArgs = [ value ];
                                push.apply(otherArgs, args);
                                return lodashFunc.apply(lodash, otherArgs);
                            };
                            if (useLazy) {
                                var wrapper = onlyLazy ? value : new LazyWrapper(this), result = func.apply(wrapper, args);
                                if (!retUnwrapped && (isHybrid || result.__actions__)) {
                                    var actions = result.__actions__ || (result.__actions__ = []);
                                    actions.push({
                                        func: thru,
                                        args: [ interceptor ],
                                        thisArg: lodash
                                    });
                                }
                                return new LodashWrapper(result, chainAll);
                            }
                            return this.thru(interceptor);
                        };
                    });
                    arrayEach([ "concat", "join", "pop", "push", "replace", "shift", "sort", "splice", "split", "unshift" ], function(methodName) {
                        var func = (/^(?:replace|split)$/.test(methodName) ? stringProto : arrayProto)[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:join|pop|replace|shift)$/.test(methodName);
                        lodash.prototype[methodName] = function() {
                            var args = arguments;
                            if (retUnwrapped && !this.__chain__) {
                                return func.apply(this.value(), args);
                            }
                            return this[chainName](function(value) {
                                return func.apply(value, args);
                            });
                        };
                    });
                    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
                        var lodashFunc = lodash[methodName];
                        if (lodashFunc) {
                            var key = lodashFunc.name, names = realNames[key] || (realNames[key] = []);
                            names.push({
                                name: methodName,
                                func: lodashFunc
                            });
                        }
                    });
                    realNames[createHybridWrapper(null, BIND_KEY_FLAG).name] = [ {
                        name: "wrapper",
                        func: null
                    } ];
                    LazyWrapper.prototype.clone = lazyClone;
                    LazyWrapper.prototype.reverse = lazyReverse;
                    LazyWrapper.prototype.value = lazyValue;
                    lodash.prototype.chain = wrapperChain;
                    lodash.prototype.commit = wrapperCommit;
                    lodash.prototype.plant = wrapperPlant;
                    lodash.prototype.reverse = wrapperReverse;
                    lodash.prototype.toString = wrapperToString;
                    lodash.prototype.run = lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
                    lodash.prototype.collect = lodash.prototype.map;
                    lodash.prototype.head = lodash.prototype.first;
                    lodash.prototype.select = lodash.prototype.filter;
                    lodash.prototype.tail = lodash.prototype.rest;
                    return lodash;
                }
                var _ = runInContext();
                if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
                    root._ = _;
                    define(function() {
                        return _;
                    });
                } else if (freeExports && freeModule) {
                    if (moduleExports) {
                        (freeModule.exports = _)._ = _;
                    } else {
                        freeExports._ = _;
                    }
                } else {
                    root._ = _;
                }
            }).call(this);
        }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, {} ],
    78: [ function(require, module, exports) {
        (function(root, factory) {
            if (typeof module === "object" && module.exports) {
                module.exports = function(_) {
                    _ = _ || require("underscore");
                    return factory(_);
                };
            } else if (typeof define === "function" && define.amd) {
                define([ "underscore" ], function(_) {
                    return factory(_, root);
                });
            } else {
                root.machina = factory(root._, root);
            }
        })(this, function(_, global, undefined) {
            var slice = [].slice;
            var NEXT_TRANSITION = "transition";
            var NEXT_HANDLER = "handler";
            var HANDLING = "handling";
            var HANDLED = "handled";
            var NO_HANDLER = "nohandler";
            var TRANSITION = "transition";
            var INVALID_STATE = "invalidstate";
            var DEFERRED = "deferred";
            var NEW_FSM = "newfsm";
            var utils = {
                makeFsmNamespace: function() {
                    var machinaCount = 0;
                    return function() {
                        return "fsm." + machinaCount++;
                    };
                }(),
                getDefaultOptions: function() {
                    return {
                        initialState: "uninitialized",
                        eventListeners: {
                            "*": []
                        },
                        states: {},
                        eventQueue: [],
                        namespace: utils.makeFsmNamespace(),
                        targetReplayState: "",
                        state: undefined,
                        priorState: undefined,
                        _priorAction: "",
                        _currentAction: ""
                    };
                }
            };
            if (!_.deepExtend) {
                var behavior = {
                    "*": function(obj, sourcePropKey, sourcePropVal) {
                        obj[sourcePropKey] = sourcePropVal;
                    },
                    object: function(obj, sourcePropKey, sourcePropVal) {
                        obj[sourcePropKey] = deepExtend({}, obj[sourcePropKey] || {}, sourcePropVal);
                    },
                    array: function(obj, sourcePropKey, sourcePropVal) {
                        obj[sourcePropKey] = [];
                        _.each(sourcePropVal, function(item, idx) {
                            behavior[getHandlerName(item)](obj[sourcePropKey], idx, item);
                        }, this);
                    }
                }, getActualType = function(val) {
                    if (_.isArray(val)) {
                        return "array";
                    }
                    if (_.isDate(val)) {
                        return "date";
                    }
                    if (_.isRegExp(val)) {
                        return "regex";
                    }
                    return typeof val;
                }, getHandlerName = function(val) {
                    var propType = getActualType(val);
                    return behavior[propType] ? propType : "*";
                }, deepExtend = function(obj) {
                    _.each(slice.call(arguments, 1), function(source) {
                        _.each(source, function(sourcePropVal, sourcePropKey) {
                            behavior[getHandlerName(sourcePropVal)](obj, sourcePropKey, sourcePropVal);
                        });
                    });
                    return obj;
                };
                _.mixin({
                    deepExtend: deepExtend
                });
            }
            var Fsm = function(options) {
                _.extend(this, options);
                _.defaults(this, utils.getDefaultOptions());
                this.initialize.apply(this, arguments);
                machina.emit(NEW_FSM, this);
                if (this.initialState) {
                    this.transition(this.initialState);
                }
            };
            _.extend(Fsm.prototype, {
                initialize: function() {},
                emit: function(eventName) {
                    var args = arguments;
                    if (this.eventListeners["*"]) {
                        _.each(this.eventListeners["*"], function(callback) {
                            try {
                                callback.apply(this, slice.call(args, 0));
                            } catch (exception) {
                                if (console && typeof console.log !== "undefined") {
                                    console.log(exception.toString());
                                }
                            }
                        }, this);
                    }
                    if (this.eventListeners[eventName]) {
                        _.each(this.eventListeners[eventName], function(callback) {
                            try {
                                callback.apply(this, slice.call(args, 1));
                            } catch (exception) {
                                if (console && typeof console.log !== "undefined") {
                                    console.log(exception.toString());
                                }
                            }
                        }, this);
                    }
                },
                handle: function(inputType) {
                    if (!this.inExitHandler) {
                        var states = this.states, current = this.state, args = slice.call(arguments, 0), handlerName, handler, catchAll, action;
                        this.currentActionArgs = args;
                        if (states[current][inputType] || states[current]["*"] || this["*"]) {
                            handlerName = states[current][inputType] ? inputType : "*";
                            catchAll = handlerName === "*";
                            if (states[current][handlerName]) {
                                handler = states[current][handlerName];
                                action = current + "." + handlerName;
                            } else {
                                handler = this["*"];
                                action = "*";
                            }
                            if (!this._currentAction) this._currentAction = action;
                            this.emit.call(this, HANDLING, {
                                inputType: inputType,
                                args: args.slice(1)
                            });
                            if (_.isFunction(handler)) handler = handler.apply(this, catchAll ? args : args.slice(1));
                            if (_.isString(handler)) this.transition(handler);
                            this.emit.call(this, HANDLED, {
                                inputType: inputType,
                                args: args.slice(1)
                            });
                            this._priorAction = this._currentAction;
                            this._currentAction = "";
                            this.processQueue(NEXT_HANDLER);
                        } else {
                            this.emit.call(this, NO_HANDLER, {
                                inputType: inputType,
                                args: args.slice(1)
                            });
                        }
                        this.currentActionArgs = undefined;
                    }
                },
                transition: function(newState) {
                    if (!this.inExitHandler && newState !== this.state) {
                        var curState = this.state;
                        if (this.states[newState]) {
                            if (this.states[curState] && this.states[curState]._onExit) {
                                this.inExitHandler = true;
                                this.states[curState]._onExit.call(this);
                                this.inExitHandler = false;
                            }
                            this.targetReplayState = newState;
                            this.priorState = curState;
                            this.state = newState;
                            this.emit.call(this, TRANSITION, {
                                fromState: this.priorState,
                                action: this._currentAction,
                                toState: newState
                            });
                            if (this.states[newState]._onEnter) {
                                this.states[newState]._onEnter.call(this);
                            }
                            if (this.targetReplayState === newState) {
                                this.processQueue(NEXT_TRANSITION);
                            }
                            return;
                        }
                        this.emit.call(this, INVALID_STATE, {
                            state: this.state,
                            attemptedState: newState
                        });
                    }
                },
                processQueue: function(type) {
                    var filterFn = type === NEXT_TRANSITION ? function(item) {
                        return item.type === NEXT_TRANSITION && (!item.untilState || item.untilState === this.state);
                    } : function(item) {
                        return item.type === NEXT_HANDLER;
                    };
                    var toProcess = _.filter(this.eventQueue, filterFn, this);
                    this.eventQueue = _.difference(this.eventQueue, toProcess);
                    _.each(toProcess, function(item) {
                        this.handle.apply(this, item.args);
                    }, this);
                },
                clearQueue: function(type, name) {
                    if (!type) {
                        this.eventQueue = [];
                    } else {
                        var filter;
                        if (type === NEXT_TRANSITION) {
                            filter = function(evnt) {
                                return evnt.type === NEXT_TRANSITION && (name ? evnt.untilState === name : true);
                            };
                        } else if (type === NEXT_HANDLER) {
                            filter = function(evnt) {
                                return evnt.type === NEXT_HANDLER;
                            };
                        }
                        this.eventQueue = _.filter(this.eventQueue, filter);
                    }
                },
                deferUntilTransition: function(stateName) {
                    if (this.currentActionArgs) {
                        var queued = {
                            type: NEXT_TRANSITION,
                            untilState: stateName,
                            args: this.currentActionArgs
                        };
                        this.eventQueue.push(queued);
                        this.emit.call(this, DEFERRED, {
                            state: this.state,
                            queuedArgs: queued
                        });
                    }
                },
                deferUntilNextHandler: function() {
                    if (this.currentActionArgs) {
                        var queued = {
                            type: NEXT_HANDLER,
                            args: this.currentActionArgs
                        };
                        this.eventQueue.push(queued);
                        this.emit.call(this, DEFERRED, {
                            state: this.state,
                            queuedArgs: queued
                        });
                    }
                },
                on: function(eventName, callback) {
                    var self = this;
                    if (!self.eventListeners[eventName]) {
                        self.eventListeners[eventName] = [];
                    }
                    self.eventListeners[eventName].push(callback);
                    return {
                        eventName: eventName,
                        callback: callback,
                        off: function() {
                            self.off(eventName, callback);
                        }
                    };
                },
                off: function(eventName, callback) {
                    if (!eventName) {
                        this.eventListeners = {};
                    } else {
                        if (this.eventListeners[eventName]) {
                            if (callback) {
                                this.eventListeners[eventName] = _.without(this.eventListeners[eventName], callback);
                            } else {
                                this.eventListeners[eventName] = [];
                            }
                        }
                    }
                }
            });
            Fsm.prototype.trigger = Fsm.prototype.emit;
            var ctor = function() {};
            var inherits = function(parent, protoProps, staticProps) {
                var fsm;
                if (protoProps && protoProps.hasOwnProperty("constructor")) {
                    fsm = protoProps.constructor;
                } else {
                    fsm = function() {
                        parent.apply(this, arguments);
                    };
                }
                _.deepExtend(fsm, parent);
                ctor.prototype = parent.prototype;
                fsm.prototype = new ctor();
                if (protoProps) {
                    _.deepExtend(fsm.prototype, protoProps);
                }
                if (staticProps) {
                    _.deepExtend(fsm, staticProps);
                }
                fsm.prototype.constructor = fsm;
                fsm.__super__ = parent.prototype;
                return fsm;
            };
            Fsm.extend = function(protoProps, classProps) {
                var fsm = inherits(this, protoProps, classProps);
                fsm.extend = this.extend;
                return fsm;
            };
            var machina = {
                Fsm: Fsm,
                utils: utils,
                on: function(eventName, callback) {
                    if (!this.eventListeners[eventName]) {
                        this.eventListeners[eventName] = [];
                    }
                    this.eventListeners[eventName].push(callback);
                    return callback;
                },
                off: function(eventName, callback) {
                    if (this.eventListeners[eventName]) {
                        this.eventListeners[eventName] = _.without(this.eventListeners[eventName], callback);
                    }
                },
                trigger: function(eventName) {
                    var i = 0, len, args = arguments, listeners = this.eventListeners[eventName] || [];
                    if (listeners && listeners.length) {
                        _.each(listeners, function(callback) {
                            callback.apply(null, slice.call(args, 1));
                        });
                    }
                },
                eventListeners: {
                    newFsm: []
                }
            };
            machina.emit = machina.trigger;
            return machina;
        });
    }, {
        underscore: 79
    } ],
    79: [ function(require, module, exports) {
        (function() {
            var root = this;
            var previousUnderscore = root._;
            var breaker = {};
            var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;
            var push = ArrayProto.push, slice = ArrayProto.slice, concat = ArrayProto.concat, toString = ObjProto.toString, hasOwnProperty = ObjProto.hasOwnProperty;
            var nativeForEach = ArrayProto.forEach, nativeMap = ArrayProto.map, nativeReduce = ArrayProto.reduce, nativeReduceRight = ArrayProto.reduceRight, nativeFilter = ArrayProto.filter, nativeEvery = ArrayProto.every, nativeSome = ArrayProto.some, nativeIndexOf = ArrayProto.indexOf, nativeLastIndexOf = ArrayProto.lastIndexOf, nativeIsArray = Array.isArray, nativeKeys = Object.keys, nativeBind = FuncProto.bind;
            var _ = function(obj) {
                if (obj instanceof _) return obj;
                if (!(this instanceof _)) return new _(obj);
                this._wrapped = obj;
            };
            if (typeof exports !== "undefined") {
                if (typeof module !== "undefined" && module.exports) {
                    exports = module.exports = _;
                }
                exports._ = _;
            } else {
                root._ = _;
            }
            _.VERSION = "1.5.2";
            var each = _.each = _.forEach = function(obj, iterator, context) {
                if (obj == null) return;
                if (nativeForEach && obj.forEach === nativeForEach) {
                    obj.forEach(iterator, context);
                } else if (obj.length === +obj.length) {
                    for (var i = 0, length = obj.length; i < length; i++) {
                        if (iterator.call(context, obj[i], i, obj) === breaker) return;
                    }
                } else {
                    var keys = _.keys(obj);
                    for (var i = 0, length = keys.length; i < length; i++) {
                        if (iterator.call(context, obj[keys[i]], keys[i], obj) === breaker) return;
                    }
                }
            };
            _.map = _.collect = function(obj, iterator, context) {
                var results = [];
                if (obj == null) return results;
                if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);
                each(obj, function(value, index, list) {
                    results.push(iterator.call(context, value, index, list));
                });
                return results;
            };
            var reduceError = "Reduce of empty array with no initial value";
            _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {
                var initial = arguments.length > 2;
                if (obj == null) obj = [];
                if (nativeReduce && obj.reduce === nativeReduce) {
                    if (context) iterator = _.bind(iterator, context);
                    return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);
                }
                each(obj, function(value, index, list) {
                    if (!initial) {
                        memo = value;
                        initial = true;
                    } else {
                        memo = iterator.call(context, memo, value, index, list);
                    }
                });
                if (!initial) throw new TypeError(reduceError);
                return memo;
            };
            _.reduceRight = _.foldr = function(obj, iterator, memo, context) {
                var initial = arguments.length > 2;
                if (obj == null) obj = [];
                if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {
                    if (context) iterator = _.bind(iterator, context);
                    return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);
                }
                var length = obj.length;
                if (length !== +length) {
                    var keys = _.keys(obj);
                    length = keys.length;
                }
                each(obj, function(value, index, list) {
                    index = keys ? keys[--length] : --length;
                    if (!initial) {
                        memo = obj[index];
                        initial = true;
                    } else {
                        memo = iterator.call(context, memo, obj[index], index, list);
                    }
                });
                if (!initial) throw new TypeError(reduceError);
                return memo;
            };
            _.find = _.detect = function(obj, iterator, context) {
                var result;
                any(obj, function(value, index, list) {
                    if (iterator.call(context, value, index, list)) {
                        result = value;
                        return true;
                    }
                });
                return result;
            };
            _.filter = _.select = function(obj, iterator, context) {
                var results = [];
                if (obj == null) return results;
                if (nativeFilter && obj.filter === nativeFilter) return obj.filter(iterator, context);
                each(obj, function(value, index, list) {
                    if (iterator.call(context, value, index, list)) results.push(value);
                });
                return results;
            };
            _.reject = function(obj, iterator, context) {
                return _.filter(obj, function(value, index, list) {
                    return !iterator.call(context, value, index, list);
                }, context);
            };
            _.every = _.all = function(obj, iterator, context) {
                iterator || (iterator = _.identity);
                var result = true;
                if (obj == null) return result;
                if (nativeEvery && obj.every === nativeEvery) return obj.every(iterator, context);
                each(obj, function(value, index, list) {
                    if (!(result = result && iterator.call(context, value, index, list))) return breaker;
                });
                return !!result;
            };
            var any = _.some = _.any = function(obj, iterator, context) {
                iterator || (iterator = _.identity);
                var result = false;
                if (obj == null) return result;
                if (nativeSome && obj.some === nativeSome) return obj.some(iterator, context);
                each(obj, function(value, index, list) {
                    if (result || (result = iterator.call(context, value, index, list))) return breaker;
                });
                return !!result;
            };
            _.contains = _.include = function(obj, target) {
                if (obj == null) return false;
                if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;
                return any(obj, function(value) {
                    return value === target;
                });
            };
            _.invoke = function(obj, method) {
                var args = slice.call(arguments, 2);
                var isFunc = _.isFunction(method);
                return _.map(obj, function(value) {
                    return (isFunc ? method : value[method]).apply(value, args);
                });
            };
            _.pluck = function(obj, key) {
                return _.map(obj, function(value) {
                    return value[key];
                });
            };
            _.where = function(obj, attrs, first) {
                if (_.isEmpty(attrs)) return first ? void 0 : [];
                return _[first ? "find" : "filter"](obj, function(value) {
                    for (var key in attrs) {
                        if (attrs[key] !== value[key]) return false;
                    }
                    return true;
                });
            };
            _.findWhere = function(obj, attrs) {
                return _.where(obj, attrs, true);
            };
            _.max = function(obj, iterator, context) {
                if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
                    return Math.max.apply(Math, obj);
                }
                if (!iterator && _.isEmpty(obj)) return -Infinity;
                var result = {
                    computed: -Infinity,
                    value: -Infinity
                };
                each(obj, function(value, index, list) {
                    var computed = iterator ? iterator.call(context, value, index, list) : value;
                    computed > result.computed && (result = {
                        value: value,
                        computed: computed
                    });
                });
                return result.value;
            };
            _.min = function(obj, iterator, context) {
                if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
                    return Math.min.apply(Math, obj);
                }
                if (!iterator && _.isEmpty(obj)) return Infinity;
                var result = {
                    computed: Infinity,
                    value: Infinity
                };
                each(obj, function(value, index, list) {
                    var computed = iterator ? iterator.call(context, value, index, list) : value;
                    computed < result.computed && (result = {
                        value: value,
                        computed: computed
                    });
                });
                return result.value;
            };
            _.shuffle = function(obj) {
                var rand;
                var index = 0;
                var shuffled = [];
                each(obj, function(value) {
                    rand = _.random(index++);
                    shuffled[index - 1] = shuffled[rand];
                    shuffled[rand] = value;
                });
                return shuffled;
            };
            _.sample = function(obj, n, guard) {
                if (arguments.length < 2 || guard) {
                    return obj[_.random(obj.length - 1)];
                }
                return _.shuffle(obj).slice(0, Math.max(0, n));
            };
            var lookupIterator = function(value) {
                return _.isFunction(value) ? value : function(obj) {
                    return obj[value];
                };
            };
            _.sortBy = function(obj, value, context) {
                var iterator = lookupIterator(value);
                return _.pluck(_.map(obj, function(value, index, list) {
                    return {
                        value: value,
                        index: index,
                        criteria: iterator.call(context, value, index, list)
                    };
                }).sort(function(left, right) {
                    var a = left.criteria;
                    var b = right.criteria;
                    if (a !== b) {
                        if (a > b || a === void 0) return 1;
                        if (a < b || b === void 0) return -1;
                    }
                    return left.index - right.index;
                }), "value");
            };
            var group = function(behavior) {
                return function(obj, value, context) {
                    var result = {};
                    var iterator = value == null ? _.identity : lookupIterator(value);
                    each(obj, function(value, index) {
                        var key = iterator.call(context, value, index, obj);
                        behavior(result, key, value);
                    });
                    return result;
                };
            };
            _.groupBy = group(function(result, key, value) {
                (_.has(result, key) ? result[key] : result[key] = []).push(value);
            });
            _.indexBy = group(function(result, key, value) {
                result[key] = value;
            });
            _.countBy = group(function(result, key) {
                _.has(result, key) ? result[key]++ : result[key] = 1;
            });
            _.sortedIndex = function(array, obj, iterator, context) {
                iterator = iterator == null ? _.identity : lookupIterator(iterator);
                var value = iterator.call(context, obj);
                var low = 0, high = array.length;
                while (low < high) {
                    var mid = low + high >>> 1;
                    iterator.call(context, array[mid]) < value ? low = mid + 1 : high = mid;
                }
                return low;
            };
            _.toArray = function(obj) {
                if (!obj) return [];
                if (_.isArray(obj)) return slice.call(obj);
                if (obj.length === +obj.length) return _.map(obj, _.identity);
                return _.values(obj);
            };
            _.size = function(obj) {
                if (obj == null) return 0;
                return obj.length === +obj.length ? obj.length : _.keys(obj).length;
            };
            _.first = _.head = _.take = function(array, n, guard) {
                if (array == null) return void 0;
                return n == null || guard ? array[0] : slice.call(array, 0, n);
            };
            _.initial = function(array, n, guard) {
                return slice.call(array, 0, array.length - (n == null || guard ? 1 : n));
            };
            _.last = function(array, n, guard) {
                if (array == null) return void 0;
                if (n == null || guard) {
                    return array[array.length - 1];
                } else {
                    return slice.call(array, Math.max(array.length - n, 0));
                }
            };
            _.rest = _.tail = _.drop = function(array, n, guard) {
                return slice.call(array, n == null || guard ? 1 : n);
            };
            _.compact = function(array) {
                return _.filter(array, _.identity);
            };
            var flatten = function(input, shallow, output) {
                if (shallow && _.every(input, _.isArray)) {
                    return concat.apply(output, input);
                }
                each(input, function(value) {
                    if (_.isArray(value) || _.isArguments(value)) {
                        shallow ? push.apply(output, value) : flatten(value, shallow, output);
                    } else {
                        output.push(value);
                    }
                });
                return output;
            };
            _.flatten = function(array, shallow) {
                return flatten(array, shallow, []);
            };
            _.without = function(array) {
                return _.difference(array, slice.call(arguments, 1));
            };
            _.uniq = _.unique = function(array, isSorted, iterator, context) {
                if (_.isFunction(isSorted)) {
                    context = iterator;
                    iterator = isSorted;
                    isSorted = false;
                }
                var initial = iterator ? _.map(array, iterator, context) : array;
                var results = [];
                var seen = [];
                each(initial, function(value, index) {
                    if (isSorted ? !index || seen[seen.length - 1] !== value : !_.contains(seen, value)) {
                        seen.push(value);
                        results.push(array[index]);
                    }
                });
                return results;
            };
            _.union = function() {
                return _.uniq(_.flatten(arguments, true));
            };
            _.intersection = function(array) {
                var rest = slice.call(arguments, 1);
                return _.filter(_.uniq(array), function(item) {
                    return _.every(rest, function(other) {
                        return _.indexOf(other, item) >= 0;
                    });
                });
            };
            _.difference = function(array) {
                var rest = concat.apply(ArrayProto, slice.call(arguments, 1));
                return _.filter(array, function(value) {
                    return !_.contains(rest, value);
                });
            };
            _.zip = function() {
                var length = _.max(_.pluck(arguments, "length").concat(0));
                var results = new Array(length);
                for (var i = 0; i < length; i++) {
                    results[i] = _.pluck(arguments, "" + i);
                }
                return results;
            };
            _.object = function(list, values) {
                if (list == null) return {};
                var result = {};
                for (var i = 0, length = list.length; i < length; i++) {
                    if (values) {
                        result[list[i]] = values[i];
                    } else {
                        result[list[i][0]] = list[i][1];
                    }
                }
                return result;
            };
            _.indexOf = function(array, item, isSorted) {
                if (array == null) return -1;
                var i = 0, length = array.length;
                if (isSorted) {
                    if (typeof isSorted == "number") {
                        i = isSorted < 0 ? Math.max(0, length + isSorted) : isSorted;
                    } else {
                        i = _.sortedIndex(array, item);
                        return array[i] === item ? i : -1;
                    }
                }
                if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item, isSorted);
                for (;i < length; i++) if (array[i] === item) return i;
                return -1;
            };
            _.lastIndexOf = function(array, item, from) {
                if (array == null) return -1;
                var hasIndex = from != null;
                if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) {
                    return hasIndex ? array.lastIndexOf(item, from) : array.lastIndexOf(item);
                }
                var i = hasIndex ? from : array.length;
                while (i--) if (array[i] === item) return i;
                return -1;
            };
            _.range = function(start, stop, step) {
                if (arguments.length <= 1) {
                    stop = start || 0;
                    start = 0;
                }
                step = arguments[2] || 1;
                var length = Math.max(Math.ceil((stop - start) / step), 0);
                var idx = 0;
                var range = new Array(length);
                while (idx < length) {
                    range[idx++] = start;
                    start += step;
                }
                return range;
            };
            var ctor = function() {};
            _.bind = function(func, context) {
                var args, bound;
                if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
                if (!_.isFunction(func)) throw new TypeError();
                args = slice.call(arguments, 2);
                return bound = function() {
                    if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));
                    ctor.prototype = func.prototype;
                    var self = new ctor();
                    ctor.prototype = null;
                    var result = func.apply(self, args.concat(slice.call(arguments)));
                    if (Object(result) === result) return result;
                    return self;
                };
            };
            _.partial = function(func) {
                var args = slice.call(arguments, 1);
                return function() {
                    return func.apply(this, args.concat(slice.call(arguments)));
                };
            };
            _.bindAll = function(obj) {
                var funcs = slice.call(arguments, 1);
                if (funcs.length === 0) throw new Error("bindAll must be passed function names");
                each(funcs, function(f) {
                    obj[f] = _.bind(obj[f], obj);
                });
                return obj;
            };
            _.memoize = function(func, hasher) {
                var memo = {};
                hasher || (hasher = _.identity);
                return function() {
                    var key = hasher.apply(this, arguments);
                    return _.has(memo, key) ? memo[key] : memo[key] = func.apply(this, arguments);
                };
            };
            _.delay = function(func, wait) {
                var args = slice.call(arguments, 2);
                return setTimeout(function() {
                    return func.apply(null, args);
                }, wait);
            };
            _.defer = function(func) {
                return _.delay.apply(_, [ func, 1 ].concat(slice.call(arguments, 1)));
            };
            _.throttle = function(func, wait, options) {
                var context, args, result;
                var timeout = null;
                var previous = 0;
                options || (options = {});
                var later = function() {
                    previous = options.leading === false ? 0 : new Date();
                    timeout = null;
                    result = func.apply(context, args);
                };
                return function() {
                    var now = new Date();
                    if (!previous && options.leading === false) previous = now;
                    var remaining = wait - (now - previous);
                    context = this;
                    args = arguments;
                    if (remaining <= 0) {
                        clearTimeout(timeout);
                        timeout = null;
                        previous = now;
                        result = func.apply(context, args);
                    } else if (!timeout && options.trailing !== false) {
                        timeout = setTimeout(later, remaining);
                    }
                    return result;
                };
            };
            _.debounce = function(func, wait, immediate) {
                var timeout, args, context, timestamp, result;
                return function() {
                    context = this;
                    args = arguments;
                    timestamp = new Date();
                    var later = function() {
                        var last = new Date() - timestamp;
                        if (last < wait) {
                            timeout = setTimeout(later, wait - last);
                        } else {
                            timeout = null;
                            if (!immediate) result = func.apply(context, args);
                        }
                    };
                    var callNow = immediate && !timeout;
                    if (!timeout) {
                        timeout = setTimeout(later, wait);
                    }
                    if (callNow) result = func.apply(context, args);
                    return result;
                };
            };
            _.once = function(func) {
                var ran = false, memo;
                return function() {
                    if (ran) return memo;
                    ran = true;
                    memo = func.apply(this, arguments);
                    func = null;
                    return memo;
                };
            };
            _.wrap = function(func, wrapper) {
                return function() {
                    var args = [ func ];
                    push.apply(args, arguments);
                    return wrapper.apply(this, args);
                };
            };
            _.compose = function() {
                var funcs = arguments;
                return function() {
                    var args = arguments;
                    for (var i = funcs.length - 1; i >= 0; i--) {
                        args = [ funcs[i].apply(this, args) ];
                    }
                    return args[0];
                };
            };
            _.after = function(times, func) {
                return function() {
                    if (--times < 1) {
                        return func.apply(this, arguments);
                    }
                };
            };
            _.keys = nativeKeys || function(obj) {
                if (obj !== Object(obj)) throw new TypeError("Invalid object");
                var keys = [];
                for (var key in obj) if (_.has(obj, key)) keys.push(key);
                return keys;
            };
            _.values = function(obj) {
                var keys = _.keys(obj);
                var length = keys.length;
                var values = new Array(length);
                for (var i = 0; i < length; i++) {
                    values[i] = obj[keys[i]];
                }
                return values;
            };
            _.pairs = function(obj) {
                var keys = _.keys(obj);
                var length = keys.length;
                var pairs = new Array(length);
                for (var i = 0; i < length; i++) {
                    pairs[i] = [ keys[i], obj[keys[i]] ];
                }
                return pairs;
            };
            _.invert = function(obj) {
                var result = {};
                var keys = _.keys(obj);
                for (var i = 0, length = keys.length; i < length; i++) {
                    result[obj[keys[i]]] = keys[i];
                }
                return result;
            };
            _.functions = _.methods = function(obj) {
                var names = [];
                for (var key in obj) {
                    if (_.isFunction(obj[key])) names.push(key);
                }
                return names.sort();
            };
            _.extend = function(obj) {
                each(slice.call(arguments, 1), function(source) {
                    if (source) {
                        for (var prop in source) {
                            obj[prop] = source[prop];
                        }
                    }
                });
                return obj;
            };
            _.pick = function(obj) {
                var copy = {};
                var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
                each(keys, function(key) {
                    if (key in obj) copy[key] = obj[key];
                });
                return copy;
            };
            _.omit = function(obj) {
                var copy = {};
                var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
                for (var key in obj) {
                    if (!_.contains(keys, key)) copy[key] = obj[key];
                }
                return copy;
            };
            _.defaults = function(obj) {
                each(slice.call(arguments, 1), function(source) {
                    if (source) {
                        for (var prop in source) {
                            if (obj[prop] === void 0) obj[prop] = source[prop];
                        }
                    }
                });
                return obj;
            };
            _.clone = function(obj) {
                if (!_.isObject(obj)) return obj;
                return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
            };
            _.tap = function(obj, interceptor) {
                interceptor(obj);
                return obj;
            };
            var eq = function(a, b, aStack, bStack) {
                if (a === b) return a !== 0 || 1 / a == 1 / b;
                if (a == null || b == null) return a === b;
                if (a instanceof _) a = a._wrapped;
                if (b instanceof _) b = b._wrapped;
                var className = toString.call(a);
                if (className != toString.call(b)) return false;
                switch (className) {
                  case "[object String]":
                    return a == String(b);

                  case "[object Number]":
                    return a != +a ? b != +b : a == 0 ? 1 / a == 1 / b : a == +b;

                  case "[object Date]":
                  case "[object Boolean]":
                    return +a == +b;

                  case "[object RegExp]":
                    return a.source == b.source && a.global == b.global && a.multiline == b.multiline && a.ignoreCase == b.ignoreCase;
                }
                if (typeof a != "object" || typeof b != "object") return false;
                var length = aStack.length;
                while (length--) {
                    if (aStack[length] == a) return bStack[length] == b;
                }
                var aCtor = a.constructor, bCtor = b.constructor;
                if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor && _.isFunction(bCtor) && bCtor instanceof bCtor)) {
                    return false;
                }
                aStack.push(a);
                bStack.push(b);
                var size = 0, result = true;
                if (className == "[object Array]") {
                    size = a.length;
                    result = size == b.length;
                    if (result) {
                        while (size--) {
                            if (!(result = eq(a[size], b[size], aStack, bStack))) break;
                        }
                    }
                } else {
                    for (var key in a) {
                        if (_.has(a, key)) {
                            size++;
                            if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack))) break;
                        }
                    }
                    if (result) {
                        for (key in b) {
                            if (_.has(b, key) && !size--) break;
                        }
                        result = !size;
                    }
                }
                aStack.pop();
                bStack.pop();
                return result;
            };
            _.isEqual = function(a, b) {
                return eq(a, b, [], []);
            };
            _.isEmpty = function(obj) {
                if (obj == null) return true;
                if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;
                for (var key in obj) if (_.has(obj, key)) return false;
                return true;
            };
            _.isElement = function(obj) {
                return !!(obj && obj.nodeType === 1);
            };
            _.isArray = nativeIsArray || function(obj) {
                return toString.call(obj) == "[object Array]";
            };
            _.isObject = function(obj) {
                return obj === Object(obj);
            };
            each([ "Arguments", "Function", "String", "Number", "Date", "RegExp" ], function(name) {
                _["is" + name] = function(obj) {
                    return toString.call(obj) == "[object " + name + "]";
                };
            });
            if (!_.isArguments(arguments)) {
                _.isArguments = function(obj) {
                    return !!(obj && _.has(obj, "callee"));
                };
            }
            if (typeof /./ !== "function") {
                _.isFunction = function(obj) {
                    return typeof obj === "function";
                };
            }
            _.isFinite = function(obj) {
                return isFinite(obj) && !isNaN(parseFloat(obj));
            };
            _.isNaN = function(obj) {
                return _.isNumber(obj) && obj != +obj;
            };
            _.isBoolean = function(obj) {
                return obj === true || obj === false || toString.call(obj) == "[object Boolean]";
            };
            _.isNull = function(obj) {
                return obj === null;
            };
            _.isUndefined = function(obj) {
                return obj === void 0;
            };
            _.has = function(obj, key) {
                return hasOwnProperty.call(obj, key);
            };
            _.noConflict = function() {
                root._ = previousUnderscore;
                return this;
            };
            _.identity = function(value) {
                return value;
            };
            _.times = function(n, iterator, context) {
                var accum = Array(Math.max(0, n));
                for (var i = 0; i < n; i++) accum[i] = iterator.call(context, i);
                return accum;
            };
            _.random = function(min, max) {
                if (max == null) {
                    max = min;
                    min = 0;
                }
                return min + Math.floor(Math.random() * (max - min + 1));
            };
            var entityMap = {
                escape: {
                    "&": "&amp;",
                    "<": "&lt;",
                    ">": "&gt;",
                    '"': "&quot;",
                    "'": "&#x27;"
                }
            };
            entityMap.unescape = _.invert(entityMap.escape);
            var entityRegexes = {
                escape: new RegExp("[" + _.keys(entityMap.escape).join("") + "]", "g"),
                unescape: new RegExp("(" + _.keys(entityMap.unescape).join("|") + ")", "g")
            };
            _.each([ "escape", "unescape" ], function(method) {
                _[method] = function(string) {
                    if (string == null) return "";
                    return ("" + string).replace(entityRegexes[method], function(match) {
                        return entityMap[method][match];
                    });
                };
            });
            _.result = function(object, property) {
                if (object == null) return void 0;
                var value = object[property];
                return _.isFunction(value) ? value.call(object) : value;
            };
            _.mixin = function(obj) {
                each(_.functions(obj), function(name) {
                    var func = _[name] = obj[name];
                    _.prototype[name] = function() {
                        var args = [ this._wrapped ];
                        push.apply(args, arguments);
                        return result.call(this, func.apply(_, args));
                    };
                });
            };
            var idCounter = 0;
            _.uniqueId = function(prefix) {
                var id = ++idCounter + "";
                return prefix ? prefix + id : id;
            };
            _.templateSettings = {
                evaluate: /<%([\s\S]+?)%>/g,
                interpolate: /<%=([\s\S]+?)%>/g,
                escape: /<%-([\s\S]+?)%>/g
            };
            var noMatch = /(.)^/;
            var escapes = {
                "'": "'",
                "\\": "\\",
                "\r": "r",
                "\n": "n",
                "	": "t",
                "\u2028": "u2028",
                "\u2029": "u2029"
            };
            var escaper = /\\|'|\r|\n|\t|\u2028|\u2029/g;
            _.template = function(text, data, settings) {
                var render;
                settings = _.defaults({}, settings, _.templateSettings);
                var matcher = new RegExp([ (settings.escape || noMatch).source, (settings.interpolate || noMatch).source, (settings.evaluate || noMatch).source ].join("|") + "|$", "g");
                var index = 0;
                var source = "__p+='";
                text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
                    source += text.slice(index, offset).replace(escaper, function(match) {
                        return "\\" + escapes[match];
                    });
                    if (escape) {
                        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
                    }
                    if (interpolate) {
                        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
                    }
                    if (evaluate) {
                        source += "';\n" + evaluate + "\n__p+='";
                    }
                    index = offset + match.length;
                    return match;
                });
                source += "';\n";
                if (!settings.variable) source = "with(obj||{}){\n" + source + "}\n";
                source = "var __t,__p='',__j=Array.prototype.join," + "print=function(){__p+=__j.call(arguments,'');};\n" + source + "return __p;\n";
                try {
                    render = new Function(settings.variable || "obj", "_", source);
                } catch (e) {
                    e.source = source;
                    throw e;
                }
                if (data) return render(data, _);
                var template = function(data) {
                    return render.call(this, data, _);
                };
                template.source = "function(" + (settings.variable || "obj") + "){\n" + source + "}";
                return template;
            };
            _.chain = function(obj) {
                return _(obj).chain();
            };
            var result = function(obj) {
                return this._chain ? _(obj).chain() : obj;
            };
            _.mixin(_);
            each([ "pop", "push", "reverse", "shift", "sort", "splice", "unshift" ], function(name) {
                var method = ArrayProto[name];
                _.prototype[name] = function() {
                    var obj = this._wrapped;
                    method.apply(obj, arguments);
                    if ((name == "shift" || name == "splice") && obj.length === 0) delete obj[0];
                    return result.call(this, obj);
                };
            });
            each([ "concat", "join", "slice" ], function(name) {
                var method = ArrayProto[name];
                _.prototype[name] = function() {
                    return result.call(this, method.apply(this._wrapped, arguments));
                };
            });
            _.extend(_.prototype, {
                chain: function() {
                    this._chain = true;
                    return this;
                },
                value: function() {
                    return this._wrapped;
                }
            });
        }).call(this);
    }, {} ],
    80: [ function(require, module, exports) {
        "use strict";
        var fill = require("cwise/lib/wrapper")({
            args: [ "index", "array", "scalar" ],
            pre: {
                body: "{}",
                args: [],
                thisVars: [],
                localVars: []
            },
            body: {
                body: "{_inline_4_arg1_=_inline_4_arg2_.apply(void 0,_inline_4_arg0_)}",
                args: [ {
                    name: "_inline_4_arg0_",
                    lvalue: false,
                    rvalue: true,
                    count: 1
                }, {
                    name: "_inline_4_arg1_",
                    lvalue: true,
                    rvalue: false,
                    count: 1
                }, {
                    name: "_inline_4_arg2_",
                    lvalue: false,
                    rvalue: true,
                    count: 1
                } ],
                thisVars: [],
                localVars: []
            },
            post: {
                body: "{}",
                args: [],
                thisVars: [],
                localVars: []
            },
            debug: false,
            funcName: "cwise",
            blockSize: 64
        });
        module.exports = function(array, f) {
            fill(array, f);
            return array;
        };
    }, {
        "cwise/lib/wrapper": 13
    } ],
    81: [ function(require, module, exports) {
        "use strict";
        var compile = require("cwise-compiler");
        var EmptyProc = {
            body: "",
            args: [],
            thisVars: [],
            localVars: []
        };
        function fixup(x) {
            if (!x) {
                return EmptyProc;
            }
            for (var i = 0; i < x.args.length; ++i) {
                var a = x.args[i];
                if (i === 0) {
                    x.args[i] = {
                        name: a,
                        lvalue: true,
                        rvalue: !!x.rvalue,
                        count: x.count || 1
                    };
                } else {
                    x.args[i] = {
                        name: a,
                        lvalue: false,
                        rvalue: true,
                        count: 1
                    };
                }
            }
            if (!x.thisVars) {
                x.thisVars = [];
            }
            if (!x.localVars) {
                x.localVars = [];
            }
            return x;
        }
        function pcompile(user_args) {
            return compile({
                args: user_args.args,
                pre: fixup(user_args.pre),
                body: fixup(user_args.body),
                post: fixup(user_args.proc),
                funcName: user_args.funcName
            });
        }
        function makeOp(user_args) {
            var args = [];
            for (var i = 0; i < user_args.args.length; ++i) {
                args.push("a" + i);
            }
            var wrapper = new Function("P", [ "return function ", user_args.funcName, "_ndarrayops(", args.join(","), ") {P(", args.join(","), ");return a0}" ].join(""));
            return wrapper(pcompile(user_args));
        }
        var assign_ops = {
            add: "+",
            sub: "-",
            mul: "*",
            div: "/",
            mod: "%",
            band: "&",
            bor: "|",
            bxor: "^",
            lshift: "<<",
            rshift: ">>",
            rrshift: ">>>"
        };
        (function() {
            for (var id in assign_ops) {
                var op = assign_ops[id];
                exports[id] = makeOp({
                    args: [ "array", "array", "array" ],
                    body: {
                        args: [ "a", "b", "c" ],
                        body: "a=b" + op + "c"
                    },
                    funcName: id
                });
                exports[id + "eq"] = makeOp({
                    args: [ "array", "array" ],
                    body: {
                        args: [ "a", "b" ],
                        body: "a" + op + "=b"
                    },
                    rvalue: true,
                    funcName: id + "eq"
                });
                exports[id + "s"] = makeOp({
                    args: [ "array", "array", "scalar" ],
                    body: {
                        args: [ "a", "b", "s" ],
                        body: "a=b" + op + "s"
                    },
                    funcName: id + "s"
                });
                exports[id + "seq"] = makeOp({
                    args: [ "array", "scalar" ],
                    body: {
                        args: [ "a", "s" ],
                        body: "a" + op + "=s"
                    },
                    rvalue: true,
                    funcName: id + "seq"
                });
            }
        })();
        var unary_ops = {
            not: "!",
            bnot: "~",
            neg: "-",
            recip: "1.0/"
        };
        (function() {
            for (var id in unary_ops) {
                var op = unary_ops[id];
                exports[id] = makeOp({
                    args: [ "array", "array" ],
                    body: {
                        args: [ "a", "b" ],
                        body: "a=" + op + "b"
                    },
                    funcName: id
                });
                exports[id + "eq"] = makeOp({
                    args: [ "array" ],
                    body: {
                        args: [ "a" ],
                        body: "a=" + op + "a"
                    },
                    rvalue: true,
                    count: 2,
                    funcName: id + "eq"
                });
            }
        })();
        var binary_ops = {
            and: "&&",
            or: "||",
            eq: "===",
            neq: "!==",
            lt: "<",
            gt: ">",
            leq: "<=",
            geq: ">="
        };
        (function() {
            for (var id in binary_ops) {
                var op = binary_ops[id];
                exports[id] = makeOp({
                    args: [ "array", "array", "array" ],
                    body: {
                        args: [ "a", "b", "c" ],
                        body: "a=b" + op + "c"
                    },
                    funcName: id
                });
                exports[id + "s"] = makeOp({
                    args: [ "array", "array", "scalar" ],
                    body: {
                        args: [ "a", "b", "s" ],
                        body: "a=b" + op + "s"
                    },
                    funcName: id + "s"
                });
                exports[id + "eq"] = makeOp({
                    args: [ "array", "array" ],
                    body: {
                        args: [ "a", "b" ],
                        body: "a=a" + op + "b"
                    },
                    rvalue: true,
                    count: 2,
                    funcName: id + "eq"
                });
                exports[id + "seq"] = makeOp({
                    args: [ "array", "scalar" ],
                    body: {
                        args: [ "a", "s" ],
                        body: "a=a" + op + "s"
                    },
                    rvalue: true,
                    count: 2,
                    funcName: id + "seq"
                });
            }
        })();
        var math_unary = [ "abs", "acos", "asin", "atan", "ceil", "cos", "exp", "floor", "log", "round", "sin", "sqrt", "tan" ];
        (function() {
            for (var i = 0; i < math_unary.length; ++i) {
                var f = math_unary[i];
                exports[f] = makeOp({
                    args: [ "array", "array" ],
                    pre: {
                        args: [],
                        body: "this_f=Math." + f,
                        thisVars: [ "this_f" ]
                    },
                    body: {
                        args: [ "a", "b" ],
                        body: "a=this_f(b)",
                        thisVars: [ "this_f" ]
                    },
                    funcName: f
                });
                exports[f + "eq"] = makeOp({
                    args: [ "array" ],
                    pre: {
                        args: [],
                        body: "this_f=Math." + f,
                        thisVars: [ "this_f" ]
                    },
                    body: {
                        args: [ "a" ],
                        body: "a=this_f(a)",
                        thisVars: [ "this_f" ]
                    },
                    rvalue: true,
                    count: 2,
                    funcName: f + "eq"
                });
            }
        })();
        var math_comm = [ "max", "min", "atan2", "pow" ];
        (function() {
            for (var i = 0; i < math_comm.length; ++i) {
                var f = math_comm[i];
                exports[f] = makeOp({
                    args: [ "array", "array", "array" ],
                    pre: {
                        args: [],
                        body: "this_f=Math." + f,
                        thisVars: [ "this_f" ]
                    },
                    body: {
                        args: [ "a", "b", "c" ],
                        body: "a=this_f(b,c)",
                        thisVars: [ "this_f" ]
                    },
                    funcName: f
                });
                exports[f + "s"] = makeOp({
                    args: [ "array", "array", "scalar" ],
                    pre: {
                        args: [],
                        body: "this_f=Math." + f,
                        thisVars: [ "this_f" ]
                    },
                    body: {
                        args: [ "a", "b", "c" ],
                        body: "a=this_f(b,c)",
                        thisVars: [ "this_f" ]
                    },
                    funcName: f + "s"
                });
                exports[f + "eq"] = makeOp({
                    args: [ "array", "array" ],
                    pre: {
                        args: [],
                        body: "this_f=Math." + f,
                        thisVars: [ "this_f" ]
                    },
                    body: {
                        args: [ "a", "b" ],
                        body: "a=this_f(a,b)",
                        thisVars: [ "this_f" ]
                    },
                    rvalue: true,
                    count: 2,
                    funcName: f + "eq"
                });
                exports[f + "seq"] = makeOp({
                    args: [ "array", "scalar" ],
                    pre: {
                        args: [],
                        body: "this_f=Math." + f,
                        thisVars: [ "this_f" ]
                    },
                    body: {
                        args: [ "a", "b" ],
                        body: "a=this_f(a,b)",
                        thisVars: [ "this_f" ]
                    },
                    rvalue: true,
                    count: 2,
                    funcName: f + "seq"
                });
            }
        })();
        var math_noncomm = [ "atan2", "pow" ];
        (function() {
            for (var i = 0; i < math_noncomm.length; ++i) {
                var f = math_noncomm[i];
                exports[f + "op"] = makeOp({
                    args: [ "array", "array", "array" ],
                    pre: {
                        args: [],
                        body: "this_f=Math." + f,
                        thisVars: [ "this_f" ]
                    },
                    body: {
                        args: [ "a", "b", "c" ],
                        body: "a=this_f(c,b)",
                        thisVars: [ "this_f" ]
                    },
                    funcName: f + "op"
                });
                exports[f + "ops"] = makeOp({
                    args: [ "array", "array", "scalar" ],
                    pre: {
                        args: [],
                        body: "this_f=Math." + f,
                        thisVars: [ "this_f" ]
                    },
                    body: {
                        args: [ "a", "b", "c" ],
                        body: "a=this_f(c,b)",
                        thisVars: [ "this_f" ]
                    },
                    funcName: f + "ops"
                });
                exports[f + "opeq"] = makeOp({
                    args: [ "array", "array" ],
                    pre: {
                        args: [],
                        body: "this_f=Math." + f,
                        thisVars: [ "this_f" ]
                    },
                    body: {
                        args: [ "a", "b" ],
                        body: "a=this_f(b,a)",
                        thisVars: [ "this_f" ]
                    },
                    rvalue: true,
                    count: 2,
                    funcName: f + "opeq"
                });
                exports[f + "opseq"] = makeOp({
                    args: [ "array", "scalar" ],
                    pre: {
                        args: [],
                        body: "this_f=Math." + f,
                        thisVars: [ "this_f" ]
                    },
                    body: {
                        args: [ "a", "b" ],
                        body: "a=this_f(b,a)",
                        thisVars: [ "this_f" ]
                    },
                    rvalue: true,
                    count: 2,
                    funcName: f + "opseq"
                });
            }
        })();
        exports.any = compile({
            args: [ "array" ],
            pre: EmptyProc,
            body: {
                args: [ {
                    name: "a",
                    lvalue: false,
                    rvalue: true,
                    count: 1
                } ],
                body: "if(a){return true}",
                localVars: [],
                thisVars: []
            },
            post: {
                args: [],
                localVars: [],
                thisVars: [],
                body: "return false"
            },
            funcName: "any"
        });
        exports.all = compile({
            args: [ "array" ],
            pre: EmptyProc,
            body: {
                args: [ {
                    name: "x",
                    lvalue: false,
                    rvalue: true,
                    count: 1
                } ],
                body: "if(!x){return false}",
                localVars: [],
                thisVars: []
            },
            post: {
                args: [],
                localVars: [],
                thisVars: [],
                body: "return true"
            },
            funcName: "all"
        });
        exports.sum = compile({
            args: [ "array" ],
            pre: {
                args: [],
                localVars: [],
                thisVars: [ "this_s" ],
                body: "this_s=0"
            },
            body: {
                args: [ {
                    name: "a",
                    lvalue: false,
                    rvalue: true,
                    count: 1
                } ],
                body: "this_s+=a",
                localVars: [],
                thisVars: [ "this_s" ]
            },
            post: {
                args: [],
                localVars: [],
                thisVars: [ "this_s" ],
                body: "return this_s"
            },
            funcName: "sum"
        });
        exports.prod = compile({
            args: [ "array" ],
            pre: {
                args: [],
                localVars: [],
                thisVars: [ "this_s" ],
                body: "this_s=1"
            },
            body: {
                args: [ {
                    name: "a",
                    lvalue: false,
                    rvalue: true,
                    count: 1
                } ],
                body: "this_s*=a",
                localVars: [],
                thisVars: [ "this_s" ]
            },
            post: {
                args: [],
                localVars: [],
                thisVars: [ "this_s" ],
                body: "return this_s"
            },
            funcName: "prod"
        });
        exports.norm2squared = compile({
            args: [ "array" ],
            pre: {
                args: [],
                localVars: [],
                thisVars: [ "this_s" ],
                body: "this_s=0"
            },
            body: {
                args: [ {
                    name: "a",
                    lvalue: false,
                    rvalue: true,
                    count: 2
                } ],
                body: "this_s+=a*a",
                localVars: [],
                thisVars: [ "this_s" ]
            },
            post: {
                args: [],
                localVars: [],
                thisVars: [ "this_s" ],
                body: "return this_s"
            },
            funcName: "norm2squared"
        });
        exports.norm2 = compile({
            args: [ "array" ],
            pre: {
                args: [],
                localVars: [],
                thisVars: [ "this_s" ],
                body: "this_s=0"
            },
            body: {
                args: [ {
                    name: "a",
                    lvalue: false,
                    rvalue: true,
                    count: 2
                } ],
                body: "this_s+=a*a",
                localVars: [],
                thisVars: [ "this_s" ]
            },
            post: {
                args: [],
                localVars: [],
                thisVars: [ "this_s" ],
                body: "return Math.sqrt(this_s)"
            },
            funcName: "norm2"
        });
        exports.norminf = compile({
            args: [ "array" ],
            pre: {
                args: [],
                localVars: [],
                thisVars: [ "this_s" ],
                body: "this_s=0"
            },
            body: {
                args: [ {
                    name: "a",
                    lvalue: false,
                    rvalue: true,
                    count: 4
                } ],
                body: "if(-a>this_s){this_s=-a}else if(a>this_s){this_s=a}",
                localVars: [],
                thisVars: [ "this_s" ]
            },
            post: {
                args: [],
                localVars: [],
                thisVars: [ "this_s" ],
                body: "return this_s"
            },
            funcName: "norminf"
        });
        exports.norm1 = compile({
            args: [ "array" ],
            pre: {
                args: [],
                localVars: [],
                thisVars: [ "this_s" ],
                body: "this_s=0"
            },
            body: {
                args: [ {
                    name: "a",
                    lvalue: false,
                    rvalue: true,
                    count: 3
                } ],
                body: "this_s+=a<0?-a:a",
                localVars: [],
                thisVars: [ "this_s" ]
            },
            post: {
                args: [],
                localVars: [],
                thisVars: [ "this_s" ],
                body: "return this_s"
            },
            funcName: "norm1"
        });
        exports.sup = compile({
            args: [ "array" ],
            pre: {
                body: "this_h=-Infinity",
                args: [],
                thisVars: [ "this_h" ],
                localVars: []
            },
            body: {
                body: "if(_inline_1_arg0_>this_h)this_h=_inline_1_arg0_",
                args: [ {
                    name: "_inline_1_arg0_",
                    lvalue: false,
                    rvalue: true,
                    count: 2
                } ],
                thisVars: [ "this_h" ],
                localVars: []
            },
            post: {
                body: "return this_h",
                args: [],
                thisVars: [ "this_h" ],
                localVars: []
            }
        });
        exports.inf = compile({
            args: [ "array" ],
            pre: {
                body: "this_h=Infinity",
                args: [],
                thisVars: [ "this_h" ],
                localVars: []
            },
            body: {
                body: "if(_inline_1_arg0_<this_h)this_h=_inline_1_arg0_",
                args: [ {
                    name: "_inline_1_arg0_",
                    lvalue: false,
                    rvalue: true,
                    count: 2
                } ],
                thisVars: [ "this_h" ],
                localVars: []
            },
            post: {
                body: "return this_h",
                args: [],
                thisVars: [ "this_h" ],
                localVars: []
            }
        });
        exports.argmin = compile({
            args: [ "index", "array", "shape" ],
            pre: {
                body: "{this_v=Infinity;this_i=_inline_0_arg2_.slice(0)}",
                args: [ {
                    name: "_inline_0_arg0_",
                    lvalue: false,
                    rvalue: false,
                    count: 0
                }, {
                    name: "_inline_0_arg1_",
                    lvalue: false,
                    rvalue: false,
                    count: 0
                }, {
                    name: "_inline_0_arg2_",
                    lvalue: false,
                    rvalue: true,
                    count: 1
                } ],
                thisVars: [ "this_i", "this_v" ],
                localVars: []
            },
            body: {
                body: "{if(_inline_1_arg1_<this_v){this_v=_inline_1_arg1_;for(var _inline_1_k=0;_inline_1_k<_inline_1_arg0_.length;++_inline_1_k){this_i[_inline_1_k]=_inline_1_arg0_[_inline_1_k]}}}",
                args: [ {
                    name: "_inline_1_arg0_",
                    lvalue: false,
                    rvalue: true,
                    count: 2
                }, {
                    name: "_inline_1_arg1_",
                    lvalue: false,
                    rvalue: true,
                    count: 2
                } ],
                thisVars: [ "this_i", "this_v" ],
                localVars: [ "_inline_1_k" ]
            },
            post: {
                body: "{return this_i}",
                args: [],
                thisVars: [ "this_i" ],
                localVars: []
            }
        });
        exports.argmax = compile({
            args: [ "index", "array", "shape" ],
            pre: {
                body: "{this_v=-Infinity;this_i=_inline_0_arg2_.slice(0)}",
                args: [ {
                    name: "_inline_0_arg0_",
                    lvalue: false,
                    rvalue: false,
                    count: 0
                }, {
                    name: "_inline_0_arg1_",
                    lvalue: false,
                    rvalue: false,
                    count: 0
                }, {
                    name: "_inline_0_arg2_",
                    lvalue: false,
                    rvalue: true,
                    count: 1
                } ],
                thisVars: [ "this_i", "this_v" ],
                localVars: []
            },
            body: {
                body: "{if(_inline_1_arg1_>this_v){this_v=_inline_1_arg1_;for(var _inline_1_k=0;_inline_1_k<_inline_1_arg0_.length;++_inline_1_k){this_i[_inline_1_k]=_inline_1_arg0_[_inline_1_k]}}}",
                args: [ {
                    name: "_inline_1_arg0_",
                    lvalue: false,
                    rvalue: true,
                    count: 2
                }, {
                    name: "_inline_1_arg1_",
                    lvalue: false,
                    rvalue: true,
                    count: 2
                } ],
                thisVars: [ "this_i", "this_v" ],
                localVars: [ "_inline_1_k" ]
            },
            post: {
                body: "{return this_i}",
                args: [],
                thisVars: [ "this_i" ],
                localVars: []
            }
        });
        exports.random = makeOp({
            args: [ "array" ],
            pre: {
                args: [],
                body: "this_f=Math.random",
                thisVars: [ "this_f" ]
            },
            body: {
                args: [ "a" ],
                body: "a=this_f()",
                thisVars: [ "this_f" ]
            },
            funcName: "random"
        });
        exports.assign = makeOp({
            args: [ "array", "array" ],
            body: {
                args: [ "a", "b" ],
                body: "a=b"
            },
            funcName: "assign"
        });
        exports.assigns = makeOp({
            args: [ "array", "scalar" ],
            body: {
                args: [ "a", "b" ],
                body: "a=b"
            },
            funcName: "assigns"
        });
        exports.equals = compile({
            args: [ "array", "array" ],
            pre: EmptyProc,
            body: {
                args: [ {
                    name: "x",
                    lvalue: false,
                    rvalue: true,
                    count: 1
                }, {
                    name: "y",
                    lvalue: false,
                    rvalue: true,
                    count: 1
                } ],
                body: "if(x!==y){return false}",
                localVars: [],
                thisVars: []
            },
            post: {
                args: [],
                localVars: [],
                thisVars: [],
                body: "return true"
            },
            funcName: "equals"
        });
    }, {
        "cwise-compiler": 82
    } ],
    82: [ function(require, module, exports) {
        arguments[4][14][0].apply(exports, arguments);
    }, {
        "./lib/thunk.js": 84,
        dup: 14
    } ],
    83: [ function(require, module, exports) {
        arguments[4][15][0].apply(exports, arguments);
    }, {
        dup: 15,
        uniq: 85
    } ],
    84: [ function(require, module, exports) {
        arguments[4][16][0].apply(exports, arguments);
    }, {
        "./compile.js": 83,
        dup: 16
    } ],
    85: [ function(require, module, exports) {
        arguments[4][17][0].apply(exports, arguments);
    }, {
        dup: 17
    } ],
    86: [ function(require, module, exports) {
        "use strict";
        var ndarray = require("ndarray");
        var do_convert = require("./doConvert.js");
        module.exports = function convert(arr, result) {
            var shape = [], c = arr, sz = 1;
            while (c instanceof Array) {
                shape.push(c.length);
                sz *= c.length;
                c = c[0];
            }
            if (shape.length === 0) {
                return ndarray();
            }
            if (!result) {
                result = ndarray(new Float64Array(sz), shape);
            }
            do_convert(result, arr);
            return result;
        };
    }, {
        "./doConvert.js": 87,
        ndarray: 101
    } ],
    87: [ function(require, module, exports) {
        module.exports = require("cwise-compiler")({
            args: [ "array", "scalar", "index" ],
            pre: {
                body: "{}",
                args: [],
                thisVars: [],
                localVars: []
            },
            body: {
                body: "{\nvar _inline_1_v=_inline_1_arg1_,_inline_1_i\nfor(_inline_1_i=0;_inline_1_i<_inline_1_arg2_.length-1;++_inline_1_i) {\n_inline_1_v=_inline_1_v[_inline_1_arg2_[_inline_1_i]]\n}\n_inline_1_arg0_=_inline_1_v[_inline_1_arg2_[_inline_1_arg2_.length-1]]\n}",
                args: [ {
                    name: "_inline_1_arg0_",
                    lvalue: true,
                    rvalue: false,
                    count: 1
                }, {
                    name: "_inline_1_arg1_",
                    lvalue: false,
                    rvalue: true,
                    count: 1
                }, {
                    name: "_inline_1_arg2_",
                    lvalue: false,
                    rvalue: true,
                    count: 4
                } ],
                thisVars: [],
                localVars: [ "_inline_1_i", "_inline_1_v" ]
            },
            post: {
                body: "{}",
                args: [],
                thisVars: [],
                localVars: []
            },
            funcName: "convert",
            blockSize: 64
        });
    }, {
        "cwise-compiler": 88
    } ],
    88: [ function(require, module, exports) {
        "use strict";
        var createThunk = require("./lib/thunk.js");
        function Procedure() {
            this.argTypes = [];
            this.shimArgs = [];
            this.arrayArgs = [];
            this.scalarArgs = [];
            this.offsetArgs = [];
            this.offsetArgIndex = [];
            this.indexArgs = [];
            this.shapeArgs = [];
            this.funcName = "";
            this.pre = null;
            this.body = null;
            this.post = null;
            this.debug = false;
        }
        function compileCwise(user_args) {
            var proc = new Procedure();
            proc.pre = user_args.pre;
            proc.body = user_args.body;
            proc.post = user_args.post;
            var proc_args = user_args.args.slice(0);
            proc.argTypes = proc_args.slice(0);
            for (var i = 0; i < proc_args.length; ++i) {
                var arg_type = proc_args[i];
                if (arg_type === "array") {
                    proc.arrayArgs.push(i);
                    proc.shimArgs.push("array" + i);
                    if (i < proc.pre.args.length && proc.pre.args[i].count > 0) {
                        throw new Error("cwise: pre() block may not reference array args");
                    }
                    if (i < proc.post.args.length && proc.post.args[i].count > 0) {
                        throw new Error("cwise: post() block may not reference array args");
                    }
                } else if (arg_type === "scalar") {
                    proc.scalarArgs.push(i);
                    proc.shimArgs.push("scalar" + i);
                } else if (arg_type === "index") {
                    proc.indexArgs.push(i);
                    if (i < proc.pre.args.length && proc.pre.args[i].count > 0) {
                        throw new Error("cwise: pre() block may not reference array index");
                    }
                    if (i < proc.body.args.length && proc.body.args[i].lvalue) {
                        throw new Error("cwise: body() block may not write to array index");
                    }
                    if (i < proc.post.args.length && proc.post.args[i].count > 0) {
                        throw new Error("cwise: post() block may not reference array index");
                    }
                } else if (arg_type === "shape") {
                    proc.shapeArgs.push(i);
                    if (i < proc.pre.args.length && proc.pre.args[i].lvalue) {
                        throw new Error("cwise: pre() block may not write to array shape");
                    }
                    if (i < proc.body.args.length && proc.body.args[i].lvalue) {
                        throw new Error("cwise: body() block may not write to array shape");
                    }
                    if (i < proc.post.args.length && proc.post.args[i].lvalue) {
                        throw new Error("cwise: post() block may not write to array shape");
                    }
                } else if (typeof arg_type === "object" && arg_type.offset) {
                    proc.argTypes[i] = "offset";
                    proc.offsetArgs.push({
                        array: arg_type.array,
                        offset: arg_type.offset
                    });
                    proc.offsetArgIndex.push(i);
                } else {
                    throw new Error("cwise: Unknown argument type " + proc_args[i]);
                }
            }
            if (proc.arrayArgs.length <= 0) {
                throw new Error("cwise: No array arguments specified");
            }
            if (proc.pre.args.length > proc_args.length) {
                throw new Error("cwise: Too many arguments in pre() block");
            }
            if (proc.body.args.length > proc_args.length) {
                throw new Error("cwise: Too many arguments in body() block");
            }
            if (proc.post.args.length > proc_args.length) {
                throw new Error("cwise: Too many arguments in post() block");
            }
            proc.debug = !!user_args.printCode || !!user_args.debug;
            proc.funcName = user_args.funcName || "cwise";
            proc.blockSize = user_args.blockSize || 64;
            return createThunk(proc);
        }
        module.exports = compileCwise;
    }, {
        "./lib/thunk.js": 90
    } ],
    89: [ function(require, module, exports) {
        "use strict";
        var uniq = require("uniq");
        function innerFill(order, proc, body) {
            var dimension = order.length, nargs = proc.arrayArgs.length, has_index = proc.indexArgs.length > 0, code = [], vars = [], idx = 0, pidx = 0, i, j;
            for (i = 0; i < dimension; ++i) {
                vars.push([ "i", i, "=0" ].join(""));
            }
            for (j = 0; j < nargs; ++j) {
                for (i = 0; i < dimension; ++i) {
                    pidx = idx;
                    idx = order[i];
                    if (i === 0) {
                        vars.push([ "d", j, "s", i, "=t", j, "[", idx, "]" ].join(""));
                    } else {
                        vars.push([ "d", j, "s", i, "=(t", j, "[", idx, "]-s", pidx, "*t", j, "[", pidx, "])" ].join(""));
                    }
                }
            }
            code.push("var " + vars.join(","));
            for (i = dimension - 1; i >= 0; --i) {
                idx = order[i];
                code.push([ "for(i", i, "=0;i", i, "<s", idx, ";++i", i, "){" ].join(""));
            }
            code.push(body);
            for (i = 0; i < dimension; ++i) {
                pidx = idx;
                idx = order[i];
                for (j = 0; j < nargs; ++j) {
                    code.push([ "p", j, "+=d", j, "s", i ].join(""));
                }
                if (has_index) {
                    if (i > 0) {
                        code.push([ "index[", pidx, "]-=s", pidx ].join(""));
                    }
                    code.push([ "++index[", idx, "]" ].join(""));
                }
                code.push("}");
            }
            return code.join("\n");
        }
        function outerFill(matched, order, proc, body) {
            var dimension = order.length, nargs = proc.arrayArgs.length, blockSize = proc.blockSize, has_index = proc.indexArgs.length > 0, code = [];
            for (var i = 0; i < nargs; ++i) {
                code.push([ "var offset", i, "=p", i ].join(""));
            }
            for (var i = matched; i < dimension; ++i) {
                code.push([ "for(var j" + i + "=SS[", order[i], "]|0;j", i, ">0;){" ].join(""));
                code.push([ "if(j", i, "<", blockSize, "){" ].join(""));
                code.push([ "s", order[i], "=j", i ].join(""));
                code.push([ "j", i, "=0" ].join(""));
                code.push([ "}else{s", order[i], "=", blockSize ].join(""));
                code.push([ "j", i, "-=", blockSize, "}" ].join(""));
                if (has_index) {
                    code.push([ "index[", order[i], "]=j", i ].join(""));
                }
            }
            for (var i = 0; i < nargs; ++i) {
                var indexStr = [ "offset" + i ];
                for (var j = matched; j < dimension; ++j) {
                    indexStr.push([ "j", j, "*t", i, "[", order[j], "]" ].join(""));
                }
                code.push([ "p", i, "=(", indexStr.join("+"), ")" ].join(""));
            }
            code.push(innerFill(order, proc, body));
            for (var i = matched; i < dimension; ++i) {
                code.push("}");
            }
            return code.join("\n");
        }
        function countMatches(orders) {
            var matched = 0, dimension = orders[0].length;
            while (matched < dimension) {
                for (var j = 1; j < orders.length; ++j) {
                    if (orders[j][matched] !== orders[0][matched]) {
                        return matched;
                    }
                }
                ++matched;
            }
            return matched;
        }
        function processBlock(block, proc, dtypes) {
            var code = block.body;
            var pre = [];
            var post = [];
            for (var i = 0; i < block.args.length; ++i) {
                var carg = block.args[i];
                if (carg.count <= 0) {
                    continue;
                }
                var re = new RegExp(carg.name, "g");
                var ptrStr = "";
                var arrNum = proc.arrayArgs.indexOf(i);
                switch (proc.argTypes[i]) {
                  case "offset":
                    var offArgIndex = proc.offsetArgIndex.indexOf(i);
                    var offArg = proc.offsetArgs[offArgIndex];
                    arrNum = offArg.array;
                    ptrStr = "+q" + offArgIndex;

                  case "array":
                    ptrStr = "p" + arrNum + ptrStr;
                    var localStr = "l" + i;
                    var arrStr = "a" + arrNum;
                    if (carg.count === 1) {
                        if (dtypes[arrNum] === "generic") {
                            if (carg.lvalue) {
                                pre.push([ "var ", localStr, "=", arrStr, ".get(", ptrStr, ")" ].join(""));
                                code = code.replace(re, localStr);
                                post.push([ arrStr, ".set(", ptrStr, ",", localStr, ")" ].join(""));
                            } else {
                                code = code.replace(re, [ arrStr, ".get(", ptrStr, ")" ].join(""));
                            }
                        } else {
                            code = code.replace(re, [ arrStr, "[", ptrStr, "]" ].join(""));
                        }
                    } else if (dtypes[arrNum] === "generic") {
                        pre.push([ "var ", localStr, "=", arrStr, ".get(", ptrStr, ")" ].join(""));
                        code = code.replace(re, localStr);
                        if (carg.lvalue) {
                            post.push([ arrStr, ".set(", ptrStr, ",", localStr, ")" ].join(""));
                        }
                    } else {
                        pre.push([ "var ", localStr, "=", arrStr, "[", ptrStr, "]" ].join(""));
                        code = code.replace(re, localStr);
                        if (carg.lvalue) {
                            post.push([ arrStr, "[", ptrStr, "]=", localStr ].join(""));
                        }
                    }
                    break;

                  case "scalar":
                    code = code.replace(re, "Y" + proc.scalarArgs.indexOf(i));
                    break;

                  case "index":
                    code = code.replace(re, "index");
                    break;

                  case "shape":
                    code = code.replace(re, "shape");
                    break;
                }
            }
            return [ pre.join("\n"), code, post.join("\n") ].join("\n").trim();
        }
        function typeSummary(dtypes) {
            var summary = new Array(dtypes.length);
            var allEqual = true;
            for (var i = 0; i < dtypes.length; ++i) {
                var t = dtypes[i];
                var digits = t.match(/\d+/);
                if (!digits) {
                    digits = "";
                } else {
                    digits = digits[0];
                }
                if (t.charAt(0) === 0) {
                    summary[i] = "u" + t.charAt(1) + digits;
                } else {
                    summary[i] = t.charAt(0) + digits;
                }
                if (i > 0) {
                    allEqual = allEqual && summary[i] === summary[i - 1];
                }
            }
            if (allEqual) {
                return summary[0];
            }
            return summary.join("");
        }
        function generateCWiseOp(proc, typesig) {
            var dimension = typesig[1].length | 0;
            var orders = new Array(proc.arrayArgs.length);
            var dtypes = new Array(proc.arrayArgs.length);
            var arglist = [ "SS" ];
            var code = [ "'use strict'" ];
            var vars = [];
            for (var j = 0; j < dimension; ++j) {
                vars.push([ "s", j, "=SS[", j, "]" ].join(""));
            }
            for (var i = 0; i < proc.arrayArgs.length; ++i) {
                arglist.push("a" + i);
                arglist.push("t" + i);
                arglist.push("p" + i);
                dtypes[i] = typesig[2 * i];
                orders[i] = typesig[2 * i + 1];
            }
            for (var i = 0; i < proc.scalarArgs.length; ++i) {
                arglist.push("Y" + i);
            }
            if (proc.shapeArgs.length > 0) {
                vars.push("shape=SS.slice(0)");
            }
            if (proc.indexArgs.length > 0) {
                var zeros = new Array(dimension);
                for (var i = 0; i < dimension; ++i) {
                    zeros[i] = "0";
                }
                vars.push([ "index=[", zeros.join(","), "]" ].join(""));
            }
            for (var i = 0; i < proc.offsetArgs.length; ++i) {
                var off_arg = proc.offsetArgs[i];
                var init_string = [];
                for (var j = 0; j < off_arg.offset.length; ++j) {
                    if (off_arg.offset[j] === 0) {
                        continue;
                    } else if (off_arg.offset[j] === 1) {
                        init_string.push([ "t", off_arg.array, "[", j, "]" ].join(""));
                    } else {
                        init_string.push([ off_arg.offset[j], "*t", off_arg.array, "[", j, "]" ].join(""));
                    }
                }
                if (init_string.length === 0) {
                    vars.push("q" + i + "=0");
                } else {
                    vars.push([ "q", i, "=(", init_string.join("+"), ")|0" ].join(""));
                }
            }
            var thisVars = uniq([].concat(proc.pre.thisVars).concat(proc.body.thisVars).concat(proc.post.thisVars));
            vars = vars.concat(thisVars);
            code.push("var " + vars.join(","));
            for (var i = 0; i < proc.arrayArgs.length; ++i) {
                code.push("p" + i + "|=0");
            }
            if (proc.pre.body.length > 3) {
                code.push(processBlock(proc.pre, proc, dtypes));
            }
            var body = processBlock(proc.body, proc, dtypes);
            var matched = countMatches(orders);
            if (matched < dimension) {
                code.push(outerFill(matched, orders[0], proc, body));
            } else {
                code.push(innerFill(orders[0], proc, body));
            }
            if (proc.post.body.length > 3) {
                code.push(processBlock(proc.post, proc, dtypes));
            }
            if (proc.debug) {
                console.log("Generated cwise routine for ", typesig, ":\n\n", code.join("\n"));
            }
            var loopName = [ proc.funcName || "unnamed", "_cwise_loop_", orders[0].join("s"), "m", matched, typeSummary(dtypes) ].join("");
            var f = new Function([ "function ", loopName, "(", arglist.join(","), "){", code.join("\n"), "} return ", loopName ].join(""));
            return f();
        }
        module.exports = generateCWiseOp;
    }, {
        uniq: 91
    } ],
    90: [ function(require, module, exports) {
        "use strict";
        var compile = require("./compile.js");
        function createThunk(proc) {
            var code = [ "'use strict'", "var CACHED={}" ];
            var vars = [];
            var thunkName = proc.funcName + "_cwise_thunk";
            code.push([ "return function ", thunkName, "(", proc.shimArgs.join(","), "){" ].join(""));
            var typesig = [];
            var string_typesig = [];
            var proc_args = [ [ "array", proc.arrayArgs[0], ".shape" ].join("") ];
            for (var i = 0; i < proc.arrayArgs.length; ++i) {
                var j = proc.arrayArgs[i];
                vars.push([ "t", j, "=array", j, ".dtype,", "r", j, "=array", j, ".order" ].join(""));
                typesig.push("t" + j);
                typesig.push("r" + j);
                string_typesig.push("t" + j);
                string_typesig.push("r" + j + ".join()");
                proc_args.push("array" + j + ".data");
                proc_args.push("array" + j + ".stride");
                proc_args.push("array" + j + ".offset|0");
            }
            for (var i = 0; i < proc.scalarArgs.length; ++i) {
                proc_args.push("scalar" + proc.scalarArgs[i]);
            }
            vars.push([ "type=[", string_typesig.join(","), "].join()" ].join(""));
            vars.push("proc=CACHED[type]");
            code.push("var " + vars.join(","));
            code.push([ "if(!proc){", "CACHED[type]=proc=compile([", typesig.join(","), "])}", "return proc(", proc_args.join(","), ")}" ].join(""));
            if (proc.debug) {
                console.log("Generated thunk:", code.join("\n"));
            }
            var thunk = new Function("compile", code.join("\n"));
            return thunk(compile.bind(undefined, proc));
        }
        module.exports = createThunk;
    }, {
        "./compile.js": 89
    } ],
    91: [ function(require, module, exports) {
        "use strict";
        function unique_pred(list, compare) {
            var ptr = 1, len = list.length, a = list[0], b = list[0];
            for (var i = 1; i < len; ++i) {
                b = a;
                a = list[i];
                if (compare(a, b)) {
                    if (i === ptr) {
                        ptr++;
                        continue;
                    }
                    list[ptr++] = a;
                }
            }
            list.length = ptr;
            return list;
        }
        function unique_eq(list) {
            var ptr = 1, len = list.length, a = list[0], b = list[0];
            for (var i = 1; i < len; ++i, b = a) {
                b = a;
                a = list[i];
                if (a !== b) {
                    if (i === ptr) {
                        ptr++;
                        continue;
                    }
                    list[ptr++] = a;
                }
            }
            list.length = ptr;
            return list;
        }
        function unique(list, compare, sorted) {
            if (list.length === 0) {
                return [];
            }
            if (compare) {
                if (!sorted) {
                    list.sort(compare);
                }
                return unique_pred(list, compare);
            }
            if (!sorted) {
                list.sort();
            }
            return unique_eq(list);
        }
        module.exports = unique;
    }, {} ],
    92: [ function(require, module, exports) {
        "use strict";
        "use restrict";
        var INT_BITS = 32;
        exports.INT_BITS = INT_BITS;
        exports.INT_MAX = 2147483647;
        exports.INT_MIN = -1 << INT_BITS - 1;
        exports.sign = function(v) {
            return (v > 0) - (v < 0);
        };
        exports.abs = function(v) {
            var mask = v >> INT_BITS - 1;
            return (v ^ mask) - mask;
        };
        exports.min = function(x, y) {
            return y ^ (x ^ y) & -(x < y);
        };
        exports.max = function(x, y) {
            return x ^ (x ^ y) & -(x < y);
        };
        exports.isPow2 = function(v) {
            return !(v & v - 1) && !!v;
        };
        exports.log2 = function(v) {
            var r, shift;
            r = (v > 65535) << 4;
            v >>>= r;
            shift = (v > 255) << 3;
            v >>>= shift;
            r |= shift;
            shift = (v > 15) << 2;
            v >>>= shift;
            r |= shift;
            shift = (v > 3) << 1;
            v >>>= shift;
            r |= shift;
            return r | v >> 1;
        };
        exports.log10 = function(v) {
            return v >= 1e9 ? 9 : v >= 1e8 ? 8 : v >= 1e7 ? 7 : v >= 1e6 ? 6 : v >= 1e5 ? 5 : v >= 1e4 ? 4 : v >= 1e3 ? 3 : v >= 100 ? 2 : v >= 10 ? 1 : 0;
        };
        exports.popCount = function(v) {
            v = v - (v >>> 1 & 1431655765);
            v = (v & 858993459) + (v >>> 2 & 858993459);
            return (v + (v >>> 4) & 252645135) * 16843009 >>> 24;
        };
        function countTrailingZeros(v) {
            var c = 32;
            v &= -v;
            if (v) c--;
            if (v & 65535) c -= 16;
            if (v & 16711935) c -= 8;
            if (v & 252645135) c -= 4;
            if (v & 858993459) c -= 2;
            if (v & 1431655765) c -= 1;
            return c;
        }
        exports.countTrailingZeros = countTrailingZeros;
        exports.nextPow2 = function(v) {
            v += v === 0;
            --v;
            v |= v >>> 1;
            v |= v >>> 2;
            v |= v >>> 4;
            v |= v >>> 8;
            v |= v >>> 16;
            return v + 1;
        };
        exports.prevPow2 = function(v) {
            v |= v >>> 1;
            v |= v >>> 2;
            v |= v >>> 4;
            v |= v >>> 8;
            v |= v >>> 16;
            return v - (v >>> 1);
        };
        exports.parity = function(v) {
            v ^= v >>> 16;
            v ^= v >>> 8;
            v ^= v >>> 4;
            v &= 15;
            return 27030 >>> v & 1;
        };
        var REVERSE_TABLE = new Array(256);
        (function(tab) {
            for (var i = 0; i < 256; ++i) {
                var v = i, r = i, s = 7;
                for (v >>>= 1; v; v >>>= 1) {
                    r <<= 1;
                    r |= v & 1;
                    --s;
                }
                tab[i] = r << s & 255;
            }
        })(REVERSE_TABLE);
        exports.reverse = function(v) {
            return REVERSE_TABLE[v & 255] << 24 | REVERSE_TABLE[v >>> 8 & 255] << 16 | REVERSE_TABLE[v >>> 16 & 255] << 8 | REVERSE_TABLE[v >>> 24 & 255];
        };
        exports.interleave2 = function(x, y) {
            x &= 65535;
            x = (x | x << 8) & 16711935;
            x = (x | x << 4) & 252645135;
            x = (x | x << 2) & 858993459;
            x = (x | x << 1) & 1431655765;
            y &= 65535;
            y = (y | y << 8) & 16711935;
            y = (y | y << 4) & 252645135;
            y = (y | y << 2) & 858993459;
            y = (y | y << 1) & 1431655765;
            return x | y << 1;
        };
        exports.deinterleave2 = function(v, n) {
            v = v >>> n & 1431655765;
            v = (v | v >>> 1) & 858993459;
            v = (v | v >>> 2) & 252645135;
            v = (v | v >>> 4) & 16711935;
            v = (v | v >>> 16) & 65535;
            return v << 16 >> 16;
        };
        exports.interleave3 = function(x, y, z) {
            x &= 1023;
            x = (x | x << 16) & 4278190335;
            x = (x | x << 8) & 251719695;
            x = (x | x << 4) & 3272356035;
            x = (x | x << 2) & 1227133513;
            y &= 1023;
            y = (y | y << 16) & 4278190335;
            y = (y | y << 8) & 251719695;
            y = (y | y << 4) & 3272356035;
            y = (y | y << 2) & 1227133513;
            x |= y << 1;
            z &= 1023;
            z = (z | z << 16) & 4278190335;
            z = (z | z << 8) & 251719695;
            z = (z | z << 4) & 3272356035;
            z = (z | z << 2) & 1227133513;
            return x | z << 2;
        };
        exports.deinterleave3 = function(v, n) {
            v = v >>> n & 1227133513;
            v = (v | v >>> 2) & 3272356035;
            v = (v | v >>> 4) & 251719695;
            v = (v | v >>> 8) & 4278190335;
            v = (v | v >>> 16) & 1023;
            return v << 22 >> 22;
        };
        exports.nextCombination = function(v) {
            var t = v | v - 1;
            return t + 1 | (~t & -~t) - 1 >>> countTrailingZeros(v) + 1;
        };
    }, {} ],
    93: [ function(require, module, exports) {
        "use strict";
        function dupe_array(count, value, i) {
            var c = count[i] | 0;
            if (c <= 0) {
                return [];
            }
            var result = new Array(c), j;
            if (i === count.length - 1) {
                for (j = 0; j < c; ++j) {
                    result[j] = value;
                }
            } else {
                for (j = 0; j < c; ++j) {
                    result[j] = dupe_array(count, value, i + 1);
                }
            }
            return result;
        }
        function dupe_number(count, value) {
            var result, i;
            result = new Array(count);
            for (i = 0; i < count; ++i) {
                result[i] = value;
            }
            return result;
        }
        function dupe(count, value) {
            if (typeof value === "undefined") {
                value = 0;
            }
            switch (typeof count) {
              case "number":
                if (count > 0) {
                    return dupe_number(count | 0, value);
                }
                break;

              case "object":
                if (typeof count.length === "number") {
                    return dupe_array(count, value, 0);
                }
                break;
            }
            return [];
        }
        module.exports = dupe;
    }, {} ],
    94: [ function(require, module, exports) {
        (function(global, Buffer) {
            "use strict";
            var bits = require("bit-twiddle");
            var dup = require("dup");
            if (!global.__TYPEDARRAY_POOL) {
                global.__TYPEDARRAY_POOL = {
                    UINT8: dup([ 32, 0 ]),
                    UINT16: dup([ 32, 0 ]),
                    UINT32: dup([ 32, 0 ]),
                    INT8: dup([ 32, 0 ]),
                    INT16: dup([ 32, 0 ]),
                    INT32: dup([ 32, 0 ]),
                    FLOAT: dup([ 32, 0 ]),
                    DOUBLE: dup([ 32, 0 ]),
                    DATA: dup([ 32, 0 ]),
                    UINT8C: dup([ 32, 0 ]),
                    BUFFER: dup([ 32, 0 ])
                };
            }
            var hasUint8C = typeof Uint8ClampedArray !== "undefined";
            var POOL = global.__TYPEDARRAY_POOL;
            if (!POOL.UINT8C) {
                POOL.UINT8C = dup([ 32, 0 ]);
            }
            if (!POOL.BUFFER) {
                POOL.BUFFER = dup([ 32, 0 ]);
            }
            var DATA = POOL.DATA, BUFFER = POOL.BUFFER;
            exports.free = function free(array) {
                if (Buffer.isBuffer(array)) {
                    BUFFER[bits.log2(array.length)].push(array);
                } else {
                    if (Object.prototype.toString.call(array) !== "[object ArrayBuffer]") {
                        array = array.buffer;
                    }
                    if (!array) {
                        return;
                    }
                    var n = array.length || array.byteLength;
                    var log_n = bits.log2(n) | 0;
                    DATA[log_n].push(array);
                }
            };
            function freeArrayBuffer(buffer) {
                if (!buffer) {
                    return;
                }
                var n = buffer.length || buffer.byteLength;
                var log_n = bits.log2(n);
                DATA[log_n].push(buffer);
            }
            function freeTypedArray(array) {
                freeArrayBuffer(array.buffer);
            }
            exports.freeUint8 = exports.freeUint16 = exports.freeUint32 = exports.freeInt8 = exports.freeInt16 = exports.freeInt32 = exports.freeFloat32 = exports.freeFloat = exports.freeFloat64 = exports.freeDouble = exports.freeUint8Clamped = exports.freeDataView = freeTypedArray;
            exports.freeArrayBuffer = freeArrayBuffer;
            exports.freeBuffer = function freeBuffer(array) {
                BUFFER[bits.log2(array.length)].push(array);
            };
            exports.malloc = function malloc(n, dtype) {
                if (dtype === undefined || dtype === "arraybuffer") {
                    return mallocArrayBuffer(n);
                } else {
                    switch (dtype) {
                      case "uint8":
                        return mallocUint8(n);

                      case "uint16":
                        return mallocUint16(n);

                      case "uint32":
                        return mallocUint32(n);

                      case "int8":
                        return mallocInt8(n);

                      case "int16":
                        return mallocInt16(n);

                      case "int32":
                        return mallocInt32(n);

                      case "float":
                      case "float32":
                        return mallocFloat(n);

                      case "double":
                      case "float64":
                        return mallocDouble(n);

                      case "uint8_clamped":
                        return mallocUint8Clamped(n);

                      case "buffer":
                        return mallocBuffer(n);

                      case "data":
                      case "dataview":
                        return mallocDataView(n);

                      default:
                        return null;
                    }
                }
                return null;
            };
            function mallocArrayBuffer(n) {
                var n = bits.nextPow2(n);
                var log_n = bits.log2(n);
                var d = DATA[log_n];
                if (d.length > 0) {
                    return d.pop();
                }
                return new ArrayBuffer(n);
            }
            exports.mallocArrayBuffer = mallocArrayBuffer;
            function mallocUint8(n) {
                return new Uint8Array(mallocArrayBuffer(n), 0, n);
            }
            exports.mallocUint8 = mallocUint8;
            function mallocUint16(n) {
                return new Uint16Array(mallocArrayBuffer(2 * n), 0, n);
            }
            exports.mallocUint16 = mallocUint16;
            function mallocUint32(n) {
                return new Uint32Array(mallocArrayBuffer(4 * n), 0, n);
            }
            exports.mallocUint32 = mallocUint32;
            function mallocInt8(n) {
                return new Int8Array(mallocArrayBuffer(n), 0, n);
            }
            exports.mallocInt8 = mallocInt8;
            function mallocInt16(n) {
                return new Int16Array(mallocArrayBuffer(2 * n), 0, n);
            }
            exports.mallocInt16 = mallocInt16;
            function mallocInt32(n) {
                return new Int32Array(mallocArrayBuffer(4 * n), 0, n);
            }
            exports.mallocInt32 = mallocInt32;
            function mallocFloat(n) {
                return new Float32Array(mallocArrayBuffer(4 * n), 0, n);
            }
            exports.mallocFloat32 = exports.mallocFloat = mallocFloat;
            function mallocDouble(n) {
                return new Float64Array(mallocArrayBuffer(8 * n), 0, n);
            }
            exports.mallocFloat64 = exports.mallocDouble = mallocDouble;
            function mallocUint8Clamped(n) {
                if (hasUint8C) {
                    return new Uint8ClampedArray(mallocArrayBuffer(n), 0, n);
                } else {
                    return mallocUint8(n);
                }
            }
            exports.mallocUint8Clamped = mallocUint8Clamped;
            function mallocDataView(n) {
                return new DataView(mallocArrayBuffer(n), 0, n);
            }
            exports.mallocDataView = mallocDataView;
            function mallocBuffer(n) {
                n = bits.nextPow2(n);
                var log_n = bits.log2(n);
                var cache = BUFFER[log_n];
                if (cache.length > 0) {
                    return cache.pop();
                }
                return new Buffer(n);
            }
            exports.mallocBuffer = mallocBuffer;
            exports.clearCache = function clearCache() {
                for (var i = 0; i < 32; ++i) {
                    POOL.UINT8[i].length = 0;
                    POOL.UINT16[i].length = 0;
                    POOL.UINT32[i].length = 0;
                    POOL.INT8[i].length = 0;
                    POOL.INT16[i].length = 0;
                    POOL.INT32[i].length = 0;
                    POOL.FLOAT[i].length = 0;
                    POOL.DOUBLE[i].length = 0;
                    POOL.UINT8C[i].length = 0;
                    DATA[i].length = 0;
                    BUFFER[i].length = 0;
                }
            };
        }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, require("buffer").Buffer);
    }, {
        "bit-twiddle": 92,
        buffer: 3,
        dup: 93
    } ],
    95: [ function(require, module, exports) {
        "use strict";
        var ndarray = require("ndarray");
        var ops = require("ndarray-ops");
        var pool = require("typedarray-pool");
        function clone(array) {
            var dtype = array.dtype;
            if (dtype === "generic" || dtype === "array") {
                dtype = "double";
            }
            var data = pool.malloc(array.size, dtype);
            var result = ndarray(data, array.shape);
            ops.assign(result, array);
            return result;
        }
        exports.clone = clone;
        function malloc(shape, dtype) {
            if (!dtype) {
                dtype = "double";
            }
            var sz = 1;
            var stride = new Array(shape.length);
            for (var i = shape.length - 1; i >= 0; --i) {
                stride[i] = sz;
                sz *= shape[i];
            }
            return ndarray(pool.malloc(sz, dtype), shape, stride, 0);
        }
        exports.malloc = malloc;
        function free(array) {
            if (array.dtype === "generic" || array.dtype === "array") {
                return;
            }
            pool.free(array.data);
        }
        exports.free = free;
        function zeros(shape, dtype) {
            if (!dtype) {
                dtype = "double";
            }
            var sz = 1;
            var stride = new Array(shape.length);
            for (var i = shape.length - 1; i >= 0; --i) {
                stride[i] = sz;
                sz *= shape[i];
            }
            var buf = pool.malloc(sz, dtype);
            for (var i = 0; i < sz; ++i) {
                buf[i] = 0;
            }
            return ndarray(buf, shape, stride, 0);
        }
        exports.zeros = zeros;
    }, {
        ndarray: 101,
        "ndarray-ops": 81,
        "typedarray-pool": 94
    } ],
    96: [ function(require, module, exports) {
        var showf = require("fixed-width-float");
        var ndarray = require("ndarray");
        module.exports = function(m, opts) {
            if (!opts) opts = {};
            if (typeof opts === "number") opts = {
                width: opts
            };
            if (!opts.width) opts.width = 8;
            if (m.dimension === undefined) {
                m = ndarray(m);
            }
            if (m.dimension === 1) return d1(m, opts);
            if (m.dimension === 2) return d2(m, opts);
            if (m.dimension === 3) return d3(m, opts);
            if (m.dimension === 4) return d4(m, opts);
        };
        function d1(m, opts) {
            var terms = [];
            for (var i = 0; i < m.shape[0]; i++) {
                terms.push(showf(m.get(i), opts.width));
            }
            return terms.join(" ");
        }
        function d2(m, opts) {
            var rows = [];
            for (var y = 0; y < m.shape[1]; y++) {
                rows.push(d1(m.pick(null, y), opts));
            }
            return rows.join("\n");
        }
        function d3(m, opts) {
            var rows = [];
            for (var z = 0; z < m.shape[2]; z++) {
                rows.push(d2(m.pick(null, null, z), opts), "");
            }
            return rows.join("\n");
        }
        function d4(m, opts) {
            var rows = [], len = 3;
            for (var w = 0; w < m.shape[3]; w++) {
                var r = d3(m.pick(null, null, null, w), opts);
                rows.push(r);
                var lines = r.split("\n");
                for (var i = 0; i < lines.length; i++) {
                    len = Math.max(len, lines[i].length);
                }
            }
            return rows.join("\n" + Array(len + 1).join("-") + "\n\n");
        }
    }, {
        "fixed-width-float": 97,
        ndarray: 101
    } ],
    97: [ function(require, module, exports) {
        var sprintf = require("sprintf");
        module.exports = format;
        function format(x, bytes) {
            if (bytes === undefined) bytes = 8;
            var rfmt = "%" + bytes + "." + bytes + "s";
            if (bytes <= 0) return undefined;
            if (isNaN(x)) return sprintf(rfmt, "NaN");
            if (x === Infinity) {
                if (bytes === 1) return undefined;
                return sprintf(rfmt, bytes >= 9 ? "Infinity" : " Inf").slice(0, bytes);
            }
            if (x === -Infinity) {
                if (bytes === 1) return undefined;
                return sprintf(rfmt, bytes >= 9 ? "-Infinity" : "-Inf").slice(0, bytes);
            }
            return packf(x, bytes);
        }
        function sci(x, bytes) {
            var n = Math.max(1, log10f(Math.abs(x)));
            var sz = log10f(Math.abs(n));
            var b = Math.pow(10, bytes + 1);
            if (Math.abs(x) < 1) {
                x = Math.round(x * b) / b;
            } else {
                var tn = Math.pow(10, n + 1);
                x = Math.round(x / tn * b) / b * tn;
            }
            var s;
            if (bytes - sz - 6 === -1) {
                x = Math.round(x / Math.pow(10, n));
                x = x * Math.pow(10, n);
                s = sprintf("%1e", x).replace(/\.[^e]+/, "");
            } else if (bytes - sz - 6 < 0) return undefined; else {
                s = sprintf("%." + (bytes - sz - 6) + "e", x);
            }
            if (x > 0) s = " " + s;
            return pad(s, bytes);
        }
        function pad(s, bytes) {
            return Array(Math.max(0, bytes - s.length + 1)).join(" ") + s;
        }
        function log10f(n) {
            return Math.floor(Math.log(n) / Math.log(10));
        }
        function packf(x, bytes) {
            var lbytes = Math.max(1, Math.floor((bytes - 2) / 2));
            var rbytes = bytes - lbytes - 2;
            if (x === 0 && bytes < 4) {
                return pad("0", bytes);
            } else if (x === 0) {
                return pad("0." + Array(rbytes + 1).join("0"), bytes);
            }
            if (rbytes <= 0) {
                var s = sprintf("%" + lbytes + "f", x);
                if (x >= 0) s = " " + s;
                if (s.length > bytes) return undefined;
                return pad(s, bytes);
            }
            if (Math.abs(x) < Math.pow(10, 1 - rbytes)) return sci(x, bytes);
            var b = Math.pow(10, bytes - 3);
            var tn = Math.pow(10, log10f(Math.abs(x)));
            var xr = Math.round(x / tn * b) / b * tn;
            var s = sprintf("%" + lbytes + "." + rbytes + "f", xr);
            if (xr > 0) s = " " + s;
            s = s.slice(0, bytes);
            var r = s.split(".")[1];
            if (!r || r.length < 1) return sci(xr, bytes);
            return pad(s, bytes).slice(0, bytes);
        }
    }, {
        sprintf: 98
    } ],
    98: [ function(require, module, exports) {
        var sprintf = function() {
            function get_type(variable) {
                return Object.prototype.toString.call(variable).slice(8, -1).toLowerCase();
            }
            function str_repeat(input, multiplier) {
                for (var output = []; multiplier > 0; output[--multiplier] = input) {}
                return output.join("");
            }
            var str_format = function() {
                if (!str_format.cache.hasOwnProperty(arguments[0])) {
                    str_format.cache[arguments[0]] = str_format.parse(arguments[0]);
                }
                return str_format.format.call(null, str_format.cache[arguments[0]], arguments);
            };
            str_format.object_stringify = function(obj, depth, maxdepth, seen) {
                var str = "";
                if (obj != null) {
                    switch (typeof obj) {
                      case "function":
                        return "[Function" + (obj.name ? ": " + obj.name : "") + "]";
                        break;

                      case "object":
                        if (obj instanceof Error) {
                            return "[" + obj.toString() + "]";
                        }
                        ;
                        if (depth >= maxdepth) return "[Object]";
                        if (seen) {
                            seen = seen.slice(0);
                            seen.push(obj);
                        }
                        if (obj.length != null) {
                            str += "[";
                            var arr = [];
                            for (var i in obj) {
                                if (seen && seen.indexOf(obj[i]) >= 0) arr.push("[Circular]"); else arr.push(str_format.object_stringify(obj[i], depth + 1, maxdepth, seen));
                            }
                            str += arr.join(", ") + "]";
                        } else if ("getMonth" in obj) {
                            return "Date(" + obj + ")";
                        } else {
                            str += "{";
                            var arr = [];
                            for (var k in obj) {
                                if (obj.hasOwnProperty(k)) {
                                    if (seen && seen.indexOf(obj[k]) >= 0) arr.push(k + ": [Circular]"); else arr.push(k + ": " + str_format.object_stringify(obj[k], depth + 1, maxdepth, seen));
                                }
                            }
                            str += arr.join(", ") + "}";
                        }
                        return str;
                        break;

                      case "string":
                        return '"' + obj + '"';
                        break;
                    }
                }
                return "" + obj;
            };
            str_format.format = function(parse_tree, argv) {
                var cursor = 1, tree_length = parse_tree.length, node_type = "", arg, output = [], i, k, match, pad, pad_character, pad_length;
                for (i = 0; i < tree_length; i++) {
                    node_type = get_type(parse_tree[i]);
                    if (node_type === "string") {
                        output.push(parse_tree[i]);
                    } else if (node_type === "array") {
                        match = parse_tree[i];
                        if (match[2]) {
                            arg = argv[cursor];
                            for (k = 0; k < match[2].length; k++) {
                                if (!arg.hasOwnProperty(match[2][k])) {
                                    throw new Error(sprintf('[sprintf] property "%s" does not exist', match[2][k]));
                                }
                                arg = arg[match[2][k]];
                            }
                        } else if (match[1]) {
                            arg = argv[match[1]];
                        } else {
                            arg = argv[cursor++];
                        }
                        if (/[^sO]/.test(match[8]) && get_type(arg) != "number") {
                            throw new Error(sprintf('[sprintf] expecting number but found %s "' + arg + '"', get_type(arg)));
                        }
                        switch (match[8]) {
                          case "b":
                            arg = arg.toString(2);
                            break;

                          case "c":
                            arg = String.fromCharCode(arg);
                            break;

                          case "d":
                            arg = parseInt(arg, 10);
                            break;

                          case "e":
                            arg = match[7] ? arg.toExponential(match[7]) : arg.toExponential();
                            break;

                          case "f":
                            arg = match[7] ? parseFloat(arg).toFixed(match[7]) : parseFloat(arg);
                            break;

                          case "O":
                            arg = str_format.object_stringify(arg, 0, parseInt(match[7]) || 5);
                            break;

                          case "o":
                            arg = arg.toString(8);
                            break;

                          case "s":
                            arg = (arg = String(arg)) && match[7] ? arg.substring(0, match[7]) : arg;
                            break;

                          case "u":
                            arg = Math.abs(arg);
                            break;

                          case "x":
                            arg = arg.toString(16);
                            break;

                          case "X":
                            arg = arg.toString(16).toUpperCase();
                            break;
                        }
                        arg = /[def]/.test(match[8]) && match[3] && arg >= 0 ? "+" + arg : arg;
                        pad_character = match[4] ? match[4] == "0" ? "0" : match[4].charAt(1) : " ";
                        pad_length = match[6] - String(arg).length;
                        pad = match[6] ? str_repeat(pad_character, pad_length) : "";
                        output.push(match[5] ? arg + pad : pad + arg);
                    }
                }
                return output.join("");
            };
            str_format.cache = {};
            str_format.parse = function(fmt) {
                var _fmt = fmt, match = [], parse_tree = [], arg_names = 0;
                while (_fmt) {
                    if ((match = /^[^\x25]+/.exec(_fmt)) !== null) {
                        parse_tree.push(match[0]);
                    } else if ((match = /^\x25{2}/.exec(_fmt)) !== null) {
                        parse_tree.push("%");
                    } else if ((match = /^\x25(?:([1-9]\d*)\$|\(([^\)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-fosOuxX])/.exec(_fmt)) !== null) {
                        if (match[2]) {
                            arg_names |= 1;
                            var field_list = [], replacement_field = match[2], field_match = [];
                            if ((field_match = /^([a-z_][a-z_\d]*)/i.exec(replacement_field)) !== null) {
                                field_list.push(field_match[1]);
                                while ((replacement_field = replacement_field.substring(field_match[0].length)) !== "") {
                                    if ((field_match = /^\.([a-z_][a-z_\d]*)/i.exec(replacement_field)) !== null) {
                                        field_list.push(field_match[1]);
                                    } else if ((field_match = /^\[(\d+)\]/.exec(replacement_field)) !== null) {
                                        field_list.push(field_match[1]);
                                    } else {
                                        throw new Error("[sprintf] " + replacement_field);
                                    }
                                }
                            } else {
                                throw new Error("[sprintf] " + replacement_field);
                            }
                            match[2] = field_list;
                        } else {
                            arg_names |= 2;
                        }
                        if (arg_names === 3) {
                            throw new Error("[sprintf] mixing positional and named placeholders is not (yet) supported");
                        }
                        parse_tree.push(match);
                    } else {
                        throw new Error("[sprintf] " + _fmt);
                    }
                    _fmt = _fmt.substring(match[0].length);
                }
                return parse_tree;
            };
            return str_format;
        }();
        var vsprintf = function(fmt, argv) {
            var argvClone = argv.slice();
            argvClone.unshift(fmt);
            return sprintf.apply(null, argvClone);
        };
        module.exports = sprintf;
        sprintf.sprintf = sprintf;
        sprintf.vsprintf = vsprintf;
    }, {} ],
    99: [ function(require, module, exports) {
        arguments[4][93][0].apply(exports, arguments);
    }, {
        dup: 93
    } ],
    100: [ function(require, module, exports) {
        "use strict";
        var dup = require("dup");
        var do_unpack = require("cwise/lib/wrapper")({
            args: [ "array", "scalar", "index" ],
            pre: {
                body: "{}",
                args: [],
                thisVars: [],
                localVars: []
            },
            body: {
                body: "{var _inline_1_a,_inline_1_e=_inline_1_arg1_;for(_inline_1_a=0;_inline_1_a<_inline_1_arg2_.length-1;++_inline_1_a)_inline_1_e=_inline_1_e[_inline_1_arg2_[_inline_1_a]];_inline_1_e[_inline_1_arg2_[_inline_1_arg2_.length-1]]=_inline_1_arg0_}",
                args: [ {
                    name: "_inline_1_arg0_",
                    lvalue: false,
                    rvalue: true,
                    count: 1
                }, {
                    name: "_inline_1_arg1_",
                    lvalue: false,
                    rvalue: true,
                    count: 1
                }, {
                    name: "_inline_1_arg2_",
                    lvalue: false,
                    rvalue: true,
                    count: 4
                } ],
                thisVars: [],
                localVars: [ "_inline_1_a", "_inline_1_e" ]
            },
            post: {
                body: "{}",
                args: [],
                thisVars: [],
                localVars: []
            },
            debug: false,
            funcName: "unpackCwise",
            blockSize: 64
        });
        module.exports = function unpack(arr) {
            var result = dup(arr.shape);
            do_unpack(arr, result);
            return result;
        };
    }, {
        "cwise/lib/wrapper": 13,
        dup: 99
    } ],
    101: [ function(require, module, exports) {
        (function(Buffer) {
            var iota = require("iota-array");
            var hasTypedArrays = typeof Float64Array !== "undefined";
            var hasBuffer = typeof Buffer !== "undefined";
            function compare1st(a, b) {
                return a[0] - b[0];
            }
            function order() {
                var stride = this.stride;
                var terms = new Array(stride.length);
                var i;
                for (i = 0; i < terms.length; ++i) {
                    terms[i] = [ Math.abs(stride[i]), i ];
                }
                terms.sort(compare1st);
                var result = new Array(terms.length);
                for (i = 0; i < result.length; ++i) {
                    result[i] = terms[i][1];
                }
                return result;
            }
            function compileConstructor(dtype, dimension) {
                var className = [ "View", dimension, "d", dtype ].join("");
                if (dimension < 0) {
                    className = "View_Nil" + dtype;
                }
                var useGetters = dtype === "generic";
                if (dimension === -1) {
                    var code = "function " + className + "(a){this.data=a;};var proto=" + className + ".prototype;proto.dtype='" + dtype + "';proto.index=function(){return -1};proto.size=0;proto.dimension=-1;proto.shape=proto.stride=proto.order=[];proto.lo=proto.hi=proto.transpose=proto.step=function(){return new " + className + "(this.data);};proto.get=proto.set=function(){};proto.pick=function(){return null};return function construct_" + className + "(a){return new " + className + "(a);}";
                    var procedure = new Function(code);
                    return procedure();
                } else if (dimension === 0) {
                    var code = "function " + className + "(a,d) {this.data = a;this.offset = d};var proto=" + className + ".prototype;proto.dtype='" + dtype + "';proto.index=function(){return this.offset};proto.dimension=0;proto.size=1;proto.shape=proto.stride=proto.order=[];proto.lo=proto.hi=proto.transpose=proto.step=function " + className + "_copy() {return new " + className + "(this.data,this.offset)};proto.pick=function " + className + "_pick(){return TrivialArray(this.data);};proto.valueOf=proto.get=function " + className + "_get(){return " + (useGetters ? "this.data.get(this.offset)" : "this.data[this.offset]") + "};proto.set=function " + className + "_set(v){return " + (useGetters ? "this.data.set(this.offset,v)" : "this.data[this.offset]=v") + "};return function construct_" + className + "(a,b,c,d){return new " + className + "(a,d)}";
                    var procedure = new Function("TrivialArray", code);
                    return procedure(CACHED_CONSTRUCTORS[dtype][0]);
                }
                var code = [ "'use strict'" ];
                var indices = iota(dimension);
                var args = indices.map(function(i) {
                    return "i" + i;
                });
                var index_str = "this.offset+" + indices.map(function(i) {
                    return "this.stride[" + i + "]*i" + i;
                }).join("+");
                var shapeArg = indices.map(function(i) {
                    return "b" + i;
                }).join(",");
                var strideArg = indices.map(function(i) {
                    return "c" + i;
                }).join(",");
                code.push("function " + className + "(a," + shapeArg + "," + strideArg + ",d){this.data=a", "this.shape=[" + shapeArg + "]", "this.stride=[" + strideArg + "]", "this.offset=d|0}", "var proto=" + className + ".prototype", "proto.dtype='" + dtype + "'", "proto.dimension=" + dimension);
                code.push("Object.defineProperty(proto,'size',{get:function " + className + "_size(){return " + indices.map(function(i) {
                    return "this.shape[" + i + "]";
                }).join("*"), "}})");
                if (dimension === 1) {
                    code.push("proto.order=[0]");
                } else {
                    code.push("Object.defineProperty(proto,'order',{get:");
                    if (dimension < 4) {
                        code.push("function " + className + "_order(){");
                        if (dimension === 2) {
                            code.push("return (Math.abs(this.stride[0])>Math.abs(this.stride[1]))?[1,0]:[0,1]}})");
                        } else if (dimension === 3) {
                            code.push("var s0=Math.abs(this.stride[0]),s1=Math.abs(this.stride[1]),s2=Math.abs(this.stride[2]);if(s0>s1){if(s1>s2){return [2,1,0];}else if(s0>s2){return [1,2,0];}else{return [1,0,2];}}else if(s0>s2){return [2,0,1];}else if(s2>s1){return [0,1,2];}else{return [0,2,1];}}})");
                        }
                    } else {
                        code.push("ORDER})");
                    }
                }
                code.push("proto.set=function " + className + "_set(" + args.join(",") + ",v){");
                if (useGetters) {
                    code.push("return this.data.set(" + index_str + ",v)}");
                } else {
                    code.push("return this.data[" + index_str + "]=v}");
                }
                code.push("proto.get=function " + className + "_get(" + args.join(",") + "){");
                if (useGetters) {
                    code.push("return this.data.get(" + index_str + ")}");
                } else {
                    code.push("return this.data[" + index_str + "]}");
                }
                code.push("proto.index=function " + className + "_index(", args.join(), "){return " + index_str + "}");
                code.push("proto.hi=function " + className + "_hi(" + args.join(",") + "){return new " + className + "(this.data," + indices.map(function(i) {
                    return [ "(typeof i", i, "!=='number'||i", i, "<0)?this.shape[", i, "]:i", i, "|0" ].join("");
                }).join(",") + "," + indices.map(function(i) {
                    return "this.stride[" + i + "]";
                }).join(",") + ",this.offset)}");
                var a_vars = indices.map(function(i) {
                    return "a" + i + "=this.shape[" + i + "]";
                });
                var c_vars = indices.map(function(i) {
                    return "c" + i + "=this.stride[" + i + "]";
                });
                code.push("proto.lo=function " + className + "_lo(" + args.join(",") + "){var b=this.offset,d=0," + a_vars.join(",") + "," + c_vars.join(","));
                for (var i = 0; i < dimension; ++i) {
                    code.push("if(typeof i" + i + "==='number'&&i" + i + ">=0){d=i" + i + "|0;b+=c" + i + "*d;a" + i + "-=d}");
                }
                code.push("return new " + className + "(this.data," + indices.map(function(i) {
                    return "a" + i;
                }).join(",") + "," + indices.map(function(i) {
                    return "c" + i;
                }).join(",") + ",b)}");
                code.push("proto.step=function " + className + "_step(" + args.join(",") + "){var " + indices.map(function(i) {
                    return "a" + i + "=this.shape[" + i + "]";
                }).join(",") + "," + indices.map(function(i) {
                    return "b" + i + "=this.stride[" + i + "]";
                }).join(",") + ",c=this.offset,d=0,ceil=Math.ceil");
                for (var i = 0; i < dimension; ++i) {
                    code.push("if(typeof i" + i + "==='number'){d=i" + i + "|0;if(d<0){c+=b" + i + "*(a" + i + "-1);a" + i + "=ceil(-a" + i + "/d)}else{a" + i + "=ceil(a" + i + "/d)}b" + i + "*=d}");
                }
                code.push("return new " + className + "(this.data," + indices.map(function(i) {
                    return "a" + i;
                }).join(",") + "," + indices.map(function(i) {
                    return "b" + i;
                }).join(",") + ",c)}");
                var tShape = new Array(dimension);
                var tStride = new Array(dimension);
                for (var i = 0; i < dimension; ++i) {
                    tShape[i] = "a[i" + i + "]";
                    tStride[i] = "b[i" + i + "]";
                }
                code.push("proto.transpose=function " + className + "_transpose(" + args + "){" + args.map(function(n, idx) {
                    return n + "=(" + n + "===undefined?" + idx + ":" + n + "|0)";
                }).join(";"), "var a=this.shape,b=this.stride;return new " + className + "(this.data," + tShape.join(",") + "," + tStride.join(",") + ",this.offset)}");
                code.push("proto.pick=function " + className + "_pick(" + args + "){var a=[],b=[],c=this.offset");
                for (var i = 0; i < dimension; ++i) {
                    code.push("if(typeof i" + i + "==='number'&&i" + i + ">=0){c=(c+this.stride[" + i + "]*i" + i + ")|0}else{a.push(this.shape[" + i + "]);b.push(this.stride[" + i + "])}");
                }
                code.push("var ctor=CTOR_LIST[a.length+1];return ctor(this.data,a,b,c)}");
                code.push("return function construct_" + className + "(data,shape,stride,offset){return new " + className + "(data," + indices.map(function(i) {
                    return "shape[" + i + "]";
                }).join(",") + "," + indices.map(function(i) {
                    return "stride[" + i + "]";
                }).join(",") + ",offset)}");
                var procedure = new Function("CTOR_LIST", "ORDER", code.join("\n"));
                return procedure(CACHED_CONSTRUCTORS[dtype], order);
            }
            function arrayDType(data) {
                if (hasBuffer) {
                    if (Buffer.isBuffer(data)) {
                        return "buffer";
                    }
                }
                if (hasTypedArrays) {
                    switch (Object.prototype.toString.call(data)) {
                      case "[object Float64Array]":
                        return "float64";

                      case "[object Float32Array]":
                        return "float32";

                      case "[object Int8Array]":
                        return "int8";

                      case "[object Int16Array]":
                        return "int16";

                      case "[object Int32Array]":
                        return "int32";

                      case "[object Uint8Array]":
                        return "uint8";

                      case "[object Uint16Array]":
                        return "uint16";

                      case "[object Uint32Array]":
                        return "uint32";

                      case "[object Uint8ClampedArray]":
                        return "uint8_clamped";
                    }
                }
                if (Array.isArray(data)) {
                    return "array";
                }
                return "generic";
            }
            var CACHED_CONSTRUCTORS = {
                float32: [],
                float64: [],
                int8: [],
                int16: [],
                int32: [],
                uint8: [],
                uint16: [],
                uint32: [],
                array: [],
                uint8_clamped: [],
                buffer: [],
                generic: []
            };
            (function() {
                for (var id in CACHED_CONSTRUCTORS) {
                    CACHED_CONSTRUCTORS[id].push(compileConstructor(id, -1));
                }
            });
            function wrappedNDArrayCtor(data, shape, stride, offset) {
                if (data === undefined) {
                    var ctor = CACHED_CONSTRUCTORS.array[0];
                    return ctor([]);
                } else if (typeof data === "number") {
                    data = [ data ];
                }
                if (shape === undefined) {
                    shape = [ data.length ];
                }
                var d = shape.length;
                if (stride === undefined) {
                    stride = new Array(d);
                    for (var i = d - 1, sz = 1; i >= 0; --i) {
                        stride[i] = sz;
                        sz *= shape[i];
                    }
                }
                if (offset === undefined) {
                    offset = 0;
                    for (var i = 0; i < d; ++i) {
                        if (stride[i] < 0) {
                            offset -= (shape[i] - 1) * stride[i];
                        }
                    }
                }
                var dtype = arrayDType(data);
                var ctor_list = CACHED_CONSTRUCTORS[dtype];
                while (ctor_list.length <= d + 1) {
                    ctor_list.push(compileConstructor(dtype, ctor_list.length - 1));
                }
                var ctor = ctor_list[d + 1];
                return ctor(data, shape, stride, offset);
            }
            module.exports = wrappedNDArrayCtor;
        }).call(this, require("buffer").Buffer);
    }, {
        buffer: 3,
        "iota-array": 102
    } ],
    102: [ function(require, module, exports) {
        "use strict";
        function iota(n) {
            var result = new Array(n);
            for (var i = 0; i < n; ++i) {
                result[i] = i;
            }
            return result;
        }
        module.exports = iota;
    }, {} ],
    103: [ function(require, module, exports) {
        "use strict";
        module.exports = matrixProduct;
        var generatePlan = require("./lib/planner.js");
        function shape(arr) {
            if (Array.isArray(arr)) {
                return [ arr.length, arr[0].length ];
            } else {
                return arr.shape;
            }
        }
        function checkShapes(out, a, b) {
            var os = shape(out);
            var as = shape(a);
            var bs = shape(b);
            if (os[0] !== as[0] || os[1] !== bs[1] || as[1] !== bs[0]) {
                throw new Error("Mismatched array shapes for matrix product");
            }
        }
        function classifyType(m) {
            if (Array.isArray(m)) {
                if (Array.isArray(m)) {
                    return [ "r", "native" ];
                }
            } else if (m.shape && m.shape.length === 2) {
                if (m.order[0]) {
                    return [ "r", m.dtype ];
                } else {
                    return [ "c", m.dtype ];
                }
            }
            throw new Error("Unrecognized data type");
        }
        var CACHE = {};
        function matrixProduct(out, a, b, alpha, beta) {
            if (alpha === undefined) {
                alpha = 1;
            }
            if (beta === undefined) {
                beta = 0;
            }
            var useAlpha = alpha !== 1;
            var useBeta = beta !== 0;
            var outType = classifyType(out);
            var aType = classifyType(a);
            var bType = classifyType(b);
            checkShapes(out, a, b);
            var typeSig = [ outType, aType, bType, useAlpha, useBeta ].join(":");
            var proc = CACHE[typeSig];
            if (!proc) {
                proc = CACHE[typeSig] = generatePlan(outType, aType, bType, useAlpha, useBeta);
            }
            return proc(out, a, b, alpha, beta);
        }
    }, {
        "./lib/planner.js": 104
    } ],
    104: [ function(require, module, exports) {
        "use strict";
        module.exports = generateMatrixProduct;
        var BLOCK_SIZE = 32;
        function unpackOrder(order) {
            return order === "r" ? [ 1, 0 ] : [ 0, 1 ];
        }
        function unpackShape(name, type) {
            if (type[1] === "native") {
                return [ name, "d0=", name, ".length,", name, "d1=", name, "[0].length," ].join("");
            } else {
                return [ name, "d0=", name, ".shape[0],", name, "d1=", name, ".shape[1],", name, "s0=", name, ".stride[0],", name, "s1=", name, ".stride[1],", name, "o=", name, ".offset,", name, "d=", name, ".data," ].join("");
            }
        }
        function start(order, name, type, i, j, w) {
            var code = [];
            if (type[1] === "native") {
                if (order[0]) {
                    if (i) {
                        code.push("var ", name, "p=", name, "[", i, "];");
                    } else {
                        code.push("var ", name, "p=", name, "[0];");
                    }
                }
            } else {
                if (i && j) {
                    if (w) {
                        code.push("var ", name, "t0=", name, "s", order[0], ",", name, "t1=", name, "s", order[1], "-", name, "s", order[0], "*", w, ",", name, "p=", name, "o+", i, "*", name, "s0+", j, "*", name, "s1;");
                    } else {
                        code.push("var ", name, "t0=", name, "s", order[0], ",", name, "p=", name, "o+", i, "*", name, "s0+", j, "*", name, "s1;");
                    }
                } else if (i) {
                    code.push("var ", name, "t0=", name, "s", order[0], ",", name, "p=", name, "o+", i, "*", name, "s0;");
                } else if (j) {
                    code.push("var ", name, "t0=", name, "s", order[0], ",", name, "p=", name, "o+", j, "*", name, "s1;");
                } else {
                    code.push("var ", name, "t0=", name, "s", order[0], ",", name, "t1=", name, "s", order[1], "-", name, "s", order[0], "*", name, "d", order[0], ",", name, "p=", name, "o;");
                }
            }
            return code;
        }
        function walk(order, name, type, d, i) {
            var code = [];
            if (type[1] === "native") {
                if (order[0] && d === 1) {
                    code.push(name, "p=", name, "[", i, "+1]");
                }
            } else {
                code.push(name, "p+=", name, "t", d, ";");
            }
            return code;
        }
        function write(order, name, type, i, j, w) {
            var code = [];
            if (type[1] === "native") {
                if (order[0]) {
                    code.push(name, "p[", j, "]=", w, ";");
                } else {
                    code.push(name, "[", i, "][", j, "]=", w, ";");
                }
            } else if (type[1] === "generic") {
                code.push(name, "d.set(", name, "p,", w, ");");
            } else {
                code.push(name, "d[", name, "p]=", w, ";");
            }
            return code;
        }
        function read(order, name, type, i, j) {
            var code = [];
            if (type[1] === "native") {
                if (order[0]) {
                    code.push(name, "p[", j, "]");
                } else {
                    code.push(name, "[", i, "][", j, "]");
                }
            } else if (type[1] === "generic") {
                code.push(name, "d.get(", name, "p)");
            } else {
                code.push(name, "d[", name, "p]");
            }
            return code.join("");
        }
        function generateRowColumnLoop(oType, aType, bType, useAlpha, useBeta) {
            var code = [];
            var oOrd = oType[0] === "r" ? [ 1, 0 ] : [ 0, 1 ], aOrd = [ 1, 0 ], bOrd = [ 0, 1 ];
            var symbols = [ "i", "j" ];
            code.push.apply(code, start(oOrd, "o", oType));
            if (oOrd[1]) {
                code.push("for(j=0;j<od1;++j){");
                code.push("for(i=0;i<od0;++i){");
            } else {
                code.push("for(i=0;i<od0;++i){");
                code.push("for(j=0;j<od1;++j){");
            }
            code.push.apply(code, start(aOrd, "a", aType, "i"));
            code.push.apply(code, start(bOrd, "b", bType, undefined, "j"));
            code.push("var r=0.0;", "for(k=0;k<ad1;++k){", "r+=", read(aOrd, "a", aType, "i", "k"), "*", read(bOrd, "b", bType, "k", "j"), ";");
            code.push.apply(code, walk(aOrd, "a", aType, 0, "k"));
            code.push.apply(code, walk(bOrd, "b", bType, 0, "k"));
            code.push("}");
            if (useAlpha) {
                code.push("r*=A;");
            }
            if (useBeta) {
                code.push("r+=B*", read(oOrd, "o", oType, "i", "j"), ";");
            }
            code.push.apply(code, write(oOrd, "o", oType, "i", "j", "r"));
            code.push.apply(code, walk(oOrd, "o", oType, 0, symbols[1]));
            code.push("}");
            code.push.apply(code, walk(oOrd, "o", oType, 1, symbols[0]));
            code.push("}");
            return code;
        }
        function generateBetaPass(oType, useBeta) {
            var code = [];
            var oOrd = oType[0] === "r" ? [ 1, 0 ] : [ 0, 1 ], symbols;
            if (useBeta) {
                code.push("if(B!==1.0){");
            }
            code.push.apply(code, start(oOrd, "o", oType));
            if (oOrd[0]) {
                code.push("for(i=0;i<od0;++i){for(j=0;j<od1;++j){");
                symbols = [ "i", "j" ];
            } else {
                code.push("for(j=0;j<od1;++j){for(i=0;i<od0;++i){");
                symbols = [ "j", "i" ];
            }
            if (useBeta) {
                code.push.apply(code, write(oOrd, "o", oType, "i", "j", "B*" + read(oOrd, "o", oType, "i", "j")));
            } else {
                code.push.apply(code, write(oOrd, "o", oType, "i", "j", "0"));
            }
            code.push.apply(code, walk(oOrd, "o", oType, 0, symbols[1]));
            code.push("}");
            code.push.apply(code, walk(oOrd, "o", oType, 1, symbols[0]));
            code.push("}");
            if (useBeta) {
                code.push("}");
            }
            return code;
        }
        function generateBlockLoop(oType, aType, bType, useAlpha, useBeta) {
            var code = [];
            var shapes = [ "od0", "od1", "ad1" ];
            var oOrd = [ 1, 0 ];
            var aOrd = [ 1, 0 ];
            var bOrd = [ 0, 1 ];
            code.push.apply(code, generateBetaPass(oType, useBeta));
            for (var i = 0; i < 3; ++i) {
                code.push("for(var i", i, "=", shapes[i], ";i", i, ">0;){", "var w", i, "=", BLOCK_SIZE, ";", "if(i", i, "<", BLOCK_SIZE, "){", "w", i, "=i", i, ";", "i", i, "=0;", "}else{", "i", i, "-=", BLOCK_SIZE, ";", "}");
            }
            code.push.apply(code, start(oOrd, "o", oType, "i0", "i1", "w1"));
            code.push("for(i=0;i<w0;++i){for(j=0;j<w1;++j){var r=0.0;");
            code.push.apply(code, start(aOrd, "a", aType, "(i0+i)", "i2"));
            code.push.apply(code, start(bOrd, "b", bType, "i2", "(i1+j)"));
            code.push("for(k=0;k<w2;++k){");
            code.push("r+=", read(aOrd, "a", aType, "(i0+i)", "(i2+k)"), "*", read(bOrd, "b", bType, "(i2+k)", "(i1+j)"), ";");
            code.push.apply(code, walk(aOrd, "a", aType, 0, "(i2+k)"));
            code.push.apply(code, walk(bOrd, "b", bType, 0, "(i2+k)"));
            code.push("}");
            var sym = "r";
            if (useAlpha) {
                sym = "A*r";
            }
            code.push.apply(code, write(oOrd, "o", oType, "(i0+i)", "(i1+j)", sym + "+" + read(oOrd, "o", oType, "(i0+i)", "(i1+j)")));
            code.push.apply(code, walk(oOrd, "o", oType, 0, "(i1+j)"));
            code.push("}");
            code.push.apply(code, walk(oOrd, "o", oType, 1, "(i0+i)"));
            code.push("}}}}");
            return code;
        }
        function generateMatrixProduct(outType, aType, bType, useAlpha, useBeta) {
            var funcName = [ "gemm", outType[0], outType[1], "a", aType[0], aType[1], "b", bType[0], bType[1], useAlpha ? "alpha" : "", useBeta ? "beta" : "" ].join("");
            var code = [ "function ", funcName, "(o,a,b,A,B){", "var ", unpackShape("o", outType), unpackShape("a", aType), unpackShape("b", bType), "i,j,k;" ];
            if (aType[0] === "r" && bType[0] === "c") {
                code.push.apply(code, generateRowColumnLoop(outType, aType, bType, useAlpha, useBeta));
            } else {
                code.push.apply(code, generateBlockLoop(outType, aType, bType, useAlpha, useBeta));
            }
            code.push("}return ", funcName);
            var proc = new Function(code.join(""));
            return proc();
        }
    }, {} ],
    105: [ function(require, module, exports) {
        (function(root, factory) {
            if (typeof module === "object" && module.exports) {
                module.exports = function(_) {
                    _ = _ || require("underscore");
                    return factory(_);
                };
            } else if (typeof define === "function" && define.amd) {
                define([ "underscore" ], function(_) {
                    return factory(_, root);
                });
            } else {
                root.postal = factory(root._, root);
            }
        })(this, function(_, global, undefined) {
            var postal;
            var ConsecutiveDistinctPredicate = function() {
                var previous;
                return function(data) {
                    var eq = false;
                    if (_.isString(data)) {
                        eq = data === previous;
                        previous = data;
                    } else {
                        eq = _.isEqual(data, previous);
                        previous = _.clone(data);
                    }
                    return !eq;
                };
            };
            var DistinctPredicate = function() {
                var previous = [];
                return function(data) {
                    var isDistinct = !_.any(previous, function(p) {
                        if (_.isObject(data) || _.isArray(data)) {
                            return _.isEqual(data, p);
                        }
                        return data === p;
                    });
                    if (isDistinct) {
                        previous.push(data);
                    }
                    return isDistinct;
                };
            };
            var ChannelDefinition = function(channelName) {
                this.channel = channelName || postal.configuration.DEFAULT_CHANNEL;
            };
            ChannelDefinition.prototype.subscribe = function() {
                return arguments.length === 1 ? new SubscriptionDefinition(this.channel, arguments[0].topic, arguments[0].callback) : new SubscriptionDefinition(this.channel, arguments[0], arguments[1]);
            };
            ChannelDefinition.prototype.publish = function() {
                var envelope = arguments.length === 1 ? Object.prototype.toString.call(arguments[0]) === "[object String]" ? {
                    topic: arguments[0]
                } : arguments[0] : {
                    topic: arguments[0],
                    data: arguments[1]
                };
                envelope.channel = this.channel;
                return postal.configuration.bus.publish(envelope);
            };
            var SubscriptionDefinition = function(channel, topic, callback) {
                this.channel = channel;
                this.topic = topic;
                this.callback = callback;
                this.constraints = [];
                this.context = null;
                postal.configuration.bus.publish({
                    channel: postal.configuration.SYSTEM_CHANNEL,
                    topic: "subscription.created",
                    data: {
                        event: "subscription.created",
                        channel: channel,
                        topic: topic
                    }
                });
                postal.configuration.bus.subscribe(this);
            };
            SubscriptionDefinition.prototype = {
                unsubscribe: function() {
                    if (!this.inactive) {
                        this.inactive = true;
                        postal.configuration.bus.unsubscribe(this);
                        postal.configuration.bus.publish({
                            channel: postal.configuration.SYSTEM_CHANNEL,
                            topic: "subscription.removed",
                            data: {
                                event: "subscription.removed",
                                channel: this.channel,
                                topic: this.topic
                            }
                        });
                    }
                },
                defer: function() {
                    var self = this;
                    var fn = this.callback;
                    this.callback = function(data, env) {
                        setTimeout(function() {
                            fn.call(self.context, data, env);
                        }, 0);
                    };
                    return this;
                },
                disposeAfter: function(maxCalls) {
                    if (_.isNaN(maxCalls) || maxCalls <= 0) {
                        throw "The value provided to disposeAfter (maxCalls) must be a number greater than zero.";
                    }
                    var self = this;
                    var fn = this.callback;
                    var dispose = _.after(maxCalls, _.bind(function() {
                        this.unsubscribe();
                    }, this));
                    this.callback = function() {
                        fn.apply(self.context, arguments);
                        dispose();
                    };
                    return this;
                },
                distinctUntilChanged: function() {
                    this.withConstraint(new ConsecutiveDistinctPredicate());
                    return this;
                },
                distinct: function() {
                    this.withConstraint(new DistinctPredicate());
                    return this;
                },
                once: function() {
                    this.disposeAfter(1);
                    return this;
                },
                withConstraint: function(predicate) {
                    if (!_.isFunction(predicate)) {
                        throw "Predicate constraint must be a function";
                    }
                    this.constraints.push(predicate);
                    return this;
                },
                withConstraints: function(predicates) {
                    var self = this;
                    if (_.isArray(predicates)) {
                        _.each(predicates, function(predicate) {
                            self.withConstraint(predicate);
                        });
                    }
                    return self;
                },
                withContext: function(context) {
                    this.context = context;
                    return this;
                },
                withDebounce: function(milliseconds, immediate) {
                    if (_.isNaN(milliseconds)) {
                        throw "Milliseconds must be a number";
                    }
                    var fn = this.callback;
                    this.callback = _.debounce(fn, milliseconds, !!immediate);
                    return this;
                },
                withDelay: function(milliseconds) {
                    if (_.isNaN(milliseconds)) {
                        throw "Milliseconds must be a number";
                    }
                    var self = this;
                    var fn = this.callback;
                    this.callback = function(data, env) {
                        setTimeout(function() {
                            fn.call(self.context, data, env);
                        }, milliseconds);
                    };
                    return this;
                },
                withThrottle: function(milliseconds) {
                    if (_.isNaN(milliseconds)) {
                        throw "Milliseconds must be a number";
                    }
                    var fn = this.callback;
                    this.callback = _.throttle(fn, milliseconds);
                    return this;
                },
                subscribe: function(callback) {
                    this.callback = callback;
                    return this;
                }
            };
            var bindingsResolver = {
                cache: {},
                regex: {},
                compare: function(binding, topic) {
                    var pattern, rgx, prevSegment, result = this.cache[topic] && this.cache[topic][binding];
                    if (typeof result !== "undefined") {
                        return result;
                    }
                    if (!(rgx = this.regex[binding])) {
                        pattern = "^" + _.map(binding.split("."), function(segment) {
                            var res = "";
                            if (!!prevSegment) {
                                res = prevSegment !== "#" ? "\\.\\b" : "\\b";
                            }
                            if (segment === "#") {
                                res += "[\\s\\S]*";
                            } else if (segment === "*") {
                                res += "[^.]+";
                            } else {
                                res += segment;
                            }
                            prevSegment = segment;
                            return res;
                        }).join("") + "$";
                        rgx = this.regex[binding] = new RegExp(pattern);
                    }
                    this.cache[topic] = this.cache[topic] || {};
                    this.cache[topic][binding] = result = rgx.test(topic);
                    return result;
                },
                reset: function() {
                    this.cache = {};
                    this.regex = {};
                }
            };
            var fireSub = function(subDef, envelope) {
                if (!subDef.inactive && postal.configuration.resolver.compare(subDef.topic, envelope.topic)) {
                    if (_.all(subDef.constraints, function(constraint) {
                        return constraint.call(subDef.context, envelope.data, envelope);
                    })) {
                        if (typeof subDef.callback === "function") {
                            subDef.callback.call(subDef.context, envelope.data, envelope);
                        }
                    }
                }
            };
            var pubInProgress = 0;
            var unSubQueue = [];
            var clearUnSubQueue = function() {
                while (unSubQueue.length) {
                    localBus.unsubscribe(unSubQueue.shift());
                }
            };
            var localBus = {
                addWireTap: function(callback) {
                    var self = this;
                    self.wireTaps.push(callback);
                    return function() {
                        var idx = self.wireTaps.indexOf(callback);
                        if (idx !== -1) {
                            self.wireTaps.splice(idx, 1);
                        }
                    };
                },
                publish: function(envelope) {
                    ++pubInProgress;
                    envelope.timeStamp = new Date();
                    _.each(this.wireTaps, function(tap) {
                        tap(envelope.data, envelope);
                    });
                    if (this.subscriptions[envelope.channel]) {
                        _.each(this.subscriptions[envelope.channel], function(subscribers) {
                            var idx = 0, len = subscribers.length, subDef;
                            while (idx < len) {
                                if (subDef = subscribers[idx++]) {
                                    fireSub(subDef, envelope);
                                }
                            }
                        });
                    }
                    if (--pubInProgress === 0) {
                        clearUnSubQueue();
                    }
                    return envelope;
                },
                reset: function() {
                    if (this.subscriptions) {
                        _.each(this.subscriptions, function(channel) {
                            _.each(channel, function(topic) {
                                while (topic.length) {
                                    topic.pop().unsubscribe();
                                }
                            });
                        });
                        this.subscriptions = {};
                    }
                },
                subscribe: function(subDef) {
                    var channel = this.subscriptions[subDef.channel], subs;
                    if (!channel) {
                        channel = this.subscriptions[subDef.channel] = {};
                    }
                    subs = this.subscriptions[subDef.channel][subDef.topic];
                    if (!subs) {
                        subs = this.subscriptions[subDef.channel][subDef.topic] = [];
                    }
                    subs.push(subDef);
                    return subDef;
                },
                subscriptions: {},
                wireTaps: [],
                unsubscribe: function(config) {
                    if (pubInProgress) {
                        unSubQueue.push(config);
                        return;
                    }
                    if (this.subscriptions[config.channel][config.topic]) {
                        var len = this.subscriptions[config.channel][config.topic].length, idx = 0;
                        while (idx < len) {
                            if (this.subscriptions[config.channel][config.topic][idx] === config) {
                                this.subscriptions[config.channel][config.topic].splice(idx, 1);
                                break;
                            }
                            idx += 1;
                        }
                    }
                }
            };
            postal = {
                configuration: {
                    bus: localBus,
                    resolver: bindingsResolver,
                    DEFAULT_CHANNEL: "/",
                    SYSTEM_CHANNEL: "postal"
                },
                ChannelDefinition: ChannelDefinition,
                SubscriptionDefinition: SubscriptionDefinition,
                channel: function(channelName) {
                    return new ChannelDefinition(channelName);
                },
                subscribe: function(options) {
                    return new SubscriptionDefinition(options.channel || postal.configuration.DEFAULT_CHANNEL, options.topic, options.callback);
                },
                publish: function(envelope) {
                    envelope.channel = envelope.channel || postal.configuration.DEFAULT_CHANNEL;
                    return postal.configuration.bus.publish(envelope);
                },
                addWireTap: function(callback) {
                    return this.configuration.bus.addWireTap(callback);
                },
                linkChannels: function(sources, destinations) {
                    var result = [];
                    sources = !_.isArray(sources) ? [ sources ] : sources;
                    destinations = !_.isArray(destinations) ? [ destinations ] : destinations;
                    _.each(sources, function(source) {
                        var sourceTopic = source.topic || "#";
                        _.each(destinations, function(destination) {
                            var destChannel = destination.channel || postal.configuration.DEFAULT_CHANNEL;
                            result.push(postal.subscribe({
                                channel: source.channel || postal.configuration.DEFAULT_CHANNEL,
                                topic: sourceTopic,
                                callback: function(data, env) {
                                    var newEnv = _.clone(env);
                                    newEnv.topic = _.isFunction(destination.topic) ? destination.topic(env.topic) : destination.topic || env.topic;
                                    newEnv.channel = destChannel;
                                    newEnv.data = data;
                                    postal.publish(newEnv);
                                }
                            }));
                        });
                    });
                    return result;
                },
                utils: {
                    getSubscribersFor: function() {
                        var channel = arguments[0], tpc = arguments[1];
                        if (arguments.length === 1) {
                            channel = arguments[0].channel || postal.configuration.DEFAULT_CHANNEL;
                            tpc = arguments[0].topic;
                        }
                        if (postal.configuration.bus.subscriptions[channel] && Object.prototype.hasOwnProperty.call(postal.configuration.bus.subscriptions[channel], tpc)) {
                            return postal.configuration.bus.subscriptions[channel][tpc];
                        }
                        return [];
                    },
                    reset: function() {
                        postal.configuration.bus.reset();
                        postal.configuration.resolver.reset();
                    }
                }
            };
            localBus.subscriptions[postal.configuration.SYSTEM_CHANNEL] = {};
            if (global && Object.prototype.hasOwnProperty.call(global, "__postalReady__") && _.isArray(global.__postalReady__)) {
                while (global.__postalReady__.length) {
                    global.__postalReady__.shift().onReady(postal);
                }
            }
            return postal;
        });
    }, {
        underscore: 106
    } ],
    106: [ function(require, module, exports) {
        (function() {
            var root = this;
            var previousUnderscore = root._;
            var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;
            var push = ArrayProto.push, slice = ArrayProto.slice, toString = ObjProto.toString, hasOwnProperty = ObjProto.hasOwnProperty;
            var nativeIsArray = Array.isArray, nativeKeys = Object.keys, nativeBind = FuncProto.bind, nativeCreate = Object.create;
            var Ctor = function() {};
            var _ = function(obj) {
                if (obj instanceof _) return obj;
                if (!(this instanceof _)) return new _(obj);
                this._wrapped = obj;
            };
            if (typeof exports !== "undefined") {
                if (typeof module !== "undefined" && module.exports) {
                    exports = module.exports = _;
                }
                exports._ = _;
            } else {
                root._ = _;
            }
            _.VERSION = "1.8.3";
            var optimizeCb = function(func, context, argCount) {
                if (context === void 0) return func;
                switch (argCount == null ? 3 : argCount) {
                  case 1:
                    return function(value) {
                        return func.call(context, value);
                    };

                  case 2:
                    return function(value, other) {
                        return func.call(context, value, other);
                    };

                  case 3:
                    return function(value, index, collection) {
                        return func.call(context, value, index, collection);
                    };

                  case 4:
                    return function(accumulator, value, index, collection) {
                        return func.call(context, accumulator, value, index, collection);
                    };
                }
                return function() {
                    return func.apply(context, arguments);
                };
            };
            var cb = function(value, context, argCount) {
                if (value == null) return _.identity;
                if (_.isFunction(value)) return optimizeCb(value, context, argCount);
                if (_.isObject(value)) return _.matcher(value);
                return _.property(value);
            };
            _.iteratee = function(value, context) {
                return cb(value, context, Infinity);
            };
            var createAssigner = function(keysFunc, undefinedOnly) {
                return function(obj) {
                    var length = arguments.length;
                    if (length < 2 || obj == null) return obj;
                    for (var index = 1; index < length; index++) {
                        var source = arguments[index], keys = keysFunc(source), l = keys.length;
                        for (var i = 0; i < l; i++) {
                            var key = keys[i];
                            if (!undefinedOnly || obj[key] === void 0) obj[key] = source[key];
                        }
                    }
                    return obj;
                };
            };
            var baseCreate = function(prototype) {
                if (!_.isObject(prototype)) return {};
                if (nativeCreate) return nativeCreate(prototype);
                Ctor.prototype = prototype;
                var result = new Ctor();
                Ctor.prototype = null;
                return result;
            };
            var property = function(key) {
                return function(obj) {
                    return obj == null ? void 0 : obj[key];
                };
            };
            var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
            var getLength = property("length");
            var isArrayLike = function(collection) {
                var length = getLength(collection);
                return typeof length == "number" && length >= 0 && length <= MAX_ARRAY_INDEX;
            };
            _.each = _.forEach = function(obj, iteratee, context) {
                iteratee = optimizeCb(iteratee, context);
                var i, length;
                if (isArrayLike(obj)) {
                    for (i = 0, length = obj.length; i < length; i++) {
                        iteratee(obj[i], i, obj);
                    }
                } else {
                    var keys = _.keys(obj);
                    for (i = 0, length = keys.length; i < length; i++) {
                        iteratee(obj[keys[i]], keys[i], obj);
                    }
                }
                return obj;
            };
            _.map = _.collect = function(obj, iteratee, context) {
                iteratee = cb(iteratee, context);
                var keys = !isArrayLike(obj) && _.keys(obj), length = (keys || obj).length, results = Array(length);
                for (var index = 0; index < length; index++) {
                    var currentKey = keys ? keys[index] : index;
                    results[index] = iteratee(obj[currentKey], currentKey, obj);
                }
                return results;
            };
            function createReduce(dir) {
                function iterator(obj, iteratee, memo, keys, index, length) {
                    for (;index >= 0 && index < length; index += dir) {
                        var currentKey = keys ? keys[index] : index;
                        memo = iteratee(memo, obj[currentKey], currentKey, obj);
                    }
                    return memo;
                }
                return function(obj, iteratee, memo, context) {
                    iteratee = optimizeCb(iteratee, context, 4);
                    var keys = !isArrayLike(obj) && _.keys(obj), length = (keys || obj).length, index = dir > 0 ? 0 : length - 1;
                    if (arguments.length < 3) {
                        memo = obj[keys ? keys[index] : index];
                        index += dir;
                    }
                    return iterator(obj, iteratee, memo, keys, index, length);
                };
            }
            _.reduce = _.foldl = _.inject = createReduce(1);
            _.reduceRight = _.foldr = createReduce(-1);
            _.find = _.detect = function(obj, predicate, context) {
                var key;
                if (isArrayLike(obj)) {
                    key = _.findIndex(obj, predicate, context);
                } else {
                    key = _.findKey(obj, predicate, context);
                }
                if (key !== void 0 && key !== -1) return obj[key];
            };
            _.filter = _.select = function(obj, predicate, context) {
                var results = [];
                predicate = cb(predicate, context);
                _.each(obj, function(value, index, list) {
                    if (predicate(value, index, list)) results.push(value);
                });
                return results;
            };
            _.reject = function(obj, predicate, context) {
                return _.filter(obj, _.negate(cb(predicate)), context);
            };
            _.every = _.all = function(obj, predicate, context) {
                predicate = cb(predicate, context);
                var keys = !isArrayLike(obj) && _.keys(obj), length = (keys || obj).length;
                for (var index = 0; index < length; index++) {
                    var currentKey = keys ? keys[index] : index;
                    if (!predicate(obj[currentKey], currentKey, obj)) return false;
                }
                return true;
            };
            _.some = _.any = function(obj, predicate, context) {
                predicate = cb(predicate, context);
                var keys = !isArrayLike(obj) && _.keys(obj), length = (keys || obj).length;
                for (var index = 0; index < length; index++) {
                    var currentKey = keys ? keys[index] : index;
                    if (predicate(obj[currentKey], currentKey, obj)) return true;
                }
                return false;
            };
            _.contains = _.includes = _.include = function(obj, item, fromIndex, guard) {
                if (!isArrayLike(obj)) obj = _.values(obj);
                if (typeof fromIndex != "number" || guard) fromIndex = 0;
                return _.indexOf(obj, item, fromIndex) >= 0;
            };
            _.invoke = function(obj, method) {
                var args = slice.call(arguments, 2);
                var isFunc = _.isFunction(method);
                return _.map(obj, function(value) {
                    var func = isFunc ? method : value[method];
                    return func == null ? func : func.apply(value, args);
                });
            };
            _.pluck = function(obj, key) {
                return _.map(obj, _.property(key));
            };
            _.where = function(obj, attrs) {
                return _.filter(obj, _.matcher(attrs));
            };
            _.findWhere = function(obj, attrs) {
                return _.find(obj, _.matcher(attrs));
            };
            _.max = function(obj, iteratee, context) {
                var result = -Infinity, lastComputed = -Infinity, value, computed;
                if (iteratee == null && obj != null) {
                    obj = isArrayLike(obj) ? obj : _.values(obj);
                    for (var i = 0, length = obj.length; i < length; i++) {
                        value = obj[i];
                        if (value > result) {
                            result = value;
                        }
                    }
                } else {
                    iteratee = cb(iteratee, context);
                    _.each(obj, function(value, index, list) {
                        computed = iteratee(value, index, list);
                        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
                            result = value;
                            lastComputed = computed;
                        }
                    });
                }
                return result;
            };
            _.min = function(obj, iteratee, context) {
                var result = Infinity, lastComputed = Infinity, value, computed;
                if (iteratee == null && obj != null) {
                    obj = isArrayLike(obj) ? obj : _.values(obj);
                    for (var i = 0, length = obj.length; i < length; i++) {
                        value = obj[i];
                        if (value < result) {
                            result = value;
                        }
                    }
                } else {
                    iteratee = cb(iteratee, context);
                    _.each(obj, function(value, index, list) {
                        computed = iteratee(value, index, list);
                        if (computed < lastComputed || computed === Infinity && result === Infinity) {
                            result = value;
                            lastComputed = computed;
                        }
                    });
                }
                return result;
            };
            _.shuffle = function(obj) {
                var set = isArrayLike(obj) ? obj : _.values(obj);
                var length = set.length;
                var shuffled = Array(length);
                for (var index = 0, rand; index < length; index++) {
                    rand = _.random(0, index);
                    if (rand !== index) shuffled[index] = shuffled[rand];
                    shuffled[rand] = set[index];
                }
                return shuffled;
            };
            _.sample = function(obj, n, guard) {
                if (n == null || guard) {
                    if (!isArrayLike(obj)) obj = _.values(obj);
                    return obj[_.random(obj.length - 1)];
                }
                return _.shuffle(obj).slice(0, Math.max(0, n));
            };
            _.sortBy = function(obj, iteratee, context) {
                iteratee = cb(iteratee, context);
                return _.pluck(_.map(obj, function(value, index, list) {
                    return {
                        value: value,
                        index: index,
                        criteria: iteratee(value, index, list)
                    };
                }).sort(function(left, right) {
                    var a = left.criteria;
                    var b = right.criteria;
                    if (a !== b) {
                        if (a > b || a === void 0) return 1;
                        if (a < b || b === void 0) return -1;
                    }
                    return left.index - right.index;
                }), "value");
            };
            var group = function(behavior) {
                return function(obj, iteratee, context) {
                    var result = {};
                    iteratee = cb(iteratee, context);
                    _.each(obj, function(value, index) {
                        var key = iteratee(value, index, obj);
                        behavior(result, value, key);
                    });
                    return result;
                };
            };
            _.groupBy = group(function(result, value, key) {
                if (_.has(result, key)) result[key].push(value); else result[key] = [ value ];
            });
            _.indexBy = group(function(result, value, key) {
                result[key] = value;
            });
            _.countBy = group(function(result, value, key) {
                if (_.has(result, key)) result[key]++; else result[key] = 1;
            });
            _.toArray = function(obj) {
                if (!obj) return [];
                if (_.isArray(obj)) return slice.call(obj);
                if (isArrayLike(obj)) return _.map(obj, _.identity);
                return _.values(obj);
            };
            _.size = function(obj) {
                if (obj == null) return 0;
                return isArrayLike(obj) ? obj.length : _.keys(obj).length;
            };
            _.partition = function(obj, predicate, context) {
                predicate = cb(predicate, context);
                var pass = [], fail = [];
                _.each(obj, function(value, key, obj) {
                    (predicate(value, key, obj) ? pass : fail).push(value);
                });
                return [ pass, fail ];
            };
            _.first = _.head = _.take = function(array, n, guard) {
                if (array == null) return void 0;
                if (n == null || guard) return array[0];
                return _.initial(array, array.length - n);
            };
            _.initial = function(array, n, guard) {
                return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
            };
            _.last = function(array, n, guard) {
                if (array == null) return void 0;
                if (n == null || guard) return array[array.length - 1];
                return _.rest(array, Math.max(0, array.length - n));
            };
            _.rest = _.tail = _.drop = function(array, n, guard) {
                return slice.call(array, n == null || guard ? 1 : n);
            };
            _.compact = function(array) {
                return _.filter(array, _.identity);
            };
            var flatten = function(input, shallow, strict, startIndex) {
                var output = [], idx = 0;
                for (var i = startIndex || 0, length = getLength(input); i < length; i++) {
                    var value = input[i];
                    if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {
                        if (!shallow) value = flatten(value, shallow, strict);
                        var j = 0, len = value.length;
                        output.length += len;
                        while (j < len) {
                            output[idx++] = value[j++];
                        }
                    } else if (!strict) {
                        output[idx++] = value;
                    }
                }
                return output;
            };
            _.flatten = function(array, shallow) {
                return flatten(array, shallow, false);
            };
            _.without = function(array) {
                return _.difference(array, slice.call(arguments, 1));
            };
            _.uniq = _.unique = function(array, isSorted, iteratee, context) {
                if (!_.isBoolean(isSorted)) {
                    context = iteratee;
                    iteratee = isSorted;
                    isSorted = false;
                }
                if (iteratee != null) iteratee = cb(iteratee, context);
                var result = [];
                var seen = [];
                for (var i = 0, length = getLength(array); i < length; i++) {
                    var value = array[i], computed = iteratee ? iteratee(value, i, array) : value;
                    if (isSorted) {
                        if (!i || seen !== computed) result.push(value);
                        seen = computed;
                    } else if (iteratee) {
                        if (!_.contains(seen, computed)) {
                            seen.push(computed);
                            result.push(value);
                        }
                    } else if (!_.contains(result, value)) {
                        result.push(value);
                    }
                }
                return result;
            };
            _.union = function() {
                return _.uniq(flatten(arguments, true, true));
            };
            _.intersection = function(array) {
                var result = [];
                var argsLength = arguments.length;
                for (var i = 0, length = getLength(array); i < length; i++) {
                    var item = array[i];
                    if (_.contains(result, item)) continue;
                    for (var j = 1; j < argsLength; j++) {
                        if (!_.contains(arguments[j], item)) break;
                    }
                    if (j === argsLength) result.push(item);
                }
                return result;
            };
            _.difference = function(array) {
                var rest = flatten(arguments, true, true, 1);
                return _.filter(array, function(value) {
                    return !_.contains(rest, value);
                });
            };
            _.zip = function() {
                return _.unzip(arguments);
            };
            _.unzip = function(array) {
                var length = array && _.max(array, getLength).length || 0;
                var result = Array(length);
                for (var index = 0; index < length; index++) {
                    result[index] = _.pluck(array, index);
                }
                return result;
            };
            _.object = function(list, values) {
                var result = {};
                for (var i = 0, length = getLength(list); i < length; i++) {
                    if (values) {
                        result[list[i]] = values[i];
                    } else {
                        result[list[i][0]] = list[i][1];
                    }
                }
                return result;
            };
            function createPredicateIndexFinder(dir) {
                return function(array, predicate, context) {
                    predicate = cb(predicate, context);
                    var length = getLength(array);
                    var index = dir > 0 ? 0 : length - 1;
                    for (;index >= 0 && index < length; index += dir) {
                        if (predicate(array[index], index, array)) return index;
                    }
                    return -1;
                };
            }
            _.findIndex = createPredicateIndexFinder(1);
            _.findLastIndex = createPredicateIndexFinder(-1);
            _.sortedIndex = function(array, obj, iteratee, context) {
                iteratee = cb(iteratee, context, 1);
                var value = iteratee(obj);
                var low = 0, high = getLength(array);
                while (low < high) {
                    var mid = Math.floor((low + high) / 2);
                    if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;
                }
                return low;
            };
            function createIndexFinder(dir, predicateFind, sortedIndex) {
                return function(array, item, idx) {
                    var i = 0, length = getLength(array);
                    if (typeof idx == "number") {
                        if (dir > 0) {
                            i = idx >= 0 ? idx : Math.max(idx + length, i);
                        } else {
                            length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
                        }
                    } else if (sortedIndex && idx && length) {
                        idx = sortedIndex(array, item);
                        return array[idx] === item ? idx : -1;
                    }
                    if (item !== item) {
                        idx = predicateFind(slice.call(array, i, length), _.isNaN);
                        return idx >= 0 ? idx + i : -1;
                    }
                    for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
                        if (array[idx] === item) return idx;
                    }
                    return -1;
                };
            }
            _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);
            _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);
            _.range = function(start, stop, step) {
                if (stop == null) {
                    stop = start || 0;
                    start = 0;
                }
                step = step || 1;
                var length = Math.max(Math.ceil((stop - start) / step), 0);
                var range = Array(length);
                for (var idx = 0; idx < length; idx++, start += step) {
                    range[idx] = start;
                }
                return range;
            };
            var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {
                if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
                var self = baseCreate(sourceFunc.prototype);
                var result = sourceFunc.apply(self, args);
                if (_.isObject(result)) return result;
                return self;
            };
            _.bind = function(func, context) {
                if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
                if (!_.isFunction(func)) throw new TypeError("Bind must be called on a function");
                var args = slice.call(arguments, 2);
                var bound = function() {
                    return executeBound(func, bound, context, this, args.concat(slice.call(arguments)));
                };
                return bound;
            };
            _.partial = function(func) {
                var boundArgs = slice.call(arguments, 1);
                var bound = function() {
                    var position = 0, length = boundArgs.length;
                    var args = Array(length);
                    for (var i = 0; i < length; i++) {
                        args[i] = boundArgs[i] === _ ? arguments[position++] : boundArgs[i];
                    }
                    while (position < arguments.length) args.push(arguments[position++]);
                    return executeBound(func, bound, this, this, args);
                };
                return bound;
            };
            _.bindAll = function(obj) {
                var i, length = arguments.length, key;
                if (length <= 1) throw new Error("bindAll must be passed function names");
                for (i = 1; i < length; i++) {
                    key = arguments[i];
                    obj[key] = _.bind(obj[key], obj);
                }
                return obj;
            };
            _.memoize = function(func, hasher) {
                var memoize = function(key) {
                    var cache = memoize.cache;
                    var address = "" + (hasher ? hasher.apply(this, arguments) : key);
                    if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);
                    return cache[address];
                };
                memoize.cache = {};
                return memoize;
            };
            _.delay = function(func, wait) {
                var args = slice.call(arguments, 2);
                return setTimeout(function() {
                    return func.apply(null, args);
                }, wait);
            };
            _.defer = _.partial(_.delay, _, 1);
            _.throttle = function(func, wait, options) {
                var context, args, result;
                var timeout = null;
                var previous = 0;
                if (!options) options = {};
                var later = function() {
                    previous = options.leading === false ? 0 : _.now();
                    timeout = null;
                    result = func.apply(context, args);
                    if (!timeout) context = args = null;
                };
                return function() {
                    var now = _.now();
                    if (!previous && options.leading === false) previous = now;
                    var remaining = wait - (now - previous);
                    context = this;
                    args = arguments;
                    if (remaining <= 0 || remaining > wait) {
                        if (timeout) {
                            clearTimeout(timeout);
                            timeout = null;
                        }
                        previous = now;
                        result = func.apply(context, args);
                        if (!timeout) context = args = null;
                    } else if (!timeout && options.trailing !== false) {
                        timeout = setTimeout(later, remaining);
                    }
                    return result;
                };
            };
            _.debounce = function(func, wait, immediate) {
                var timeout, args, context, timestamp, result;
                var later = function() {
                    var last = _.now() - timestamp;
                    if (last < wait && last >= 0) {
                        timeout = setTimeout(later, wait - last);
                    } else {
                        timeout = null;
                        if (!immediate) {
                            result = func.apply(context, args);
                            if (!timeout) context = args = null;
                        }
                    }
                };
                return function() {
                    context = this;
                    args = arguments;
                    timestamp = _.now();
                    var callNow = immediate && !timeout;
                    if (!timeout) timeout = setTimeout(later, wait);
                    if (callNow) {
                        result = func.apply(context, args);
                        context = args = null;
                    }
                    return result;
                };
            };
            _.wrap = function(func, wrapper) {
                return _.partial(wrapper, func);
            };
            _.negate = function(predicate) {
                return function() {
                    return !predicate.apply(this, arguments);
                };
            };
            _.compose = function() {
                var args = arguments;
                var start = args.length - 1;
                return function() {
                    var i = start;
                    var result = args[start].apply(this, arguments);
                    while (i--) result = args[i].call(this, result);
                    return result;
                };
            };
            _.after = function(times, func) {
                return function() {
                    if (--times < 1) {
                        return func.apply(this, arguments);
                    }
                };
            };
            _.before = function(times, func) {
                var memo;
                return function() {
                    if (--times > 0) {
                        memo = func.apply(this, arguments);
                    }
                    if (times <= 1) func = null;
                    return memo;
                };
            };
            _.once = _.partial(_.before, 2);
            var hasEnumBug = !{
                toString: null
            }.propertyIsEnumerable("toString");
            var nonEnumerableProps = [ "valueOf", "isPrototypeOf", "toString", "propertyIsEnumerable", "hasOwnProperty", "toLocaleString" ];
            function collectNonEnumProps(obj, keys) {
                var nonEnumIdx = nonEnumerableProps.length;
                var constructor = obj.constructor;
                var proto = _.isFunction(constructor) && constructor.prototype || ObjProto;
                var prop = "constructor";
                if (_.has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);
                while (nonEnumIdx--) {
                    prop = nonEnumerableProps[nonEnumIdx];
                    if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {
                        keys.push(prop);
                    }
                }
            }
            _.keys = function(obj) {
                if (!_.isObject(obj)) return [];
                if (nativeKeys) return nativeKeys(obj);
                var keys = [];
                for (var key in obj) if (_.has(obj, key)) keys.push(key);
                if (hasEnumBug) collectNonEnumProps(obj, keys);
                return keys;
            };
            _.allKeys = function(obj) {
                if (!_.isObject(obj)) return [];
                var keys = [];
                for (var key in obj) keys.push(key);
                if (hasEnumBug) collectNonEnumProps(obj, keys);
                return keys;
            };
            _.values = function(obj) {
                var keys = _.keys(obj);
                var length = keys.length;
                var values = Array(length);
                for (var i = 0; i < length; i++) {
                    values[i] = obj[keys[i]];
                }
                return values;
            };
            _.mapObject = function(obj, iteratee, context) {
                iteratee = cb(iteratee, context);
                var keys = _.keys(obj), length = keys.length, results = {}, currentKey;
                for (var index = 0; index < length; index++) {
                    currentKey = keys[index];
                    results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
                }
                return results;
            };
            _.pairs = function(obj) {
                var keys = _.keys(obj);
                var length = keys.length;
                var pairs = Array(length);
                for (var i = 0; i < length; i++) {
                    pairs[i] = [ keys[i], obj[keys[i]] ];
                }
                return pairs;
            };
            _.invert = function(obj) {
                var result = {};
                var keys = _.keys(obj);
                for (var i = 0, length = keys.length; i < length; i++) {
                    result[obj[keys[i]]] = keys[i];
                }
                return result;
            };
            _.functions = _.methods = function(obj) {
                var names = [];
                for (var key in obj) {
                    if (_.isFunction(obj[key])) names.push(key);
                }
                return names.sort();
            };
            _.extend = createAssigner(_.allKeys);
            _.extendOwn = _.assign = createAssigner(_.keys);
            _.findKey = function(obj, predicate, context) {
                predicate = cb(predicate, context);
                var keys = _.keys(obj), key;
                for (var i = 0, length = keys.length; i < length; i++) {
                    key = keys[i];
                    if (predicate(obj[key], key, obj)) return key;
                }
            };
            _.pick = function(object, oiteratee, context) {
                var result = {}, obj = object, iteratee, keys;
                if (obj == null) return result;
                if (_.isFunction(oiteratee)) {
                    keys = _.allKeys(obj);
                    iteratee = optimizeCb(oiteratee, context);
                } else {
                    keys = flatten(arguments, false, false, 1);
                    iteratee = function(value, key, obj) {
                        return key in obj;
                    };
                    obj = Object(obj);
                }
                for (var i = 0, length = keys.length; i < length; i++) {
                    var key = keys[i];
                    var value = obj[key];
                    if (iteratee(value, key, obj)) result[key] = value;
                }
                return result;
            };
            _.omit = function(obj, iteratee, context) {
                if (_.isFunction(iteratee)) {
                    iteratee = _.negate(iteratee);
                } else {
                    var keys = _.map(flatten(arguments, false, false, 1), String);
                    iteratee = function(value, key) {
                        return !_.contains(keys, key);
                    };
                }
                return _.pick(obj, iteratee, context);
            };
            _.defaults = createAssigner(_.allKeys, true);
            _.create = function(prototype, props) {
                var result = baseCreate(prototype);
                if (props) _.extendOwn(result, props);
                return result;
            };
            _.clone = function(obj) {
                if (!_.isObject(obj)) return obj;
                return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
            };
            _.tap = function(obj, interceptor) {
                interceptor(obj);
                return obj;
            };
            _.isMatch = function(object, attrs) {
                var keys = _.keys(attrs), length = keys.length;
                if (object == null) return !length;
                var obj = Object(object);
                for (var i = 0; i < length; i++) {
                    var key = keys[i];
                    if (attrs[key] !== obj[key] || !(key in obj)) return false;
                }
                return true;
            };
            var eq = function(a, b, aStack, bStack) {
                if (a === b) return a !== 0 || 1 / a === 1 / b;
                if (a == null || b == null) return a === b;
                if (a instanceof _) a = a._wrapped;
                if (b instanceof _) b = b._wrapped;
                var className = toString.call(a);
                if (className !== toString.call(b)) return false;
                switch (className) {
                  case "[object RegExp]":
                  case "[object String]":
                    return "" + a === "" + b;

                  case "[object Number]":
                    if (+a !== +a) return +b !== +b;
                    return +a === 0 ? 1 / +a === 1 / b : +a === +b;

                  case "[object Date]":
                  case "[object Boolean]":
                    return +a === +b;
                }
                var areArrays = className === "[object Array]";
                if (!areArrays) {
                    if (typeof a != "object" || typeof b != "object") return false;
                    var aCtor = a.constructor, bCtor = b.constructor;
                    if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor && _.isFunction(bCtor) && bCtor instanceof bCtor) && ("constructor" in a && "constructor" in b)) {
                        return false;
                    }
                }
                aStack = aStack || [];
                bStack = bStack || [];
                var length = aStack.length;
                while (length--) {
                    if (aStack[length] === a) return bStack[length] === b;
                }
                aStack.push(a);
                bStack.push(b);
                if (areArrays) {
                    length = a.length;
                    if (length !== b.length) return false;
                    while (length--) {
                        if (!eq(a[length], b[length], aStack, bStack)) return false;
                    }
                } else {
                    var keys = _.keys(a), key;
                    length = keys.length;
                    if (_.keys(b).length !== length) return false;
                    while (length--) {
                        key = keys[length];
                        if (!(_.has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
                    }
                }
                aStack.pop();
                bStack.pop();
                return true;
            };
            _.isEqual = function(a, b) {
                return eq(a, b);
            };
            _.isEmpty = function(obj) {
                if (obj == null) return true;
                if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;
                return _.keys(obj).length === 0;
            };
            _.isElement = function(obj) {
                return !!(obj && obj.nodeType === 1);
            };
            _.isArray = nativeIsArray || function(obj) {
                return toString.call(obj) === "[object Array]";
            };
            _.isObject = function(obj) {
                var type = typeof obj;
                return type === "function" || type === "object" && !!obj;
            };
            _.each([ "Arguments", "Function", "String", "Number", "Date", "RegExp", "Error" ], function(name) {
                _["is" + name] = function(obj) {
                    return toString.call(obj) === "[object " + name + "]";
                };
            });
            if (!_.isArguments(arguments)) {
                _.isArguments = function(obj) {
                    return _.has(obj, "callee");
                };
            }
            if (typeof /./ != "function" && typeof Int8Array != "object") {
                _.isFunction = function(obj) {
                    return typeof obj == "function" || false;
                };
            }
            _.isFinite = function(obj) {
                return isFinite(obj) && !isNaN(parseFloat(obj));
            };
            _.isNaN = function(obj) {
                return _.isNumber(obj) && obj !== +obj;
            };
            _.isBoolean = function(obj) {
                return obj === true || obj === false || toString.call(obj) === "[object Boolean]";
            };
            _.isNull = function(obj) {
                return obj === null;
            };
            _.isUndefined = function(obj) {
                return obj === void 0;
            };
            _.has = function(obj, key) {
                return obj != null && hasOwnProperty.call(obj, key);
            };
            _.noConflict = function() {
                root._ = previousUnderscore;
                return this;
            };
            _.identity = function(value) {
                return value;
            };
            _.constant = function(value) {
                return function() {
                    return value;
                };
            };
            _.noop = function() {};
            _.property = property;
            _.propertyOf = function(obj) {
                return obj == null ? function() {} : function(key) {
                    return obj[key];
                };
            };
            _.matcher = _.matches = function(attrs) {
                attrs = _.extendOwn({}, attrs);
                return function(obj) {
                    return _.isMatch(obj, attrs);
                };
            };
            _.times = function(n, iteratee, context) {
                var accum = Array(Math.max(0, n));
                iteratee = optimizeCb(iteratee, context, 1);
                for (var i = 0; i < n; i++) accum[i] = iteratee(i);
                return accum;
            };
            _.random = function(min, max) {
                if (max == null) {
                    max = min;
                    min = 0;
                }
                return min + Math.floor(Math.random() * (max - min + 1));
            };
            _.now = Date.now || function() {
                return new Date().getTime();
            };
            var escapeMap = {
                "&": "&amp;",
                "<": "&lt;",
                ">": "&gt;",
                '"': "&quot;",
                "'": "&#x27;",
                "`": "&#x60;"
            };
            var unescapeMap = _.invert(escapeMap);
            var createEscaper = function(map) {
                var escaper = function(match) {
                    return map[match];
                };
                var source = "(?:" + _.keys(map).join("|") + ")";
                var testRegexp = RegExp(source);
                var replaceRegexp = RegExp(source, "g");
                return function(string) {
                    string = string == null ? "" : "" + string;
                    return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
                };
            };
            _.escape = createEscaper(escapeMap);
            _.unescape = createEscaper(unescapeMap);
            _.result = function(object, property, fallback) {
                var value = object == null ? void 0 : object[property];
                if (value === void 0) {
                    value = fallback;
                }
                return _.isFunction(value) ? value.call(object) : value;
            };
            var idCounter = 0;
            _.uniqueId = function(prefix) {
                var id = ++idCounter + "";
                return prefix ? prefix + id : id;
            };
            _.templateSettings = {
                evaluate: /<%([\s\S]+?)%>/g,
                interpolate: /<%=([\s\S]+?)%>/g,
                escape: /<%-([\s\S]+?)%>/g
            };
            var noMatch = /(.)^/;
            var escapes = {
                "'": "'",
                "\\": "\\",
                "\r": "r",
                "\n": "n",
                "\u2028": "u2028",
                "\u2029": "u2029"
            };
            var escaper = /\\|'|\r|\n|\u2028|\u2029/g;
            var escapeChar = function(match) {
                return "\\" + escapes[match];
            };
            _.template = function(text, settings, oldSettings) {
                if (!settings && oldSettings) settings = oldSettings;
                settings = _.defaults({}, settings, _.templateSettings);
                var matcher = RegExp([ (settings.escape || noMatch).source, (settings.interpolate || noMatch).source, (settings.evaluate || noMatch).source ].join("|") + "|$", "g");
                var index = 0;
                var source = "__p+='";
                text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
                    source += text.slice(index, offset).replace(escaper, escapeChar);
                    index = offset + match.length;
                    if (escape) {
                        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
                    } else if (interpolate) {
                        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
                    } else if (evaluate) {
                        source += "';\n" + evaluate + "\n__p+='";
                    }
                    return match;
                });
                source += "';\n";
                if (!settings.variable) source = "with(obj||{}){\n" + source + "}\n";
                source = "var __t,__p='',__j=Array.prototype.join," + "print=function(){__p+=__j.call(arguments,'');};\n" + source + "return __p;\n";
                try {
                    var render = new Function(settings.variable || "obj", "_", source);
                } catch (e) {
                    e.source = source;
                    throw e;
                }
                var template = function(data) {
                    return render.call(this, data, _);
                };
                var argument = settings.variable || "obj";
                template.source = "function(" + argument + "){\n" + source + "}";
                return template;
            };
            _.chain = function(obj) {
                var instance = _(obj);
                instance._chain = true;
                return instance;
            };
            var result = function(instance, obj) {
                return instance._chain ? _(obj).chain() : obj;
            };
            _.mixin = function(obj) {
                _.each(_.functions(obj), function(name) {
                    var func = _[name] = obj[name];
                    _.prototype[name] = function() {
                        var args = [ this._wrapped ];
                        push.apply(args, arguments);
                        return result(this, func.apply(_, args));
                    };
                });
            };
            _.mixin(_);
            _.each([ "pop", "push", "reverse", "shift", "sort", "splice", "unshift" ], function(name) {
                var method = ArrayProto[name];
                _.prototype[name] = function() {
                    var obj = this._wrapped;
                    method.apply(obj, arguments);
                    if ((name === "shift" || name === "splice") && obj.length === 0) delete obj[0];
                    return result(this, obj);
                };
            });
            _.each([ "concat", "join", "slice" ], function(name) {
                var method = ArrayProto[name];
                _.prototype[name] = function() {
                    return result(this, method.apply(this._wrapped, arguments));
                };
            });
            _.prototype.value = function() {
                return this._wrapped;
            };
            _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;
            _.prototype.toString = function() {
                return "" + this._wrapped;
            };
            if (typeof define === "function" && define.amd) {
                define("underscore", [], function() {
                    return _;
                });
            }
        }).call(this);
    }, {} ],
    107: [ function(require, module, exports) {
        "use strict";
        module.exports = AnalysisGeneratorFactory;
        AnalysisGeneratorFactory.$inject = [ "lodash", "iGenerateAnalysisFromCube", "iGenerateAnalysisFromSaved" ];
        function AnalysisGeneratorFactory(_, iGenerateAnalysisFromCube, iGenerateAnalysisFromSaved) {
            return {
                getGenerator: function(params) {
                    var first = iGenerateAnalysisFromSaved;
                    iGenerateAnalysisFromSaved.next = iGenerateAnalysisFromCube;
                    return _.partial(first.generate.bind(first), params);
                }
            };
        }
    }, {} ],
    108: [ function(require, module, exports) {
        "use strict";
        module.exports = AnalysisGeneratorFactory;
        AnalysisGeneratorFactory.$inject = [];
        function AnalysisGeneratorFactory() {
            function AnalysisGenerator() {}
            AnalysisGenerator.prototype.generate = function(params) {
                var current = this;
                do {
                    if (current.accepts(params)) {
                        return current.execute(params);
                    }
                    current = current.next;
                } while (current);
                throw new Error("request could not be handled");
            };
            AnalysisGenerator.prototype.accepts = function() {
                return false;
            };
            AnalysisGenerator.prototype.execute = function() {
                throw new Error("not implemented");
            };
            Object.defineProperties(AnalysisGenerator.prototype, {
                next: {
                    set: function(value) {
                        if (!(value instanceof AnalysisGenerator)) {
                            throw new Error("generator doesn't conform with interface");
                        }
                        this._next = value;
                    },
                    get: function() {
                        return this._next;
                    }
                }
            });
            return new AnalysisGenerator();
        }
    }, {} ],
    109: [ function(require, module, exports) {
        "use strict";
        module.exports = AnalysisFactory;
        AnalysisFactory.$inject = [ "lodash", "$q", "machina", "VariableList", "MeasureList", "analysisGeneratorFactory" ];
        function AnalysisFactory(_, $q, machina, VariableList, MeasureList, analysisGeneratorFactory) {
            function hasSlideId(params) {
                return _.isString(params.slideId);
            }
            function assertDatasetId(cfg) {
                if (!cfg.datasetId) {
                    throw new Error("please provide a valid datasetId");
                }
            }
            function assertSlideId(cfg) {
                if (!_.isString(cfg.slideId)) {
                    throw new Error("please provide a valid slideId");
                }
            }
            var analysisOperations = {
                "add-variable": function(variableId) {
                    this.variables.add(variableId).then(function() {
                        this.recalculate();
                    }.bind(this));
                },
                clean: function() {
                    this.variables.clean();
                    delete this.data;
                    this.transition("empty");
                },
                "remove-variable": function(i) {
                    this.variables.remove(i);
                    if (this.variables.isEmpty()) {
                        delete this.data;
                        this.transition("empty");
                    } else {
                        this.recalculate();
                    }
                },
                "replace-variable": function(index, variableId) {
                    this.variables.replace(index, variableId).then(function() {
                        this.recalculate();
                    }.bind(this));
                },
                pivot: function(idx1, idx2) {
                    this.variables.pivot(idx1, idx2);
                    this.recalculate();
                },
                recalculate: function() {
                    this.recalculate();
                },
                "measures-mean": function(variableId) {
                    this.measures.add("mean", variableId).then(function() {
                        this.recalculate();
                    }.bind(this));
                },
                "measures-count": function() {
                    this.measures.clean();
                }
            };
            var Analysis = machina.Fsm.extend({
                namespace: "analysis",
                initialState: "uninitialized",
                recalculate: function() {
                    var generate = analysisGeneratorFactory.getGenerator({
                        datasetId: this.datasetId,
                        variables: this.variables,
                        measures: this.measures,
                        currentData: this.data
                    }), self = this;
                    self.transition("loading");
                    try {
                        generate().then(function(data) {
                            self.data = data;
                            self.transition("loaded");
                        }).catch(function() {
                            self.transition("error");
                        });
                    } catch (e) {
                        self.transition("error");
                    }
                },
                isUnivariate: function() {
                    return this.variables.count() === 1 && !this.variables.hasArrays();
                },
                isBivariate: function() {
                    return this.variables.count() === 2 && !this.variables.hasArrays();
                },
                isEmpty: function() {
                    return this.variables.count() === 0;
                },
                hasMeanMeasure: function() {
                    return this.measures.hasMeasure("mean");
                },
                hasArrayVariables: function() {
                    return this.variables.hasArrays();
                },
                hasBinnedRows: function() {
                    return this.variables.at(0).type === "numeric";
                },
                destroy: function() {
                    this.off();
                },
                states: {
                    uninitialized: {
                        initialize: function(params) {
                            assertDatasetId(params);
                            this.datasetId = params.datasetId;
                            this.variables = new VariableList(params.datasetId);
                            this.measures = new MeasureList(params.datasetId);
                            this.transition("empty");
                        }
                    },
                    empty: {
                        _onEnter: function() {
                            this.measures.clean();
                        },
                        "add-variable": function(variableId) {
                            this.variables.add(variableId).then(function() {
                                this.recalculate();
                            }.bind(this));
                        },
                        "measures-mean": function(variableId) {
                            this.measures.add("mean", variableId).then(function() {
                                this.recalculate();
                            }.bind(this));
                        },
                        "measures-count": function() {
                            this.measures.clean();
                        }
                    },
                    loading: {
                        _onEnter: function() {
                            this.emit("analysis.loading");
                        }
                    },
                    error: _.extend({
                        _onEnter: function() {
                            this.emit("analysis.error");
                        }
                    }, analysisOperations),
                    loaded: _.extend({
                        _onEnter: function() {
                            this.emit("analysis.loaded", this.data);
                        }
                    }, analysisOperations)
                }
            });
            Object.defineProperties(Analysis.prototype, {
                graphType: {
                    get: function() {
                        var variableTypes, graphType = "barchart";
                        if (this.hasMeanMeasure()) {
                            graphType = "dotplot";
                        } else {
                            variableTypes = this.variables.items.map(function(v) {
                                return v.type;
                            });
                            variableTypes.forEach(function(t, i) {
                                if (t === "numeric" && i == 0) {
                                    graphType = "histogram";
                                } else if (t === "datetime" && i == 1) {
                                    graphType = "timeplot";
                                }
                            });
                        }
                        return graphType;
                    }
                }
            });
            var SavedAnalysis = Analysis.extend({
                states: {
                    uninitialized: {
                        initialize: function(params) {
                            assertDatasetId(params);
                            assertSlideId(params);
                            this.datasetId = params.datasetId;
                            this.slideId = params.slideId;
                            this.analysis = params.analysis || undefined;
                            this.savedSettings = undefined;
                            this.variables = new VariableList(params.datasetId);
                            this.measures = new MeasureList(params.datasetId);
                            this.transition("empty");
                        }
                    },
                    empty: {
                        load: function() {
                            var generate, self = this;
                            generate = analysisGeneratorFactory.getGenerator({
                                datasetId: self.datasetId,
                                slideId: self.slideId,
                                analysis: self.analysis
                            });
                            self.transition("loading");
                            generate().then(function(data) {
                                var promises = [];
                                self.data = data;
                                self.displaySettings = data.analysis.display_settings;
                                promises.push(self.variables.add(data.variables));
                                if (data.measureVariables) {
                                    promises.push(self.measures.add("mean", data.measureVariables));
                                }
                                return $q.all(promises);
                            }).then(function() {
                                self.emit("savedAnalysis.loaded", self.data);
                                self.transition("loaded");
                            }).catch(function() {
                                self.transition("error");
                            });
                        }
                    }
                }
            });
            return {
                create: function(cfg) {
                    var analysis;
                    cfg = cfg || {};
                    analysis = hasSlideId(cfg) ? new SavedAnalysis() : new Analysis();
                    analysis.handle("initialize", cfg);
                    return analysis;
                }
            };
        }
    }, {} ],
    110: [ function(require, module, exports) {
        "use strict";
        module.exports = CubeQuery;
        CubeQuery.$inject = [ "lodash", "$q" ];
        function CubeQuery(_, $q) {
            function build(variables, measures) {
                var types = {};
                measures = measures || {
                    count: {
                        "function": "cube_count"
                    }
                };
                types.categorical = function(varb) {
                    var variableId = varb.self;
                    if (variableId[variableId.length - 1] === "/") {
                        variableId = variableId.substring(0, variableId.length - 1);
                    }
                    return {
                        variable: variableId
                    };
                };
                types.categorical_array = function(varb) {
                    var variableId = varb.self;
                    if (variableId[variableId.length - 1] === "/") {
                        variableId = variableId.substring(0, variableId.length - 1);
                    }
                    var d = {};
                    d[varb.dimension] = variableId;
                    return d;
                };
                types.numeric = function(varb) {
                    var variableId = varb.self;
                    if (variableId[variableId.length - 1] === "/") {
                        variableId = variableId.substring(0, variableId.length - 1);
                    }
                    return {
                        "function": "bin",
                        args: [ {
                            variable: variableId
                        } ]
                    };
                };
                types.text = function(varb) {
                    var variableId = varb.self;
                    if (variableId[variableId.length - 1] === "/") {
                        variableId = variableId.substring(0, variableId.length - 1);
                    }
                    return {
                        variable: variableId
                    };
                };
                types.datetime = function(varb) {
                    var variableId = varb.self;
                    if (variableId[variableId.length - 1] === "/") {
                        variableId = variableId.substring(0, variableId.length - 1);
                    }
                    var res = varb.view.rollup_resolution || NULL;
                    var sanitizedRollup = res === "" ? NULL : res;
                    return {
                        "function": "rollup",
                        args: [ {
                            variable: variableId
                        }, {
                            value: sanitizedRollup
                        } ]
                    };
                };
                types.multiple_response = function(varb) {
                    var variableId = varb.self;
                    if (variableId[variableId.length - 1] === "/") {
                        variableId = variableId.substring(0, variableId.length - 1);
                    }
                    return [ {
                        "function": "selected_array",
                        args: [ {
                            variable: variableId
                        } ]
                    }, {
                        each: variableId
                    } ];
                };
                var dimensions = _.flatten(variables.map(function(varb) {
                    return types[varb.type](varb);
                }, this), true);
                if (!!measures.mean && variables.length > 1) {
                    delete measures.stddev;
                }
                return $q.when({
                    dimensions: dimensions,
                    measures: measures
                });
            }
            return {
                build: build
            };
        }
    }, {} ],
    111: [ function(require, module, exports) {
        "use strict";
        var _ = require("lodash");
        IFetchCubes.$inject = [ "iResourceDataset" ];
        module.exports = IFetchCubes;
        function IFetchCubes(iResourceDataset) {
            return function execute(q) {
                return iResourceDataset({
                    datasetId: q.datasetId
                }).then(function(ds) {
                    return ds.urls.cube.map({
                        params: {
                            query: q.query
                        }
                    }).then(function(it) {
                        return it.value;
                    });
                });
            };
        }
    }, {
        lodash: 77
    } ],
    112: [ function(require, module, exports) {
        "use strict";
        module.exports = IGenerateAnalysisFromCube;
        IGenerateAnalysisFromCube.$inject = [ "lodash", "$q", "analysisGenerator", "cube", "cubeQuery", "iFetchCubes" ];
        function IGenerateAnalysisFromCube(_, $q, analysisGenerator, Cube, cubeQuery, iFetchCubes) {
            function assertVariables(params) {
                if (!_.isObject(params) || !_.isArray(params.variables)) {
                    throw new Error("provide an array of variables");
                }
            }
            function getXtabFromCube(params) {
                function buildQuery(params) {
                    var measures = params.measures.valueOf() || {};
                    return cubeQuery.build(params.variables.valueOf(), measures);
                }
                function fetchCube(q) {
                    return iFetchCubes({
                        query: q,
                        datasetId: params.datasetId
                    });
                }
                function whaamCube(crunchCube) {
                    return Cube.fromCrCube(crunchCube);
                }
                var handlers = [ buildQuery, fetchCube, whaamCube ];
                return handlers.reduce($q.when, params);
            }
            var iGenerateAnalysisFromCube = Object.create(analysisGenerator);
            iGenerateAnalysisFromCube.accepts = function(params) {
                return params && params.variables && params.measures;
            };
            iGenerateAnalysisFromCube.execute = function(params) {
                params.variables = params.variables.valueOf();
                assertVariables(params);
                return getXtabFromCube(params).then(function(result) {
                    return {
                        cube: result
                    };
                });
            };
            return iGenerateAnalysisFromCube;
        }
    }, {} ],
    113: [ function(require, module, exports) {
        "use strict";
        module.exports = IGenerateAnalysisFromSavedFactory;
        IGenerateAnalysisFromSavedFactory.$inject = [ "lodash", "analysisGenerator", "iResourceDataset", "Shoji", "crFindVariables", "cube", "iFetchCubes" ];
        function IGenerateAnalysisFromSavedFactory(_, analysisGenerator, iResourceDataset, Shoji, findVariables, Cube, iFetchCubes) {
            var acc;
            function assertDataset(params) {
                if (!_.isObject(params) || !_.isString(params.datasetId)) {
                    throw new Error("provide a dataset id");
                }
            }
            function fetchQuery(acc, dataset) {
                acc.dataset = dataset;
                return iFetchCubes({
                    datasetId: dataset.self,
                    query: acc.analysis.query
                });
            }
            function makeWhaamCube(acc, crunchCube) {
                return Cube.fromCrCube(crunchCube);
            }
            function prepareResult(acc, whaamCube) {
                var cube = whaamCube;
                var dims = acc.analysis.query.dimensions.filter(function(d) {
                    return d.function ? d.function !== "selected_array" : true;
                });
                var variables = dims.map(function(d) {
                    return {
                        self: findVariables(d),
                        dimension: d.each ? "each" : "variable"
                    };
                });
                var measures = acc.analysis.query.measures.mean ? findVariables(acc.analysis.query.measures.mean) : undefined;
                return {
                    cube: cube,
                    variables: variables,
                    measureVariables: measures,
                    analysis: acc.analysis
                };
            }
            var iGenerateAnalysisFromSaved = Object.create(analysisGenerator);
            iGenerateAnalysisFromSaved.accepts = function(params) {
                return _.isObject(params) && _.isObject(params.analysis) && params.slideId;
            };
            iGenerateAnalysisFromSaved.execute = function(params) {
                assertDataset(params);
                acc = {};
                acc.analysis = params.analysis;
                return iResourceDataset({
                    datasetId: params.datasetId
                }).then(function(ds) {
                    var handlers = [ fetchQuery, makeWhaamCube, prepareResult ];
                    return ds.reduce(acc, handlers);
                });
            };
            return iGenerateAnalysisFromSaved;
        }
    }, {} ],
    114: [ function(require, module, exports) {
        "use strict";
        module.exports = buildModule;
        function buildModule(moduleName, cfg) {
            var angular = require("angular"), mod = angular.module(moduleName || "analysis", []);
            mod.factory("lodash", function() {
                return require("lodash");
            });
            mod.factory("analysisGenerator", require("./analysis-generator"));
            mod.factory("iGenerateAnalysisFromCube", require("./i-generate-analysis-from-cube"));
            mod.factory("iGenerateAnalysisFromSaved", require("./i-generate-analysis-from-saved-analysis"));
            mod.factory("analysisGeneratorFactory", require("./analysis-generator-factory"));
            mod.factory("cubeQuery", require("./cube-query"));
            mod.factory("iFetchCubes", require("./i-fetch-cubes"));
            mod.factory("VariableList", require("./variable-list"));
            mod.factory("MeasureList", require("./measure-list"));
            mod.factory("Analysis", require("./analysis"));
            return mod;
        }
    }, {
        "./analysis": 109,
        "./analysis-generator": 108,
        "./analysis-generator-factory": 107,
        "./cube-query": 110,
        "./i-fetch-cubes": 111,
        "./i-generate-analysis-from-cube": 112,
        "./i-generate-analysis-from-saved-analysis": 113,
        "./measure-list": 115,
        "./variable-list": 116,
        angular: "angular",
        lodash: 77
    } ],
    115: [ function(require, module, exports) {
        "use strict";
        module.exports = MeasureListFactory;
        MeasureListFactory.$inject = [ "lodash", "$q", "cachedHierarchicalVariables" ];
        function MeasureListFactory(_, $q, cachedHierarchicalVariables) {
            function assertDatasetId(datasetId) {
                if (!datasetId) {
                    throw new Error("datasetId is required by the measure list");
                }
            }
            function MeasureList(datasetId) {
                assertDatasetId(datasetId);
                this.datasetId = datasetId;
                this.measures = {};
            }
            function serialize(variables, measure) {
                return {
                    "function": "cube_" + measure,
                    args: _.map(variables, function(variable) {
                        return {
                            variable: variable.self
                        };
                    })
                };
            }
            MeasureList.prototype.add = function(type, variableId) {
                var measure = this.measures[type] || {}, promise, variable, self = this;
                if (!measure.hasOwnProperty(variableId)) {
                    measure = {};
                    variable = cachedHierarchicalVariables.current.byId(variableId);
                    if (variable.contains(variableId)) {
                        promise = variable.getSubvariables().then(function() {
                            measure[variableId] = variable.subvariableById(variableId);
                            self.measures[type] = measure;
                        });
                    } else {
                        measure[variableId] = variable;
                        self.measures[type] = measure;
                        promise = $q.when(measure[variableId]);
                    }
                } else {
                    promise = $q.when(measure[variableId]);
                }
                return promise;
            };
            MeasureList.prototype.hasMeasure = function(measure) {
                return _.isObject(this.measures[measure]) && Object.keys(this.measures[measure]).length > 0;
            };
            MeasureList.prototype.getMeasureVariable = function(type, index) {
                var measure = this.measures[type] || {}, key = Object.keys(measure)[index];
                return measure[key];
            };
            MeasureList.prototype.clean = function() {
                this.measures = {};
            };
            MeasureList.prototype.valueOf = function() {
                var measures = _.cloneDeep(this.measures);
                if (Object.keys(measures).length === 0) {
                    measures.count = {};
                }
                if (measures.hasOwnProperty("mean")) {
                    measures.count = {};
                }
                return _.mapValues(measures, serialize);
            };
            MeasureList.prototype.toJSON = function() {
                return this.valueOf();
            };
            return MeasureList;
        }
    }, {} ],
    116: [ function(require, module, exports) {
        "use strict";
        module.exports = VariableListFactory;
        VariableListFactory.$inject = [ "lodash", "$q", "cachedHierarchicalVariables" ];
        function VariableListFactory(_, $q, cachedHierarchicalVariables) {
            var addStrategies = {
                categorical_array: function(varInfo, items) {
                    var columnVar = _.cloneDeep(varInfo);
                    varInfo.dimension = "each";
                    columnVar.dimension = "variable";
                    items.push(varInfo, columnVar);
                    return items;
                },
                "default": function(varInfo, items) {
                    varInfo.dimension = "variable";
                    items.push(varInfo);
                    return items;
                }
            };
            function addVariable(variable) {
                var strategy, self = this, promise;
                if (typeof variable === "object") {
                    promise = getVariableInfo(variable.self).then(function(varInfo) {
                        var clone = varInfo.clone();
                        clone.dimension = variable.dimension;
                        self.items = self.items.concat([ clone ]);
                        return clone;
                    });
                } else {
                    promise = getVariableInfo(variable).then(function(varInfo) {
                        strategy = addStrategies[varInfo.type] || addStrategies.default;
                        self.items = strategy(varInfo, self.items);
                        return varInfo;
                    });
                }
                return promise;
            }
            function getVariableInfo(variableId) {
                var variable = cachedHierarchicalVariables.current.byId(variableId), promise;
                if (variable.contains(variableId)) {
                    promise = variable.getSubvariables().then(function() {
                        return variable.subvariableById(variableId).map();
                    });
                } else {
                    promise = variable.map();
                }
                return promise;
            }
            function assertDatasetId(datasetId) {
                if (!datasetId) {
                    throw new Error("Dataset id is required by the variable list");
                }
            }
            function VariableList(datasetId) {
                assertDatasetId(datasetId);
                this.datasetId = datasetId;
                this.items = [];
            }
            VariableList.prototype.at = function(idx) {
                return this.items[idx];
            };
            VariableList.prototype.getTypes = function() {
                return this.items.map(function(each) {
                    return each.type;
                });
            };
            VariableList.prototype.add = function(items) {
                var itemList = items instanceof Array ? items : [ items ], add = addVariable.bind(this), promise, currentCount = this.items.length, self = this;
                function request() {
                    var item = itemList.shift(), p;
                    if (item) {
                        p = add(item).then(request);
                    } else {
                        p = $q.when(self.items.slice(currentCount));
                    }
                    return p;
                }
                return request();
            };
            VariableList.prototype.replace = function(index, variableId) {
                var items = this.items, promise, strategy;
                if (items.length <= index) {
                    promise = addVariable.call(this, variableId);
                } else {
                    promise = getVariableInfo(variableId).then(function(varInfo) {
                        strategy = addStrategies[varInfo.type] || addStrategies.default;
                        items[index] = strategy(varInfo, [])[0];
                        return varInfo;
                    });
                }
                return promise;
            };
            VariableList.prototype.pivot = function(idx1, idx2) {
                var items = this.items, variable1 = items[idx1], variable2 = items[idx2];
                if (!_.isObject(variable1) || !_.isObject(variable2)) {
                    throw new Error("Some of the specified variables does not exist");
                }
                items[idx1] = variable2;
                items[idx2] = variable1;
            };
            VariableList.prototype.hasArrays = function() {
                return this.items.some(function(varb) {
                    return varb.type === "categorical_array";
                });
            };
            VariableList.prototype.clean = function() {
                this.items.length = 0;
            };
            VariableList.prototype.isEmpty = function() {
                return this.items.length === 0;
            };
            VariableList.prototype.count = function() {
                return this.items.length;
            };
            VariableList.prototype.remove = function(index) {
                if (!this.isEmpty() && index < this.items.length) {
                    if (this.items[index].type == "categorical_array") {
                        var variableId = this.items[index].self;
                        this.items = this.items.filter(function(i) {
                            return i.self != variableId;
                        });
                    } else {
                        this.items.splice(index, 1);
                    }
                } else {
                    throw new Error("no variable at this index");
                }
            };
            VariableList.prototype.valueOf = function() {
                return this.items;
            };
            return VariableList;
        }
    }, {} ],
    117: [ function(require, module, exports) {
        "use strict";
        module.exports = function buildModule(excludes) {
            var angular = require("angular"), features = [ require("../shoji"), require("../resources"), require("../messaging"), require("../machina-angular"), require("../current-dataset"), require("../traversable"), require("../drag-and-drop"), require("../filter-builder"), require("../hierarchical-variables"), require("../hierarchical-variables-list"), require("../analysis"), require("../cube"), require("../start-from"), require("../variables-accordion") ], mod;
            var modules = features.map(function(feat) {
                return feat().name;
            }).filter(function(modName) {
                return (excludes || []).indexOf(modName) === -1;
            });
            mod = angular.module("crunchJS", modules);
            return mod;
        };
    }, {
        "../analysis": 114,
        "../cube": 124,
        "../current-dataset": 130,
        "../drag-and-drop": 137,
        "../filter-builder": 152,
        "../hierarchical-variables": 179,
        "../hierarchical-variables-list": 164,
        "../machina-angular": 184,
        "../messaging": 192,
        "../resources": 203,
        "../shoji": 204,
        "../start-from": 212,
        "../traversable": 214,
        "../variables-accordion": 224,
        angular: "angular"
    } ],
    118: [ function(require, module, exports) {
        "use strict";
        module.exports = BinnedDimensionFactory;
        BinnedDimensionFactory.$inject = [ "lodash" ];
        function BinnedDimensionFactory(_) {
            function BinnedDimension(data) {
                this.data = data;
            }
            Object.defineProperties(BinnedDimension.prototype, {
                name: {
                    get: function() {
                        return this.data.references.name || undefined;
                    }
                },
                type: {
                    value: "binned"
                },
                labels: {
                    get: function() {
                        return this.validExtents.map(function(el) {
                            return el.value;
                        });
                    }
                },
                missing: {
                    get: function() {
                        return this.data.type.elements.map(function(el) {
                            return el.missing;
                        });
                    }
                },
                length: {
                    get: function() {
                        return this.data.type.elements.length;
                    }
                },
                validLength: {
                    get: function() {
                        return this.validExtents.length;
                    }
                },
                validExtents: {
                    get: function() {
                        return this.data.type.elements.filter(function(el) {
                            return el.missing === false;
                        });
                    }
                },
                subscripts: {
                    get: function() {
                        return this.data.type.elements.map(function(e, i) {
                            return i;
                        });
                    }
                },
                missingSubscripts: {
                    get: function() {
                        var out = [];
                        var elements = this.data.type.elements.filter(function(el, idx) {
                            var id = el.value && el.value.id || "";
                            if (el.missing) {
                                out.push(idx);
                                return true;
                            }
                        });
                        return out;
                    }
                },
                validSubscripts: {
                    get: function() {
                        var out = [];
                        var elements = this.data.type.elements.filter(function(el, idx) {
                            var id = el.value && el.value.id || "";
                            if (el.missing === false) {
                                out.push(idx);
                                return true;
                            }
                        });
                        return out;
                    }
                },
                prunedExtents: {
                    set: function(replacement) {
                        this.data.type.elements = replacement;
                    }
                }
            });
            return BinnedDimension;
        }
    }, {} ],
    119: [ function(require, module, exports) {
        "use strict";
        module.exports = CategoricalDimensionFactory;
        CategoricalDimensionFactory.$inject = [ "lodash" ];
        function CategoricalDimensionFactory(_) {
            function CategoricalDimension(data) {
                this.data = data;
            }
            Object.defineProperties(CategoricalDimension.prototype, {
                name: {
                    get: function() {
                        return this.data.references.name || undefined;
                    }
                },
                type: {
                    value: "categorical"
                },
                labels: {
                    get: function() {
                        return this.validExtents.map(function(cat) {
                            return cat.name;
                        });
                    }
                },
                missing: {
                    get: function() {
                        return this.data.type.categories.map(function(el) {
                            return el.missing;
                        });
                    }
                },
                subscripts: {
                    get: function() {
                        return this.data.type.categories.map(function(e, i) {
                            return i;
                        });
                    }
                },
                missingSubscripts: {
                    get: function() {
                        var out = [];
                        var elements = this.data.type.categories.filter(function(el, idx) {
                            var id = el.value && el.value.id || "";
                            if (el.missing) {
                                out.push(idx);
                                return true;
                            }
                        });
                        return out;
                    }
                },
                validSubscripts: {
                    get: function() {
                        var out = [];
                        var elements = this.data.type.categories.filter(function(el, idx) {
                            var id = el.value && el.value.id || "";
                            if (el.missing === false) {
                                out.push(idx);
                                return true;
                            }
                        });
                        return out;
                    }
                },
                length: {
                    get: function() {
                        return this.data.type.categories.length;
                    }
                },
                validLength: {
                    get: function() {
                        return this.validExtents.length;
                    }
                },
                validExtents: {
                    get: function() {
                        return this.data.type.categories.filter(function(cat) {
                            return cat.missing === false;
                        });
                    }
                },
                prunedExtents: {
                    set: function(replacement) {
                        this.data.type.categories = replacement;
                    }
                }
            });
            return CategoricalDimension;
        }
    }, {} ],
    120: [ function(require, module, exports) {
        "use strict";
        module.exports = CompositeDimensionFactory;
        CompositeDimensionFactory.$inject = [ "lodash" ];
        function CompositeDimensionFactory(_) {
            function CompositeDimension(data) {
                this.data = data;
            }
            Object.defineProperties(CompositeDimension.prototype, {
                name: {
                    get: function() {
                        return this.data.references.name || undefined;
                    }
                },
                type: {
                    value: "composite"
                },
                missing: {
                    get: function() {
                        return this.data.type.elements.map(function(el) {
                            return el.missing;
                        });
                    }
                },
                labels: {
                    get: function() {
                        return this.validExtents.map(function(el) {
                            return el.value.references.name;
                        });
                    }
                },
                length: {
                    get: function() {
                        return this.data.type.elements.length;
                    }
                },
                validLength: {
                    get: function() {
                        return this.validExtents.length;
                    }
                },
                validExtents: {
                    get: function() {
                        return this.data.type.elements.filter(function(el) {
                            return el.missing === false;
                        });
                    }
                },
                subscripts: {
                    get: function() {
                        return this.data.type.categories.map(function(e, i) {
                            return i;
                        });
                    }
                },
                missingSubscripts: {
                    get: function() {
                        var out = [];
                        var elements = this.data.type.elements.filter(function(el, idx) {
                            var id = el.value && el.value.id || "";
                            if (el.missing) {
                                out.push(idx);
                                return true;
                            }
                        });
                        return out;
                    }
                },
                validSubscripts: {
                    get: function() {
                        var out = [];
                        var elements = this.data.type.elements.filter(function(el, idx) {
                            var id = el.value && el.value.id || "";
                            if (el.missing === false) {
                                out.push(idx);
                                return true;
                            }
                        });
                        return out;
                    }
                },
                prunedExtents: {
                    set: function(replacement) {
                        this.data.type.elements = replacement;
                    }
                }
            });
            return CompositeDimension;
        }
    }, {} ],
    121: [ function(require, module, exports) {
        "use strict";
        module.exports = CrFindVariablesFactory;
        CrFindVariablesFactory.$inject = [];
        function CrFindVariablesFactory() {
            function findVariables(expr) {
                var variable = expr.variable || false, value = expr.value || false, func = expr.function || false, each = expr.each || false, args = expr instanceof Array || false, string = typeof expr == "string" || false;
                if (variable) {
                    return variable;
                } else if (func) {
                    return findVariables(expr.args);
                } else if (each) {
                    var varid = expr.each || false;
                    if (!!varid) {
                        return varid;
                    }
                } else if (args) {
                    return findVariables(expr[0]);
                } else if (string) {
                    return expr;
                }
                return undefined;
            }
            return findVariables;
        }
    }, {} ],
    122: [ function(require, module, exports) {
        "use strict";
        module.exports = CubeFactory;
        CubeFactory.$inject = [ "$log", "$q", "lodash", "dimension", "measure" ];
        function CubeFactory($log, $q, _, dimension, measure) {
            var Cube = function(measures, meta, margins) {
                var shape = meta.shape;
                var validShape = meta.validShape;
                this.dimension = validShape.length;
                this.n = meta.n;
                this._dimensions = meta.dimensions;
                this.query = meta.query;
                this.valid = meta.n;
                this.nMissing = meta.nMissing;
                this.weightId = meta.weightId;
                this.appliedFilters = _.cloneDeep(meta.appliedFilters);
                _.extend(this, measures);
                return this;
            };
            Object.defineProperties(Cube.prototype, {
                labels: {
                    get: function() {
                        return this._dimensions.map(function(dim) {
                            return dim.labels;
                        });
                    }
                },
                subscripts: {
                    get: function() {
                        return this._dimensions.map(function(dim) {
                            return dim.validSubscripts;
                        });
                    }
                }
            });
            Cube.fromCrCube = function(crunchCube) {
                var raw = crunchCube;
                var meta = {
                    measures: Object.keys(raw.result.measures),
                    query: raw.query
                };
                var result = {};
                var dims = (raw.result.dimensions || []).map(function(dim) {
                    return dimension.fromData(dim);
                });
                if (dims.length === 0) {
                    dims.push(dimension.aggregateDimension("Mean"));
                }
                meta = gatherMetadata(raw.result, dims, meta);
                meta.dimensions = dims;
                meta.appliedFilters = raw.query ? raw.query.filters : [];
                meta.weightId = raw.query ? raw.query.weight : undefined;
                var measures = _.mapValues(raw.result.measures, function(m, type) {
                    return measure.fromData({
                        type: type,
                        data: m.data,
                        meta: meta
                    });
                });
                result = new Cube(measures, meta, raw.margins);
                return $q.when(result);
            };
            function gatherMetadata(result, dims, meta) {
                meta.nMissing = result.measures[meta.measures[0]].n_missing || 0;
                meta.n = result.n - meta.nMissing;
                meta.shape = dims.map(function(dim) {
                    return dim.length;
                });
                meta.missing = dims.map(function(dim) {
                    return dim.missing;
                });
                meta.validShape = dims.map(function(dim) {
                    return dim.validLength;
                });
                if (meta.validShape.length === 1) {
                    meta.validShape.push(1);
                }
                meta.labels = dims.map(function(dim) {
                    return dim.labels;
                });
                return meta;
            }
            function prod() {
                var args = [].slice.call(arguments), end = args.length - 1;
                var result = [];
                function addTo(curr, start) {
                    var first = args[start], last = start === end;
                    for (var i = 0; i < first.length; ++i) {
                        var copy = curr.slice();
                        copy.push(first[i]);
                        if (last) {
                            result.push(copy);
                        } else {
                            addTo(copy, start + 1);
                        }
                    }
                }
                if (args.length) {
                    addTo([], 0);
                } else {
                    result.push([]);
                }
                return result;
            }
            Cube.prod = prod;
            Cube.prototype.ravelLabels = function() {
                return prod.apply(this, this.labels);
            };
            return Cube;
        }
    }, {} ],
    123: [ function(require, module, exports) {
        "use strict";
        module.exports = DimensionFactory;
        DimensionFactory.$inject = [ "lodash", "CategoricalDimension", "BinnedDimension", "CompositeDimension", "MultiResponseDimension" ];
        function DimensionFactory(_, CategoricalDimension, BinnedDimension, CompositeDimension, MultiResponseDimension) {
            function assertBasicDimensionStructure(data) {
                assertProperties(data, "derived", "references", "type");
            }
            function isCategoricalDimension(data) {
                var type = data.type;
                return type.hasOwnProperty("categories") && type.categories.every(function(cat) {
                    return assertProperties(cat, "id", "missing", "name", "numeric_value", true);
                });
            }
            function isBinnedDimension(data) {
                var type = data.type;
                return type.hasOwnProperty("elements") && type.elements.every(function(el) {
                    return assertProperties(el, "id", "missing", "value", true) && !assertProperties(el.value, "references", "type", "id", true);
                });
            }
            function isMultiResponseDimension(data) {
                var type = data.type, hasElements = type.hasOwnProperty("elements"), hasProps = hasElements && type.elements.every(function(el) {
                    return assertProperties(el, "id", "missing", "value", true);
                }), hasAnyAndNone = hasProps && type.elements.filter(function(el) {
                    return el.value && (el.value.id === "__none__" || el.value.id === "__any__");
                }).length === 2;
                return hasAnyAndNone;
            }
            function isCategoricalArrayDimension(data) {
                var type = data.type, hasElements = type.hasOwnProperty("elements"), hasProps = hasElements && type.elements.every(function(el) {
                    return assertProperties(el, "id", "missing", "value", true) && isCategoricalDimension(el.value);
                });
                return hasProps;
            }
            function assertProperties(object) {
                var properties = Array.prototype.slice.call(arguments, 1), silent = properties.pop();
                return properties.every(function(prop) {
                    return assertProperty(object, prop, silent);
                });
            }
            function assertProperty(object, property, silent) {
                var has = object.hasOwnProperty(property);
                if (!has && !silent) {
                    throw new Error("Object should have property " + property);
                }
                return has;
            }
            function AggregateDimension(data) {
                this.data = data;
            }
            Object.defineProperties(AggregateDimension.prototype, {
                length: {
                    value: 1
                },
                validSubscripts: {
                    value: [ 0 ]
                },
                validLength: {
                    value: 1
                },
                missing: {
                    value: [ false ]
                },
                labels: {
                    get: function() {
                        return [ this.data.name ];
                    }
                }
            });
            return {
                fromData: function(data) {
                    var dimension;
                    assertBasicDimensionStructure(data);
                    if (isCategoricalDimension(data)) {
                        dimension = new CategoricalDimension(data);
                    } else if (isBinnedDimension(data)) {
                        dimension = new BinnedDimension(data);
                    } else if (isMultiResponseDimension(data)) {
                        dimension = new MultiResponseDimension(data);
                    } else if (isCategoricalArrayDimension(data)) {
                        dimension = new CompositeDimension(data);
                    }
                    dimension.reference = data.references.name;
                    return dimension;
                },
                aggregateDimension: function(name) {
                    return new AggregateDimension({
                        name: name
                    });
                }
            };
        }
    }, {} ],
    124: [ function(require, module, exports) {
        "use strict";
        module.exports = buildModule;
        function buildModule(moduleName) {
            var angular = require("angular"), ndarray = require("ndarray"), ops = require("ndarray-ops"), cwise = require("cwise"), show = require("ndarray-show"), unpack = require("ndarray-unpack"), pack = require("ndarray-pack"), scratch = require("ndarray-scratch"), fill = require("ndarray-fill"), normalDist = require("gaussian"), ndgemm = require("ndgemm"), _ = require("lodash");
            moduleName = moduleName || "cube";
            var mod = angular.module(moduleName, []);
            mod.factory("ndarray", function() {
                return ndarray;
            });
            mod.factory("ndarrayOps", function() {
                return ops;
            });
            mod.factory("cwise", function() {
                return cwise;
            });
            mod.factory("lodash", function() {
                return _;
            });
            mod.factory("show", function() {
                return show;
            });
            mod.factory("ndarrayUnpack", function() {
                return unpack;
            });
            mod.factory("ndarrayPack", function() {
                return pack;
            });
            mod.factory("ndarrayScratch", function() {
                return scratch;
            });
            mod.factory("ndarrayFill", function() {
                return fill;
            });
            mod.factory("ndgemm", function() {
                return ndgemm;
            });
            mod.factory("normalDist", function() {
                return normalDist;
            });
            mod.factory("dimension", require("./dimension"));
            mod.factory("CategoricalDimension", require("./categorical-dimension"));
            mod.factory("BinnedDimension", require("./binned-dimension"));
            mod.factory("CompositeDimension", require("./composite-dimension"));
            mod.factory("MultiResponseDimension", require("./multi-response-dimension"));
            mod.factory("measure", require("./measure"));
            mod.factory("cube", require("./cube"));
            mod.factory("crFindVariables", require("./cr-find-variables"));
            mod.factory("stats", require("./stats"));
            mod.factory("Tabulated", require("./tabulated"));
            return mod;
        }
    }, {
        "./binned-dimension": 118,
        "./categorical-dimension": 119,
        "./composite-dimension": 120,
        "./cr-find-variables": 121,
        "./cube": 122,
        "./dimension": 123,
        "./measure": 125,
        "./multi-response-dimension": 126,
        "./stats": 127,
        "./tabulated": 128,
        angular: "angular",
        cwise: 12,
        gaussian: 76,
        lodash: 77,
        ndarray: 101,
        "ndarray-fill": 80,
        "ndarray-ops": 81,
        "ndarray-pack": 86,
        "ndarray-scratch": 95,
        "ndarray-show": 96,
        "ndarray-unpack": 100,
        ndgemm: 103
    } ],
    125: [ function(require, module, exports) {
        "use strict";
        module.exports = MeasureFactory;
        MeasureFactory.$inject = [ "lodash", "ndarray" ];
        function MeasureFactory(_, ndarray) {
            var allowedTypes = [ "mean", "stddev", "count" ];
            function assertType(type) {
                if (allowedTypes.indexOf(type) === -1) {
                    throw new Error("unsupported measure");
                }
            }
            function Measure(config) {
                var dimensions = config.meta.dimensions, missing = config.meta.missing, shape = config.meta.shape, validShape = config.meta.validShape, type = config.type, data = config.data, isMissing, validData;
                isMissing = prod.apply(this, missing).map(function(indices) {
                    return indices.some(function(missing) {
                        return missing;
                    });
                });
                validData = data.filter(function(d, i) {
                    return !isMissing[i];
                });
                this.dimensions = dimensions;
                this.type = type;
                this.rawData = ndarray(data, shape);
                this.cube = ndarray(validData, validShape);
            }
            function prod() {
                var args = [].slice.call(arguments), end = args.length - 1;
                var result = [];
                function addTo(curr, start) {
                    var first = args[start], last = start === end;
                    for (var i = 0; i < first.length; ++i) {
                        var copy = curr.slice();
                        copy.push(first[i]);
                        if (last) {
                            result.push(copy);
                        } else {
                            addTo(copy, start + 1);
                        }
                    }
                }
                if (args.length) {
                    addTo([], 0);
                } else {
                    result.push([]);
                }
                return result;
            }
            return {
                fromData: function(config) {
                    config = config || {};
                    assertType(config.type);
                    return new Measure(config);
                }
            };
        }
    }, {} ],
    126: [ function(require, module, exports) {
        "use strict";
        module.exports = MultiResponseDimensionFactory;
        MultiResponseDimensionFactory.$inject = [ "lodash", "CompositeDimension" ];
        function MultiResponseDimensionFactory(_, CompositeDimension) {
            var noneOrAny = [ "__none__", "__any__" ];
            function MultiResponseDimension(data) {
                this.data = data;
            }
            function byId(data, id) {
                return data.filter(function(el) {
                    return el.value && el.value.id === id;
                })[0];
            }
            MultiResponseDimension.prototype = new CompositeDimension();
            Object.defineProperties(MultiResponseDimension.prototype, {
                name: {
                    get: function() {
                        return this.data.references.name || undefined;
                    }
                },
                type: {
                    value: "multiresponse"
                },
                missing: {
                    get: function() {
                        var elements = this.data.type.elements.map(function(el) {
                            var id = el.value && el.value.id || "";
                            return noneOrAny.indexOf(id) > -1 ? true : el.missing;
                        });
                        return elements;
                    }
                },
                validExtents: {
                    get: function() {
                        return this.data.type.elements.filter(function(el) {
                            var id = el.value && el.value.id || "";
                            return el.missing === false && noneOrAny.indexOf(id) === -1;
                        });
                    }
                },
                subscripts: {
                    get: function() {
                        return this.data.type.elements.map(function(e, i) {
                            return i;
                        });
                    }
                },
                missingSubscripts: {
                    get: function() {
                        var out = [];
                        var elements = this.data.type.elements.filter(function(el, idx) {
                            var id = el.value && el.value.id || "";
                            if (noneOrAny.indexOf(id) > -1 ? true : el.missing) {
                                out.push(idx);
                                return true;
                            }
                        }, this);
                        return out;
                    }
                },
                validSubscripts: {
                    get: function() {
                        var out = [];
                        var elements = this.data.type.elements.filter(function(el, idx) {
                            var id = el.value && el.value.id || "";
                            if (el.missing === false && noneOrAny.indexOf(id) === -1) {
                                out.push(idx);
                                return true;
                            }
                        }, this);
                        return out;
                    }
                },
                validLength: {
                    get: function() {
                        var elements = this.data.type.elements.filter(function(el) {
                            var id = el.value && el.value.id || "";
                            return noneOrAny.indexOf(id) > -1 ? false : !el.missing;
                        });
                        return elements.length;
                    }
                },
                countingSubscripts: {
                    get: function() {
                        var ids = this.data.type.elements.map(function(el) {
                            return el.id;
                        });
                        return [ ids.indexOf(0), ids.indexOf(-127) ];
                    }
                },
                prunedExtents: {
                    set: function(replacement) {
                        this.data.type.elements = replacement;
                    }
                }
            });
            return MultiResponseDimension;
        }
    }, {} ],
    127: [ function(require, module, exports) {
        module.exports = StatsFactory;
        StatsFactory.$inject = [ "lodash", "cube", "ndarray", "ndarrayOps", "ndgemm", "ndarrayScratch", "ndarrayFill", "normalDist", "show" ];
        function StatsFactory(_, Cube, ndarray, ops, gemm, scratch, fill, normalDist, show) {
            function margin(cube, axis) {
                var types = [];
                var subscripts = cube._dimensions.map(function(d, i) {
                    types.push(d.type);
                    if (d.type === "multiresponse") {
                        return i === axis ? d.validSubscripts : d.countingSubscripts;
                    }
                    return d.validSubscripts;
                });
                var arrayDim = types.indexOf("composite");
                var specialArrayTreatment = arrayDim > -1 && arrayDim !== axis;
                if (specialArrayTreatment && axis === undefined) {
                    return new ndarray([ cube.n ], [ 1, 1 ]);
                }
                if (specialArrayTreatment) {
                    subscripts[arrayDim] = [ 0 ];
                }
                var shape = subscripts.map(function(d) {
                    return d.length;
                });
                var marginShape = subscripts.map(function(d, i) {
                    return d.length;
                }, this);
                if (shape.length === 1) {
                    shape.push(1);
                    marginShape.push(1);
                }
                indices = Cube.prod.apply(this, subscripts);
                var data = cube.count.rawData;
                var marginTable = scratch.malloc(marginShape);
                marginTable.data = indices.map(function(d, i) {
                    return data.get.apply(data, d);
                });
                if (specialArrayTreatment) {
                    fill(marginTable, function() {
                        return cube.n;
                    });
                }
                if (axis === undefined) {
                    return ndarray([ ops.sum(marginTable) ], [ 1, 1 ]);
                } else {
                    var countShape = [ 1, 1 ];
                    var outShape = [ 1, 1 ];
                    countShape[axis] = marginShape[1 - axis];
                    outShape[axis] = shape[axis];
                    var counter = scratch.malloc(countShape);
                    fill(counter, function() {
                        return 1;
                    });
                    var out = scratch.malloc(outShape);
                    var args = new Array(2);
                    args[axis] = marginTable;
                    args[1 - axis] = counter;
                    args.unshift(out);
                    gemm.apply(this, args);
                    return out;
                }
            }
            function propTable(cube, axis, marginal, includeMissing) {
                var includeMissing = includeMissing || false;
                var table, tbl, marginal, total;
                if (cube.hasOwnProperty("count")) {
                    table = cube.count.cube;
                    total = margin(cube).get(0, 0);
                } else {
                    marginal = cube;
                    table = cube;
                    total = ops.sum(marginal);
                }
                var shape = table.shape.slice();
                if (shape.length === 1) {
                    shape.push(1);
                    tbl = scratch.malloc(shape);
                    fill(tbl, function(i, j) {
                        return table.get.apply(table, [ i, j ]);
                    });
                } else {
                    tbl = scratch.clone(table);
                }
                var out = scratch.malloc(shape);
                if (marginal === undefined) {
                    marginal = margin(cube, axis);
                }
                if (axis === undefined) {
                    ops.divs(out, tbl, total);
                } else {
                    fill(out, function(i, j) {
                        var args = axis == 0 ? [ i, 0 ] : [ 0, j ];
                        return tbl.get(i, j) / marginal.get.apply(marginal, args);
                    });
                }
                return out;
            }
            function diffTable(cube, axis, marginal) {
                var out = propTable(cube, axis);
                var total = margin(cube).get(0, 0);
                if (axis === undefined) {
                    var rowMargin = margin(cube, 0);
                    var colMargin = margin(cube, 1);
                    var indep = scratch.malloc(out.shape);
                    var total = ops.sum(rowMargin);
                    ops.divseq(rowMargin, total);
                    ops.divseq(colMargin, total);
                    gemm(indep, rowMargin, colMargin);
                    ops.subeq(out, indep);
                    return out;
                }
                if (marginal === undefined) {
                    var marginal = margin(cube, 1 - axis);
                }
                ops.divseq(marginal, total);
                var swept = scratch.malloc(out.shape);
                fill(swept, function(i, j) {
                    var args = axis == 0 ? [ 0, j ] : [ i, 0 ];
                    return marginal.get.apply(marginal, args);
                });
                ops.subeq(out, swept);
                return out;
            }
            function getPvalues(rawcube, margin) {
                var strategies = {
                    row: dim0Pvalues,
                    col: dim1Pvalues,
                    cell: dimBothPvalues
                };
                var s = margin === undefined ? "cell" : margin === 0 ? "row" : "col";
                return strategies[s](rawcube, margin);
            }
            function ones() {
                return 1;
            }
            function dim0Pvalues(rawcube, axis) {
                var tbl = rawcube.count.cube;
                var n = margin(rawcube).get(0, 0);
                var shape = tbl.shape;
                var colMargin = margin(rawcube, 1);
                var rowMargin = margin(rawcube, 0);
                var diff = scratch.zeros(shape);
                ops.divseq(colMargin, n);
                fill(diff, function(i, j) {
                    var cell = tbl.get(i, j) / rowMargin.get(i, 0);
                    return isNaN(cell) ? 0 : cell;
                });
                ops.divseq(rowMargin, n);
                var dsquared = scratch.clone(diff);
                var rightside = scratch.clone(diff);
                ops.muleq(dsquared, diff);
                ops.subeq(rightside, dsquared);
                scratch.free(dsquared);
                var expected = scratch.zeros([ 1, shape[1] ]);
                gemm(expected, rowMargin.transpose(1, 0), rightside);
                scratch.free(rightside);
                var d = scratch.malloc(rowMargin.shape);
                fill(d, function(i) {
                    var cell = rowMargin.get(i, 0);
                    return (1 - 2 * cell) / cell;
                });
                var se = scratch.zeros(shape);
                fill(se, function(i, j) {
                    var obs = diff.get(i, j);
                    var v = d.get(i, 0) * obs * (1 - obs) + expected.get(0, j);
                    return Math.sqrt(v / n);
                });
                scratch.free(expected);
                scratch.free(d);
                var Z = scratch.malloc(shape);
                fill(Z, function(i, j) {
                    return colMargin.get(0, j);
                });
                ops.mulseq(Z, -1);
                ops.addeq(Z, diff);
                ops.diveq(Z, se);
                var sign = scratch.zeros(shape);
                function sgnZ(i, j) {
                    var value = Z.get(i, j);
                    return (value > 0) - (value < 0);
                }
                fill(sign, sgnZ);
                ops.abseq(Z);
                var pnorm = normalDist(0, 1).cdf;
                var p = scratch.zeros(shape);
                fill(p, function(i, j) {
                    return 2 * (1 - pnorm(Z.get(i, j)));
                });
                ops.muleq(p, sign);
                return p;
            }
            function dim1Pvalues(rawcube, axis) {
                var tbl = rawcube.count.cube;
                var n = margin(rawcube).get(0, 0);
                var shape = tbl.shape;
                var colMargin = margin(rawcube, 1);
                var rowMargin = margin(rawcube, 0);
                var diff = scratch.zeros(shape);
                ops.divseq(rowMargin, n);
                fill(diff, function(i, j) {
                    var cell = tbl.get(i, j) / colMargin.get(0, j);
                    return isNaN(cell) ? 0 : cell;
                });
                ops.divseq(colMargin, n);
                var dsquared = scratch.clone(diff);
                var rightside = scratch.clone(diff);
                ops.muleq(dsquared, diff);
                ops.subeq(rightside, dsquared);
                scratch.free(dsquared);
                var expected = scratch.zeros([ shape[0], 1 ]);
                gemm(expected, rightside, colMargin.transpose(1, 0));
                scratch.free(rightside);
                var d = scratch.malloc(colMargin.shape);
                fill(d, function(i, j) {
                    var cell = colMargin.get(0, j);
                    return (1 - 2 * cell) / cell;
                });
                var se = scratch.zeros(shape);
                fill(se, function(i, j) {
                    var obs = diff.get(i, j);
                    var v = d.get(0, j) * obs * (1 - obs) + expected.get(i, 0);
                    return Math.sqrt(v / n);
                });
                scratch.free(expected);
                scratch.free(d);
                var Z = scratch.malloc(shape);
                fill(Z, function(i, j) {
                    return rowMargin.get(i, 0);
                });
                ops.mulseq(Z, -1);
                ops.addeq(Z, diff);
                ops.diveq(Z, se);
                var sign = scratch.malloc(shape);
                function sgnZ(i, j) {
                    var value = Z.get(i, j);
                    return (value > 0) - (value < 0);
                }
                fill(sign, sgnZ);
                ops.abseq(Z);
                var pnorm = normalDist(0, 1).cdf;
                var p = scratch.malloc(shape);
                fill(p, function(i, j) {
                    return 2 * (1 - pnorm(Z.get(i, j)));
                });
                ops.muleq(p, sign);
                return p;
            }
            function dimBothPvalues(rawcube, axis) {
                var tbl = rawcube.count.cube;
                var n = ops.sum(tbl);
                var shape = tbl.shape;
                var onesCt = scratch.malloc([ 1, shape[0] ]);
                var onesR = scratch.malloc([ shape[1], 1 ]);
                var colMargin = scratch.malloc([ 1, shape[1] ]);
                var rowMargin = scratch.malloc([ shape[0], 1 ]);
                function ones() {
                    return 1;
                }
                fill(onesR, ones);
                fill(onesCt, ones);
                gemm(colMargin, onesCt, tbl);
                gemm(rowMargin, tbl, onesR);
                ops.divseq(tbl, n);
                ops.divseq(colMargin, n);
                ops.divseq(rowMargin, n);
                var expected = scratch.zeros(shape);
                gemm(expected, rowMargin, colMargin);
                var Z = scratch.clone(expected);
                var rightside = scratch.clone(expected);
                ops.mulseq(rightside, -1);
                ops.addseq(rightside, 1);
                ops.muleq(expected, rightside);
                scratch.free(rightside);
                var se = scratch.zeros(shape);
                fill(se, function(i, j) {
                    var obs = tbl.get(i, j);
                    var v = obs * (1 - obs) + expected.get(i, j);
                    return Math.sqrt(v / n);
                });
                scratch.free(expected);
                ops.mulseq(Z, -1);
                ops.addeq(Z, tbl);
                ops.diveq(Z, se);
                ops.abseq(Z);
                var pnorm = normalDist(0, 1).cdf;
                var p = scratch.zeros(shape);
                fill(p, function(i, j) {
                    return 2 * (1 - pnorm(Z.get(i, j)));
                });
                return p;
            }
            function filterByMarginThreshold(cube, cutoff) {
                var orig = cube.count.cube;
                var rowMargin = margin(cube, 0);
                var colMargin = margin(cube, 1);
                ops.gtseq(rowMargin, cutoff);
                ops.gtseq(colMargin, cutoff);
                var subscripts = [ Array.prototype.slice.call(rowMargin.data), Array.prototype.slice.call(colMargin.data) ];
                function getLength(d) {
                    return d.length;
                }
                var initShape = subscripts.map(getLength);
                var filtered = subscripts.map(function(s) {
                    var filteredSubscripts = [];
                    s.filter(function(d, i) {
                        if (d > 0) {
                            filteredSubscripts.push(i);
                            return true;
                        }
                        return false;
                    }, this);
                    return filteredSubscripts;
                }, this);
                return filtered;
            }
            function getSortedSubscripts(vector) {
                var i = j = vector.length;
                var temp = [];
                while (i--) {
                    temp[i] = {
                        k: i,
                        v: vector[i]
                    };
                }
                function comparator(a, b) {
                    return a.v < b.v ? -1 : a.v > b.v ? 1 : 0;
                }
                temp.sort(comparator);
                return temp.map(function(d) {
                    return d.k;
                });
            }
            return {
                getPvalues: getPvalues,
                margin: margin,
                propTable: propTable,
                diffTable: diffTable,
                filterByMarginThreshold: filterByMarginThreshold,
                getSortedSubscripts: getSortedSubscripts
            };
        }
    }, {} ],
    128: [ function(require, module, exports) {
        "use strict";
        module.exports = TabulatedFactory;
        TabulatedFactory.$inject = [ "lodash", "cube", "ndarray", "ndarrayScratch" ];
        function TabulatedFactory(_, Cube, ndarray, scratch) {
            function Tabulated(bodies, margins) {
                this.bodies = bodies;
                this.margins = margins;
            }
            Object.defineProperties(Tabulated.prototype, {
                subscripts: {
                    get: function() {
                        var shape = this.bodies.value.shape.slice();
                        return shape.map(function(len) {
                            return _.range(0, len);
                        });
                    }
                }
            });
            Tabulated.prototype.filterPermute = function(subscripts) {
                var newMargins = {}, newBodies = {};
                _.forEach(this.margins, function(item, key) {
                    newMargins[key] = subscripts.map(function(s, dim) {
                        var out = [];
                        var orig = item[dim];
                        if (orig === undefined) {
                            return [];
                        }
                        s.forEach(function(i) {
                            out.push(orig[i]);
                        }, this);
                        return out;
                    }, this);
                }, this);
                _.forEach(this.bodies, function(body, key) {
                    var orig = scratch.clone(body);
                    var getThese = Cube.prod.apply(this, subscripts);
                    var newShape = subscripts.map(function(d) {
                        return d.length;
                    });
                    var newBody = scratch.malloc(newShape);
                    newBody.data = getThese.map(function(d) {
                        return orig.get.apply(orig, d);
                    });
                    newBodies[key] = newBody;
                });
                this.bodies = newBodies;
                this.margins = newMargins;
            };
            Tabulated.prototype.dataFrameTable = function() {
                var labels = Cube.prod.apply(this, this.margins.labels);
                var dftLabels = [];
                labels.forEach(function(lab, i) {
                    dftLabels.push({});
                    lab.forEach(function(each, j) {
                        dftLabels[i]["var" + j] = lab[j];
                    }, this);
                    _.forEach(this.bodies, function(bodyTable, k) {
                        dftLabels[i][k] = bodyTable.data[i];
                    }, this);
                }, this);
                return dftLabels;
            };
            return Tabulated;
        }
    }, {} ],
    129: [ function(require, module, exports) {
        "use strict";
        module.exports = CurrentDatasetFactory;
        CurrentDatasetFactory.$inject = [ "lodash", "$q", "$injector" ];
        function CurrentDatasetFactory(_, $q, $injector) {
            var currentDatasetId, currentDataset, pendingDatasetRequest;
            return {
                fetch: function() {
                    var promise = $q.reject({}), iResourceDataset;
                    iResourceDataset = $injector.get("iResourceDataset");
                    if (_.isObject(currentDataset)) {
                        promise = $q.when(currentDataset);
                    } else if (_.isObject(pendingDatasetRequest)) {
                        promise = pendingDatasetRequest;
                    } else if (_.isString(currentDatasetId)) {
                        pendingDatasetRequest = iResourceDataset({
                            datasetId: currentDatasetId,
                            noCache: true
                        });
                        pendingDatasetRequest.then(function(dataset) {
                            currentDataset = dataset;
                        });
                        promise = pendingDatasetRequest;
                    }
                    return promise;
                },
                set: function(datasetId) {
                    if (currentDatasetId !== datasetId) {
                        currentDataset = null;
                        pendingDatasetRequest = null;
                        currentDatasetId = datasetId;
                    }
                },
                clean: function() {
                    currentDataset = null;
                    pendingDatasetRequest = null;
                },
                reset: function() {
                    currentDatasetId = null;
                    this.clean();
                }
            };
        }
    }, {} ],
    130: [ function(require, module, exports) {
        "use strict";
        module.exports = buildModule;
        function buildModule(moduleName) {
            var angular = require("angular");
            moduleName = moduleName || "current-dataset";
            var mod = angular.module(moduleName, []);
            mod.factory("lodash", function() {
                return require("lodash");
            });
            mod.factory("currentDataset", require("./current-dataset"));
            return mod;
        }
    }, {
        "./current-dataset": 129,
        angular: "angular",
        lodash: 77
    } ],
    131: [ function(require, module, exports) {
        "use strict";
        module.exports = DragAndDropFactory;
        DragAndDropFactory.$inject = [ "machina", "$rootScope", "$log" ];
        function DragAndDropFactory(machina, $rootScope, $log) {
            function assert(pred, msg) {
                if (pred) {
                    return;
                }
                throw new Error(msg);
            }
            function debug(e) {
                return function() {
                    var args = [].slice.call(arguments);
                    args.unshift(e);
                    args.unshift("drag-and-drop");
                    return $log.debug.apply($log, args);
                };
            }
            var DragAndDrop = machina.Fsm.extend({
                initialState: "uninitialized",
                destroy: function() {
                    this.transition("destroyed");
                },
                _publish: function(event, operation, dropped) {
                    var e = event;
                    if (operation) {
                        e += ":" + operation;
                    }
                    var payload = {
                        operation: operation,
                        dragged: this.inflight,
                        dropped: dropped
                    };
                    $log.debug("drag-and-drop", "publishing", e, payload);
                    $rootScope.$broadcast(e, payload);
                },
                _broadcast: function(e) {
                    assert(e.event, "event name is required");
                    return $rootScope.$broadcast(e.event, e);
                },
                initialize: function() {
                    this.on("transition", debug("transition"));
                    this.on("link:started", this._broadcast.bind(this));
                    this.on("move:started", this._broadcast.bind(this));
                    this.on("copy:started", this._broadcast.bind(this));
                    this.on("drag:started", this._broadcast.bind(this));
                    this.on("link:cancelled", this._broadcast.bind(this));
                    this.on("move:cancelled", this._broadcast.bind(this));
                    this.on("copy:cancelled", this._broadcast.bind(this));
                    this.on("drag:cancelled", this._broadcast.bind(this));
                },
                states: {
                    uninitialized: {
                        initialize: function() {
                            this.transition("draggable");
                        }
                    },
                    draggable: {
                        _onEnter: function() {
                            this.inflight = undefined;
                        },
                        drag: function(spec) {
                            this.inflight = spec;
                            this.transition("dragging");
                        },
                        link: function(spec) {
                            this.inflight = spec;
                            this.transition("linking");
                        },
                        copy: function(spec) {
                            this.inflight = spec;
                            this.transition("copying");
                        },
                        move: function(spec) {
                            this.inflight = spec;
                            this.transition("moving");
                        }
                    },
                    dragging: {
                        _onEnter: function() {
                            this.emit("drag:started", {
                                event: "drag:started",
                                inflight: this.inflight,
                                operation: "drag"
                            });
                        },
                        commit: function(e, droppedOn) {
                            this._publish(e, undefined, droppedOn);
                            this.transition("draggable");
                        },
                        cancel: function() {
                            this.emit("drag:cancelled", {
                                event: "drag:cancelled",
                                inflight: this.inflight,
                                operation: "drag"
                            });
                            this.transition("draggable");
                        }
                    },
                    linking: {
                        _onEnter: function() {
                            this.emit("link:started", {
                                event: "link:started",
                                inflight: this.inflight,
                                operation: "link"
                            });
                        },
                        commit: function(e, droppedOn) {
                            if (typeof e === "string") {
                                this._publish(e, "link", droppedOn);
                            } else {
                                this._publish("drop", "link", droppedOn);
                            }
                            this.transition("draggable");
                        },
                        cancel: function() {
                            this.emit("link:cancelled", {
                                event: "link:cancelled",
                                inflight: this.inflight,
                                operation: "link"
                            });
                            this.transition("draggable");
                        }
                    },
                    copying: {
                        _onEnter: function() {
                            this.emit("copy:started", {
                                event: "copy:started",
                                inflight: this.inflight,
                                operation: "copy"
                            });
                        },
                        commit: function(e, droppedOn) {
                            this._publish(e, "copy", droppedOn);
                            this.transition("draggable");
                        },
                        cancel: function() {
                            this.emit("copy:cancelled", {
                                event: "copy:cancelled",
                                inflight: this.inflight,
                                operation: "copy"
                            });
                            this.transition("draggable");
                        }
                    },
                    moving: {
                        _onEnter: function() {
                            this.emit("move:started", {
                                event: "move:started",
                                inflight: this.inflight,
                                operation: "move"
                            });
                        },
                        commit: function(e, droppedOn) {
                            this._publish(e, "move", droppedOn);
                            this.transition("draggable");
                        },
                        cancel: function() {
                            this.emit("move:cancelled", {
                                event: "move:cancelled",
                                inflight: this.inflight,
                                operation: "move"
                            });
                            this.transition("draggable");
                        }
                    },
                    destroyed: {
                        _onEnter: function() {
                            return this.off();
                        }
                    }
                }
            });
            var one = new DragAndDrop();
            one.handle("initialize");
            return one;
        }
    }, {} ],
    132: [ function(require, module, exports) {
        module.exports = function() {
            "use strict";
            function DragCoverDirective($injector) {
                return {
                    restrict: "A",
                    link: function(scope, elem, attrs) {
                        var handleExpand = function(e) {
                            elem.addClass("drag-cover");
                        };
                        var handleContract = function(e) {
                            elem.removeClass("drag-cover");
                        };
                        scope.handleExpand = handleExpand;
                        scope.handleContract = handleContract;
                        elem.bind("drop", function(e) {
                            if (e.preventDefault) {
                                e.preventDefault();
                            }
                            scope.$safeApply(function() {
                                handleContract.apply(this, [ e.originalEvent ]);
                            });
                        });
                        if (attrs.dragCoverExpandEvent) {
                            scope.$on(attrs.dragCoverExpandEvent, function(evt, data) {
                                handleExpand.apply(this, evt);
                            });
                        }
                        if (attrs.dragCoverContractEvent) {
                            scope.$on(attrs.dragCoverContractEvent, function(evt, data) {
                                handleContract.apply(this, evt);
                            });
                        }
                        scope.$on("$destroy", function() {
                            elem.off("drop");
                        });
                    }
                };
            }
            DragCoverDirective.$inject = [ "$injector" ];
            return DragCoverDirective;
        }.call(this);
    }, {} ],
    133: [ function(require, module, exports) {
        "use strict";
        module.exports = DragDirective;
        DragDirective.$inject = [ "$injector", "$rootScope" ];
        function DragDirective($injector, $rootScope) {
            var SERIALIZER_KEY = "__serializer";
            return {
                restrict: "A",
                link: function(scope, elem, attrs) {
                    var draggedData, elm = elem[0];
                    elm.setAttribute("draggable", true);
                    scope.$watch(attrs.drag, function(value) {
                        if (!value) {
                            return;
                        }
                        draggedData = value;
                    });
                    function serialize(it) {
                        var serializerName = it[SERIALIZER_KEY];
                        if (it && serializerName) {
                            var serializer = $injector.get(serializerName);
                            if (!serializer) {
                                throw new Error("serializer " + serializerName + " could not be found.");
                            }
                            if (!serializer.serialize) {
                                throw new Error("serializers " + serializerName + " forgot to implement `serialize`");
                            }
                            return serializer.serialize(it);
                        }
                        return JSON.stringify(it);
                    }
                    var handleDragStart = function(e) {
                        scope.$apply(function() {
                            e.dataTransfer.effectAllowed = "move";
                            e.dataTransfer.setData("application/json", serialize(draggedData));
                            e.dataTransfer.setData("text/plain", attrs.dragKey);
                            elm.classList.add("dragging");
                            if (attrs.dragEvent) {
                                var data = {
                                    draggedData: draggedData,
                                    key: attrs.dragKey
                                };
                                scope.$emit(attrs.dragEvent, data);
                            }
                        });
                    };
                    var handleDragEnd = function(e) {
                        scope.$apply(function() {
                            elm.classList.remove("dragging");
                            if (attrs.dragEndEvent) {
                                scope.$emit(attrs.dragEndEvent, {});
                            }
                        });
                    };
                    scope.handleDragStart = handleDragStart;
                    scope.handleDragEnd = handleDragEnd;
                    elm.addEventListener("dragstart", handleDragStart.bind(this));
                    elm.addEventListener("dragend", handleDragEnd.bind(this));
                    scope.$on("$destroy", function() {
                        draggedData = undefined;
                        elm.removeEventListener("dragstart", handleDragStart);
                        elm.removeEventListener("dragend", handleDragEnd);
                    });
                }
            };
        }
    }, {} ],
    134: [ function(require, module, exports) {
        "use strict";
        module.exports = DragItDirective;
        DragItDirective.$inject = [ "dragAndDrop", "$log", "$timeout" ];
        function DragItDirective(dragAndDrop, $log, $timeout) {
            return {
                restrict: "ACE",
                link: function(scope, el, attrs) {
                    var elm = el[0];
                    var handle = dragAndDrop.handle.bind(dragAndDrop), classList = elm.classList;
                    function discoverOperation() {
                        return attrs.dragitOperation || "drag";
                    }
                    function discoverClass() {
                        return attrs.dragitClass || "dragging";
                    }
                    function getData() {
                        return scope.$eval(attrs.dragit);
                    }
                    function onDragStart(e) {
                        var data = getData();
                        $log.debug("drag-and-drop", "drag", "start", e);
                        classList.add(discoverClass());
                        e.dataTransfer.effectAllowed = attrs.dragitOperation || "all";
                        e.dataTransfer.setData("application/json", data);
                        scope.$apply(function() {
                            var inflight = {
                                data: data,
                                element: elm,
                                event: e
                            };
                            var operation = discoverOperation();
                            handle(operation, inflight);
                        });
                    }
                    function onDragEnd(e) {
                        $log.debug("drag-and-drop", "drag", "end", e);
                        scope.$apply(function() {
                            var klass = discoverClass();
                            classList.remove(klass);
                            dragAndDrop.handle("cancel");
                        });
                    }
                    $timeout(function() {
                        elm.setAttribute("draggable", "true");
                        elm.addEventListener("dragstart", onDragStart);
                        elm.addEventListener("dragend", onDragEnd);
                    }, 500);
                    scope.$on("$destroy", function() {
                        elm.removeEventListener("dragstart", onDragStart);
                        elm.removeEventListener("dragend", onDragEnd);
                    });
                }
            };
        }
    }, {} ],
    135: [ function(require, module, exports) {
        "use strict";
        module.exports = DropDirective;
        DropDirective.$inject = [ "$log", "$injector" ];
        function DropDirective($log, $injector) {
            var SERIALIZER_KEY = "__serializer";
            return {
                restrict: "A",
                link: function(scope, elem, attrs) {
                    var droppableData;
                    var elm = elem[0], classList = elm.classList;
                    elm.setAttribute("droppable", true);
                    classList.add("drop-zone");
                    scope.$watch(attrs.drop, function(value) {
                        if (!value) {
                            return;
                        }
                        droppableData = value;
                    });
                    var handleDragEnter = function(e) {
                        scope.$apply(function() {
                            if (e.stopPropagation()) {
                                e.preventDefault();
                            }
                            classList.add("drag-over");
                        });
                    };
                    var handleDragOver = function(e) {
                        if (e.preventDefault) {
                            e.preventDefault();
                        }
                    };
                    var handleDragLeave = function(e) {
                        scope.$apply(function() {
                            if (e.stopPropagation()) {
                                e.preventDefault();
                            }
                            classList.remove("drag-over");
                        });
                    };
                    function deserialize(str) {
                        var json = JSON.parse(str);
                        if (str.search(SERIALIZER_KEY) < 0) {
                            return json;
                        }
                        var serializerName = json[SERIALIZER_KEY];
                        var serializer = $injector.get(serializerName);
                        if (!serializer) {
                            throw new Error("serializer " + serializerName + " not found");
                        }
                        if (!serializer.deserialize) {
                            throw new Error("serializer " + serializerName + " forgot to implement deserialize");
                        }
                        return serializer.deserialize(str);
                    }
                    var handleDrop = function(e) {
                        scope.$apply(function() {
                            if (e.preventDefault) {
                                e.preventDefault();
                            }
                            classList.remove("drag-over");
                            if (attrs.dropKey === e.dataTransfer.getData("text/plain")) {
                                var key = e.dataTransfer.getData("text/plain");
                                var droppedData = e.dataTransfer.getData("application/json");
                                var droppedObject = deserialize(droppedData);
                                if (attrs.dropEvent) {
                                    var data = {
                                        droppedData: droppedObject,
                                        targetData: droppableData,
                                        key: attrs.dropKey
                                    };
                                    scope.$emit(attrs.dropEvent, data);
                                }
                                return true;
                            } else {
                                scope.$emit(attrs.dropCancel, {});
                                return false;
                            }
                        });
                    };
                    scope.handleDragEnter = handleDragEnter;
                    scope.handleDragLeave = handleDragLeave;
                    scope.handleDragOver = handleDragOver;
                    scope.handleDrop = handleDrop;
                    elm.addEventListener("dragenter", handleDragEnter.bind(this));
                    elm.addEventListener("dragleave", handleDragLeave.bind(this));
                    elm.addEventListener("dragover", handleDragOver.bind(this));
                    elm.addEventListener("drop", handleDrop.bind(this));
                    scope.$on("$destroy", function() {
                        elm.removeEventListener("drop", handleDrop);
                        elm.removeEventListener("dragleave", handleDragLeave);
                        elm.removeEventListener("dragover", handleDragOver);
                        elm.removeEventListener("dragenter", handleDragEnter);
                    });
                }
            };
        }
    }, {} ],
    136: [ function(require, module, exports) {
        "use strict";
        module.exports = DropItDirective;
        DropItDirective.$inject = [ "dragAndDrop", "$log" ];
        function DropItDirective(dragAndDrop, $log) {
            return {
                restrict: "ACE",
                scope: true,
                link: function(scope, el, attrs) {
                    var elm = el[0], classList = elm.classList, applied = false;
                    elm.setAttribute("droppable", "true");
                    elm.classList.add("drop-zone");
                    function discoverDroppableClass() {
                        return attrs.dropitClass || "drag-over";
                    }
                    function applyClass(e) {
                        if (!applied) {
                            classList.add(discoverDroppableClass());
                            applied = true;
                        }
                    }
                    function removeClass(e) {
                        if (applied) {
                            classList.remove(discoverDroppableClass());
                            applied = false;
                        }
                    }
                    function onDrop(e) {
                        $log.debug("drag-and-drop", "drop", "dropped", e);
                        if (e.preventDefault) {
                            e.preventDefault();
                        }
                        if (e.stopPropagation) {
                            e.stopPropagation();
                        }
                        scope.$apply(function() {
                            var e = attrs.dropitEvent || "dropped";
                            dragAndDrop.handle("commit", e, scope.$eval(attrs.dropit));
                        });
                        scope.$broadcast("drop");
                        removeClass(e);
                    }
                    function onDragOver(e) {
                        if (e.preventDefault) {
                            e.preventDefault();
                        }
                        if (e.stopPropagation) {
                            e.stopPropagation();
                        }
                        e.dataTransfer.dropEffect = "all";
                        applyClass(e);
                        scope.$broadcast("dragover");
                    }
                    function onDragEnter(e) {
                        $log.debug("drag-and-drop", "drop", "dragenter", e);
                        if (e.preventDefault) {
                            e.preventDefault();
                        }
                        if (e.stopPropagation) {
                            e.stopPropagation();
                        }
                    }
                    function onDragLeave(e) {
                        $log.debug("drag-and-drop", "drop", "dragleave", e);
                        if (e.preventDefault) {
                            e.preventDefault();
                        }
                        if (e.stopPropagation) {
                            e.stopPropagation();
                        }
                        removeClass(e);
                        scope.$broadcast("dragleave");
                    }
                    elm.addEventListener("drop", onDrop);
                    elm.addEventListener("dragover", onDragOver);
                    elm.addEventListener("dragenter", onDragEnter);
                    elm.addEventListener("dragleave", onDragLeave);
                    scope.$on("$destroy", function() {
                        elm.removeEventListener("drop", onDrop);
                        elm.removeEventListener("dragover", onDragOver);
                        elm.removeEventListener("dragenter", onDragEnter);
                        elm.removeEventListener("dragleave", onDragLeave);
                    });
                }
            };
        }
    }, {} ],
    137: [ function(require, module, exports) {
        "use strict";
        module.exports = buildModule;
        function buildModule(moduleName) {
            var mod = angular.module(moduleName || "drag-and-drop", []);
            mod.directive("drag", require("./drag-directive"));
            mod.directive("drop", require("./drop-directive"));
            mod.directive("dragCover", require("./drag-cover-directive"));
            mod.directive("dragit", require("./dragit-directive"));
            mod.directive("dropit", require("./dropit-directive"));
            mod.factory("dragAndDrop", require("./drag-and-drop"));
            return mod;
        }
    }, {
        "./drag-and-drop": 131,
        "./drag-cover-directive": 132,
        "./drag-directive": 133,
        "./dragit-directive": 134,
        "./drop-directive": 135,
        "./dropit-directive": 136
    } ],
    138: [ function(require, module, exports) {
        "use strict";
        ApplyFilterHandler.$inject = [ "Shoji", "bus", "lodash" ];
        module.exports = ApplyFilterHandler;
        function ApplyFilterHandler(Shoji, bus, _) {
            function handle(command) {
                return function(dataset) {
                    return dataset.urls.applied_filters.map(function(applied) {
                        var entities = applied.value.groups[0].entities;
                        entities.push(command.filterId);
                        entities = _.uniq(entities);
                        return applied.update({
                            data: {
                                element: "shoji:view",
                                value: {
                                    groups: [ {
                                        entities: entities,
                                        group: "default"
                                    } ]
                                }
                            }
                        }).then(function() {
                            return {
                                event: "filter.applied",
                                filterIds: entities,
                                datasetId: dataset.id
                            };
                        });
                    });
                };
            }
            return function execute(command) {
                return Shoji(command.id).map().then(handle(command)).then(bus.publish);
            };
        }
    }, {} ],
    139: [ function(require, module, exports) {
        "use strict";
        module.exports = BaseExpressionBuilderProvider;
        BaseExpressionBuilderProvider.$inject = [ "machina", "lodash", "iResourceVariable" ];
        function BaseExpressionBuilderProvider(machina, _, iResourceVariable) {
            var BaseExpressionBuilder = machina.Fsm.extend({
                expType: "base",
                valueArg: "column",
                pickerItems: [ {
                    item: "is any of"
                }, {
                    item: "is not any of"
                } ],
                initialize: function(isExclusion) {
                    this.isExclusion = isExclusion;
                    this.hasSource = false;
                    this.categories = {};
                    this.name = null;
                    this.pickerOption = this.pickerItems[0]["item"];
                },
                prepareCategories: function(variable) {
                    var self = this;
                    var result = {};
                    var params = {
                        ignore_filter: true,
                        exclude_exclusion_filter: !!this.isExclusion
                    };
                    return variable.urls.frequencies.map({
                        params: params
                    }).then(function(freqs) {
                        var viewmodel = _.map(freqs.value, function(cat, idx) {
                            var catId = cat.id;
                            if (_.isObject(catId)) {
                                catId = "?" + catId["?"];
                            }
                            return {
                                name: cat.name || cat.value,
                                value: cat.value,
                                missing: cat.missing,
                                index: idx,
                                count: cat.count,
                                id: catId,
                                entryId: cat.id,
                                isSelected: false,
                                toggleSelection: function() {
                                    this.isSelected = !this.isSelected;
                                }
                            };
                        });
                        _.each(viewmodel, function(item) {
                            result[item.id] = item;
                        });
                        self.categories = result;
                        self.orderedCategories = _.sortBy(self.categories, "index");
                        return self.categories;
                    });
                },
                primeCard: function() {
                    if (this.hasSource) {
                        this.isPrimed = true;
                    }
                },
                activate: function() {
                    this.isActive = true;
                },
                deactivate: function() {
                    if (this.isPrimed) {
                        this.isActive = false;
                    }
                },
                negateExpression: function(value) {
                    this.negated = value !== "is any of";
                    this.updateCases();
                },
                _sourceQuery: function(q) {
                    var self = this;
                    return iResourceVariable(q).then(function(r) {
                        self._sourceVariable(r);
                    });
                },
                _sourceVariable: function(variable) {
                    this.name = variable.name;
                    this.id = variable.id;
                    this.variable = variable;
                    this.hasSource = true;
                    this.negated = false;
                    this.selectedRows = 0;
                    return this.prepareCategories(variable);
                },
                source: function(variableOrQuery) {
                    if (variableOrQuery.datasetId && variableOrQuery.variableId) {
                        return this._sourceQuery(variableOrQuery);
                    } else {
                        return this._sourceVariable(variableOrQuery);
                    }
                },
                updateCases: function() {
                    var self = this;
                    var total = 0;
                    this.selectedRows = 0;
                    _.each(this.categories, function(cat) {
                        if (cat.isSelected) {
                            self.selectedRows += cat.count;
                        }
                        total += cat.count;
                    });
                    if (this.negated) {
                        this.selectedRows = total - this.selectedRows;
                    }
                },
                selectedCategories: function() {
                    return _.filter(this.categories, function(c) {
                        return c.isSelected;
                    });
                },
                toggleCategorySelection: function(catId) {
                    this.categories[catId] && this.categories[catId].toggleSelection();
                    this.updateCases();
                },
                deselectAll: function() {
                    _.each(this.categories, function(cat) {
                        cat.isSelected = false;
                    });
                    this.updateCases();
                },
                selectAll: function() {
                    _.each(this.categories, function(cat) {
                        cat.isSelected = true;
                    });
                    this.updateCases();
                },
                variableUrl: function(variablePrefix, variableSuffix) {
                    return (variablePrefix || "") + this.id + (variableSuffix || "");
                },
                build: function(variablePrefix, variableSuffix) {
                    if (!this.hasSource) {
                        return null;
                    }
                    var cats = _(this.categories).filter(function(it) {
                        return it.isSelected;
                    }).map(function(cat) {
                        return cat.id;
                    }).value();
                    var varUrl = this.variableUrl(variablePrefix, variableSuffix);
                    var r = {
                        "function": "in",
                        args: [ {
                            variable: varUrl
                        }, {
                            column: cats,
                            type: {
                                "function": "typeof",
                                args: [ {
                                    variable: varUrl
                                } ]
                            }
                        } ]
                    };
                    if (this.negated) {
                        r = {
                            "function": "not",
                            args: [ r ]
                        };
                    }
                    return r;
                },
                extractVariableId: function(varUrl) {
                    var split = varUrl.split("/");
                    if (split.length === 1) {
                        return split;
                    }
                    if (split[split.length - 1] === "") {
                        return split[split.length - 2];
                    }
                    return split[split.length - 1];
                },
                decompile: function(fVar) {
                    var self = this;
                    this.negated = fVar["function"] === "not";
                    if (this.negated) {
                        fVar = fVar["args"][0];
                        this.pickerOption = "is not any of";
                    } else {
                        this.pickerOption = "is any of";
                    }
                    var variable;
                    var value;
                    _.each(fVar.args, function(arg) {
                        if (arg.column !== undefined) {
                            value = arg.column;
                        }
                        if (arg.variable !== undefined) {
                            variable = arg.variable;
                        }
                    });
                    this.id = this.extractVariableId(variable);
                    _.each(value, function(catId) {
                        if (_.isObject(catId)) {
                            catId = "?" + catId["?"];
                        }
                        self.toggleCategorySelection(catId);
                    });
                    this.updateCases();
                    return this;
                }
            });
            return BaseExpressionBuilder;
        }
    }, {} ],
    140: [ function(require, module, exports) {
        module.exports = CategoricalExpressionBuilderProvider;
        CategoricalExpressionBuilderProvider.$inject = [ "BaseExpressionBuilder" ];
        function CategoricalExpressionBuilderProvider(BaseExpressionBuilder) {
            var CategoricalExpressionBuilder = BaseExpressionBuilder.extend({
                expType: "categorical"
            });
            CategoricalExpressionBuilder.create = function(isExclusion) {
                var builder = new CategoricalExpressionBuilder(isExclusion);
                return builder;
            };
            return CategoricalExpressionBuilder;
        }
    }, {} ],
    141: [ function(require, module, exports) {
        module.exports = DatetimeExpressionBuilderProvider;
        DatetimeExpressionBuilderProvider.$inject = [ "BaseExpressionBuilder", "lodash" ];
        function DatetimeExpressionBuilderProvider(BaseExpressionBuilder, _) {
            var DatetimeExpressionBuilder = BaseExpressionBuilder.extend({});
            DatetimeExpressionBuilder.create = function(isExclusion) {
                var builder = new DatetimeExpressionBuilder(isExclusion);
                return builder;
            };
            return DatetimeExpressionBuilder;
        }
    }, {} ],
    142: [ function(require, module, exports) {
        module.exports = EditFilterHandler;
        EditFilterHandler.$inject = [ "Shoji", "bus", "filterCompiler" ];
        function EditFilterHandler(Shoji, bus, filterCompiler) {
            function write(command) {
                return function(filter) {
                    var data = {
                        expression: filterCompiler(command.expressions, command.junctions)
                    };
                    data.name = command.name;
                    data.is_public = command.isPublic;
                    return filter.update({
                        data: data
                    });
                };
            }
            function raiseEvent(editedFilter) {
                return editedFilter.map(function(nf) {
                    return bus.publish({
                        event: "filter.edited",
                        id: nf.self,
                        name: nf.name,
                        filterId: nf.self
                    });
                });
            }
            return function handle(command) {
                return Shoji(command.id).map().then(write(command)).then(raiseEvent);
            };
        }
    }, {} ],
    143: [ function(require, module, exports) {
        "use strict";
        module.exports = EligibleVariableCtrl;
        EligibleVariableCtrl.$inject = [ "$rootScope", "$scope", "Shoji" ];
        function EligibleVariableCtrl($rootScope, $scope, Shoji) {
            this.selectVariable = $scope.selectVariable = function($event, variableProjection) {
                $rootScope.$broadcast("eligibleVariable.selected", variableProjection);
            };
            this.init = function() {
                if ($scope.variable && $scope.variable.type == "categorical_array") {
                    $scope.variable.hint = "Expand to filter using ";
                }
            };
        }
    }, {} ],
    144: [ function(require, module, exports) {
        var expressionCompiler = require("./filter-expression-compiler");
        module.exports = function() {
            "use strict";
            function EvalFilterFactory() {
                function evaluate(dataset, args) {
                    args = args || {};
                    var expressions = args.expressions || [];
                    var junctions = args.junctions || [];
                    function _eval(expressions, ds) {
                        var q = {
                            params: {
                                filter_syntax: {
                                    expression: expressionCompiler()(expressions, junctions)
                                },
                                exclude_applied: true,
                                exclude_exclusion_filter: args.excludeExclusions || false
                            },
                            cache: false
                        };
                        return ds.urls.summary.map(q, function(summ) {
                            var result = summ.value.rows;
                            return result;
                        });
                    }
                    return _eval(expressions, dataset);
                }
                return evaluate;
            }
            EvalFilterFactory.$inject = [];
            return EvalFilterFactory;
        }.call(this);
    }, {
        "./filter-expression-compiler": 149
    } ],
    145: [ function(require, module, exports) {
        module.exports = function() {
            "use strict";
            function ExpressionBuilderFactory(categoricalExpressionBuilder, numericExpressionBuilder, textExpressionBuilder, multipleResponseExpressionBuilder, datetimeExpressionBuilder) {
                return {
                    categorical: categoricalExpressionBuilder.create,
                    numeric: numericExpressionBuilder.create,
                    text: numericExpressionBuilder.create,
                    multiple_response: multipleResponseExpressionBuilder.create,
                    datetime: datetimeExpressionBuilder.create
                };
            }
            ExpressionBuilderFactory.$inject = [ "categoricalExpressionBuilder", "numericExpressionBuilder", "textExpressionBuilder", "multipleResponseExpressionBuilder", "datetimeExpressionBuilder" ];
            return ExpressionBuilderFactory;
        }.call(this);
    }, {} ],
    146: [ function(require, module, exports) {
        "use strict";
        module.exports = ExpressionFactory;
        ExpressionFactory.$inject = [];
        function ExpressionFactory() {
            return {
                primeCard: function() {
                    if (this.hasSource) {
                        this.isPrimed = true;
                    }
                },
                activate: function() {
                    this.isActive = true;
                },
                deactivate: function() {
                    if (this.isPrimed) {
                        this.isActive = false;
                    }
                },
                negateExpression: function(value) {
                    this.negated = value !== "is any of";
                    this.updateCases();
                },
                updateCases: function() {}
            };
        }
    }, {} ],
    147: [ function(require, module, exports) {
        "use strict";
        module.exports = FilterBuilderDirective;
        FilterBuilderDirective.$inject = [ "$state", "$compile", "$templateCache", "FilterBuilder", "currentDataset", "ShareFilter" ];
        function FilterBuilderDirective($state, $compile, $templateCache, FilterBuilder, currentDataset, ShareFilter) {
            return {
                restrict: "EA",
                replace: true,
                scope: {
                    builder: "=",
                    share: "="
                },
                link: function(scope, el, attrs) {
                    scope.$watch("builder", function() {
                        if (scope.builder) {
                            scope.filterBuilder = scope.builder;
                            scope.shareFilter = scope.share;
                            scope.filterName = scope.builder.filter.name;
                            scope.filterBuilder.thisScope = scope;
                        }
                    });
                    scope.junctionOptions = [ {
                        item: "AND"
                    }, {
                        item: "OR"
                    } ];
                    scope.$watch("filterName", function(name) {
                        if (scope.filterBuilder) {
                            scope.filterBuilder.setFilterName(name);
                        }
                    });
                    scope.$watch("filterBuilder.filterName()", function(filterName) {
                        scope.filterName = filterName;
                    });
                    attrs.$observe("filterBuilder", function(filterBuilder) {
                        var tpl = "/filter-builder/filter-builder";
                        tpl += filterBuilder.indexOf("readonly") >= 0 ? "-readonly.html" : ".html";
                        el.append($compile($templateCache.get(tpl))(scope));
                    });
                }
            };
        }
    }, {} ],
    148: [ function(require, module, exports) {
        "use strict";
        module.exports = FilterBuilderFactory;
        FilterBuilderFactory.$inject = [ "machina", "lodash", "Filter", "evalFilter", "bus" ];
        function FilterBuilderFactory(Machina, _, Filter, evalFilter, bus) {
            function assertDataset(params) {
                if (!_.isObject(params.dataset)) {
                    throw new Error("please provide a valid dataset object");
                }
            }
            var FilterBuilder = Machina.Fsm.extend({
                initialState: "uninitialized",
                $events: [ "eligibleVariable.selected:link", "variable.clicked" ],
                setFilterName: function(name) {
                    this.filter.name = name;
                    bus.publish({
                        event: "expression.changed"
                    });
                },
                addExpression: function(variable) {
                    var expressions = this.filter.addExpression(this.dataset, variable);
                    expressions.forEach(this.decorateWithFilterEvaluation.bind(this));
                    this.evaluateFilter();
                    this.emit("expression.added");
                },
                junctionChanged: function(junctionIndex, junctionValue) {
                    this.filter.junctions[junctionIndex] = junctionValue;
                    this.emit("expression.changed");
                },
                decorateWithFilterEvaluation: function(expression) {
                    var operationsThatRequiresEvaluation = [ "toggleCategorySelection", "selectAll", "deselectAll", "negateExpression", "setExpression" ], evaluateFilter = this.evaluateFilter.bind(this), emit = this.emit.bind(this);
                    operationsThatRequiresEvaluation.forEach(function(op) {
                        var opFn = expression[op];
                        if (_.isFunction(opFn)) {
                            expression[op] = _.wrap(opFn, function(opFn) {
                                opFn.apply(this, Array.prototype.slice.call(arguments, 1));
                                evaluateFilter();
                                emit("expression.changed");
                                bus.publish({
                                    event: "expression.changed"
                                });
                            });
                        }
                    });
                },
                deleteExpression: function(atIndex) {
                    var filter = this.filter, target = filter.expressions[atIndex];
                    filter.expressions.splice(atIndex, 1);
                    this.evaluateFilter();
                    this.emit("expression.changed");
                    this.emit("expression.removed");
                },
                evaluateFilter: function() {
                    var args = {
                        expressions: this.filter.expressionsWithSource(),
                        junctions: this.filter.junctions,
                        datasetId: this.dataset.self,
                        excludeExclusions: this.exclusionMode
                    };
                    return evalFilter(this.dataset, args).then(function(stats) {
                        this.stats = stats;
                    }.bind(this));
                },
                filterExpressions: function() {
                    return this.filter.expressions;
                },
                expressionsCount: function() {
                    return this.filterExpressions().length;
                },
                hasVariables: function() {
                    return this.expressionsCount() > 0;
                },
                hasExpressions: function() {
                    var i;
                    if (this.expressionsCount() > 0) {
                        for (i = 0; i < this.filter.expressions.length; i++) {
                            if (this.filter.expressions[i] && this.filter.expressions[i].selectedCategories().length > 0) {
                                return true;
                            }
                        }
                    }
                    return false;
                },
                junctionsCount: function() {
                    return this.filter.junctions.length;
                },
                isCreatable: function() {
                    return this.isNamed() && this.hasExpressions();
                },
                isNamed: function() {
                    return _.isString(this.filter.name) && this.filter.name.length > 0;
                },
                filterName: function() {
                    return this.filter.name;
                },
                replace: function(builder) {
                    this.thisScope.filterBuilder = builder;
                    builder.thisScope = this.thisScope;
                },
                stat: function(statName) {
                    return this.stats[statName];
                },
                getFilter: function() {
                    return this.filter.getMemento();
                },
                destroy: function() {
                    this.oldEventListeners = this.eventListeners;
                    return this.transition("destroyed");
                },
                revive: function() {
                    this.eventListeners = this.oldEventListeners;
                    return this.transition("revived");
                },
                headerClicked: function(event) {},
                states: {
                    uninitialized: {
                        initialize: function(params) {
                            assertDataset(params);
                            this.filter = new Filter(params.filter);
                            this.stats = {
                                filtered: 0,
                                total: 0
                            };
                            this.dataset = params.dataset;
                            if (_.isString(params.defaultName)) {
                                this.filter.name = params.defaultName;
                            }
                            if (_.isBoolean(params.exclusionMode)) {
                                this.exclusionMode = params.exclusionMode;
                            }
                            this.filter.expressions.forEach(this.decorateWithFilterEvaluation.bind(this));
                            this.evaluateFilter().then(function() {
                                this.transition("initialized");
                            }.bind(this));
                        }
                    },
                    initialized: {
                        "eligibleVariable.selected:link": function(e, variable) {
                            this.addExpression(variable);
                        },
                        "variable.clicked": function(e, args) {
                            if (args.behaviors && args.behaviors.clickable === false) {
                                return;
                            }
                            this.addExpression(args.variable);
                        },
                        deleteExpression: function(expressionIndex) {
                            this.deleteExpression(expressionIndex);
                        }
                    },
                    destroyed: {
                        _onEnter: function() {
                            this.off();
                        },
                        revived: function() {}
                    },
                    revived: {
                        _onEnter: function() {
                            this.transition("initialized");
                        }
                    }
                }
            });
            return {
                create: function(params) {
                    var builder = new FilterBuilder();
                    builder.handle("initialize", params || {});
                    return builder;
                }
            };
        }
    }, {} ],
    149: [ function(require, module, exports) {
        var _ = require("lodash");
        module.exports = function() {
            "use strict";
            return FilterCompiler;
            function FilterCompiler() {
                function compile(expressions, junctions, variablePrefix, variableSuffix) {
                    junctions = junctions || [];
                    expressions = expressions || [];
                    var varPrefix = variablePrefix;
                    var varSuffix = variableSuffix;
                    expressions = _(expressions).map(function(exp) {
                        return exp.build(varPrefix, varSuffix);
                    }).reverse().value();
                    var expression = null;
                    while (expression === null && expression !== undefined) {
                        expression = expressions[0];
                        expressions = expressions.slice(1, expressions.length);
                    }
                    if (expression === undefined) {
                        return {};
                    }
                    var i = 0;
                    for (i = 0; i < expressions.length; i++) {
                        var operator = junctions[i];
                        var factor = expressions[i];
                        if (factor === null) {
                            continue;
                        }
                        expression = {
                            "function": operator,
                            args: [ factor, expression ]
                        };
                    }
                    return expression;
                }
                return compile;
            }
        }.call(this);
    }, {
        lodash: 77
    } ],
    150: [ function(require, module, exports) {
        "use strict";
        module.exports = FilterDecompilerFactory;
        FilterDecompilerFactory.$inject = [ "lodash", "expressionBuilders", "$q", "iResourceVariable" ];
        function FilterDecompilerFactory(_, expressionBuilders, $q, iResourceVariable) {
            function baseFilter(compiledFilter) {
                var filter = {
                    name: compiledFilter.name,
                    self: compiledFilter.self,
                    expressions: [],
                    junctions: compiledFilter.functions,
                    original: compiledFilter
                };
                if (compiledFilter.index !== undefined) {
                    filter.index = compiledFilter.index;
                }
                return filter;
            }
            function hiddenExpression(name) {
                var hexp = expressionBuilders.categorical();
                hexp.isHidden = true;
                hexp.name = name;
                return hexp;
            }
            function getVarFromExpression(expression) {
                if (expression.function && expression.function === "not") {
                    return getVarFromExpression(expression.args[0]);
                }
                var i;
                var args = expression.args;
                for (i = 0; i < args.length; i++) {
                    var arg = args[i];
                    if (arg && arg.hasOwnProperty("variable")) {
                        return extractVariableId(arg.variable);
                    }
                }
            }
            function decompileVariable(dataset, allVars, isExclusion) {
                var varUrl = dataset.urls.variables.self || dataset.urls.variables;
                varUrl = varUrl.split("?")[0];
                return function(fVar) {
                    var variable = varUrl + getVarFromExpression(fVar) + "/";
                    var dsVar = allVars.value[variable];
                    if (!dsVar) {
                        return hiddenExpression(fVar.args.variable);
                    } else {
                        var exp = expressionBuilders[dsVar.type](isExclusion);
                        return exp.source(dsVar).then(function() {
                            return exp.decompile(fVar);
                        });
                    }
                };
            }
            function flattenExpression(expression) {
                var junctions = [];
                var expressions = [];
                if (expression === undefined) {
                    return {
                        junctions: [],
                        expressions: []
                    };
                }
                if (expression.function && (expression.function.toUpperCase() === "AND" || expression.function.toUpperCase() === "OR")) {
                    junctions.push(expression.function);
                    var items = [];
                    _.each(expression.args, function(item) {
                        var flat = flattenExpression(item);
                        expressions.push.apply(expressions, flat.expressions);
                        junctions.push.apply(junctions, flat.junctions);
                    });
                } else {
                    expressions.push(expression);
                }
                return {
                    junctions: junctions,
                    expressions: expressions
                };
            }
            function flattenFilter(filter) {
                var flat = flattenExpression(filter.original.expression);
                filter.expressions = flat.expressions;
                filter.junctions = flat.junctions;
            }
            function buildExpressions(dataset, filter, isExclusion) {
                flattenFilter(filter);
                return function(allVars) {
                    var exps = _.map(filter.expressions, decompileVariable(dataset, allVarsById(allVars), isExclusion));
                    return $q.all(exps).then(function(results) {
                        filter.expressions = results;
                        return filter;
                    });
                };
            }
            function allVarsById(vars) {
                var result = {};
                _.each(vars, function(varb) {
                    result[varb.self] = varb;
                });
                return {
                    value: result
                };
            }
            function extractVariableId(varUrl) {
                var split = varUrl.split("/");
                if (split.length === 1) {
                    return split;
                }
                if (split[split.length - 1] === "") {
                    return split[split.length - 2];
                }
                return split[split.length - 1];
            }
            function extractVariableIds(dataset, expr) {
                var vars = [];
                var varUrl = dataset.urls.variables.self || dataset.urls.variables;
                varUrl = varUrl.split("?")[0];
                if (expr === undefined) {
                    return [];
                }
                if (expr && expr.hasOwnProperty("variable")) {
                    var variable = varUrl + extractVariableId(expr.variable) + "/";
                    if (variable && vars.indexOf(variable) === -1) {
                        vars.push(variable);
                    }
                }
                if (expr.args) {
                    var i;
                    for (i = 0; i < expr.args.length; i++) {
                        var expr_vars = extractVariableIds(dataset, expr.args[i]);
                        var j;
                        for (j = 0; j < expr_vars.length; j++) {
                            var variable = expr_vars[j];
                            if (variable && vars.indexOf(variable) == -1) {
                                vars.push(variable);
                            }
                        }
                    }
                }
                return vars;
            }
            function fetchTheseVars(varIds, datasetId) {
                return $q.all(_.map(varIds, function(varId) {
                    return iResourceVariable({
                        datasetId: datasetId,
                        variableId: varId
                    });
                }));
            }
            return function decompile(compiledFilter, dataset, isExclusion) {
                var filter = baseFilter(compiledFilter);
                var variableIds = extractVariableIds(dataset, compiledFilter.expression);
                var allVars = fetchTheseVars(variableIds, dataset.self.split("?")[0]);
                return allVars.then(buildExpressions(dataset, filter, isExclusion));
            };
        }
    }, {} ],
    151: [ function(require, module, exports) {
        "use strict";
        module.exports = FilterFactory;
        FilterFactory.$inject = [ "lodash", "expressionBuilders", "filterCompiler" ];
        function FilterFactory(_, expressionBuilders, filterCompiler) {
            var filterDefaults = {
                name: "",
                isPublic: false,
                expressions: [],
                junctions: []
            }, AND_JUNCTION = "AND";
            function expressionOrError(expressionType) {
                var exp = expressionBuilders[expressionType];
                if (!exp) {
                    throw new Error("variable type " + expressionType + " is not supported");
                }
                return exp();
            }
            function Filter(filter) {
                var memento = _.isObject(filter) ? _.clone(filter) : _.cloneDeep(filterDefaults);
                _.extend(this, memento);
            }
            Filter.prototype.addExpression = function(dataset, varb) {
                var expression, expressions = [];
                if (!varb.type) {
                    varb = varb.droppedData || varb.dragged.data || varb;
                }
                if (varb.type === undefined) {
                    return [];
                }
                if (varb.categoricalArray) {
                    varb.getSubvariables().then(function(subvariables) {
                        subvariables.forEach(function(sub) {
                            expressions.push(this.addExpression(dataset, sub));
                        }.bind(this));
                    }.bind(this));
                } else {
                    expression = expressionOrError(varb.type);
                    this.junctions.push(AND_JUNCTION);
                    this.expressions.push(expression);
                    expression.isActive = true;
                    expression.source({
                        datasetId: dataset.self,
                        variableId: varb.self
                    });
                    expressions.push(expression);
                }
                return expressions;
            };
            Filter.prototype.expressionsWithSource = function() {
                return this.expressions.filter(function(exp) {
                    return exp.hasSource;
                });
            };
            Filter.prototype.lastExpression = function() {
                var lastIndex = this.expressions.length - 1;
                return this.expressions[lastIndex];
            };
            Filter.prototype.hiddenExpressions = function() {
                return this.expressions.filter(function(exp) {
                    return exp.isHidden === true;
                });
            };
            Filter.prototype.getMemento = function() {
                return _.pick(this, "name", "isPublic", "expressions", "junctions", "self");
            };
            Filter.prototype.expToString = function(exp) {
                var built = exp && exp.build && exp.build();
                if (built === undefined) {
                    return exp && exp.name;
                }
                var categories = [];
                var i;
                var columns;
                _.each(built.args, function(arg) {
                    if (arg.column) {
                        columns = arg.column;
                    }
                    if (arg.value) {
                        columns = arg.value;
                    }
                });
                for (i = 0; i < columns.length; i++) {
                    var category_name = columns[i];
                    if (category_name["?"] !== undefined) {
                        category_name = "?" + category_name["?"];
                    }
                    var name = exp.categories[category_name].name;
                    if (name !== undefined) {
                        categories.push(name);
                    }
                }
                var func = built.function;
                if (func == "in") {
                    func = "is";
                }
                if (func == "any") {
                    func = "is";
                }
                var cats = categories.join(" or ");
                if (categories.length > 2) {
                    cats = categories.slice(0, categories.length - 1).join(", ");
                    cats += " or " + categories[categories.length - 1];
                }
                return exp.name + " " + func + " " + cats;
            };
            Filter.prototype.toString = function() {
                var expressions = this.expressions;
                if (expressions.length == 0) {
                    return "";
                }
                var i;
                var s = "";
                var junctions = this.junctions;
                s += this.expToString(expressions[0]);
                for (i = 1; i < junctions.length + 1; i++) {
                    if (expressions[i] !== undefined) {
                        var junction = junctions[i - 1];
                        if (junction !== undefined) {
                            s += " " + junction + " ";
                        }
                        s += this.expToString(expressions[i]);
                    }
                }
                return s;
            };
            Filter.prototype.compile = function(variablePrefix, variableSuffix) {
                return filterCompiler(this.expressions, this.junctions, variablePrefix, variableSuffix);
            };
            return Filter;
        }
    }, {} ],
    152: [ function(require, module, exports) {
        module.exports = function() {
            "use strict";
            var angular = require("angular"), _ = require("lodash");
            function buildModule(moduleName) {
                var mod = angular.module(moduleName || "filters", []);
                mod.factory("lodash", function() {
                    return _;
                });
                mod.controller("eligibleVariable", require("./eligible-variable-ctrl"));
                mod.factory("applyFilterHandler", require("./apply-filter-handler"));
                mod.factory("removeFilterHandler", require("./remove-filter-handler"));
                mod.factory("replaceFilterHandler", require("./replace-filter-handler"));
                mod.factory("editFilterHandler", require("./edit-filter-handler"));
                mod.factory("expressionBuilders", require("./expression-builder-factory"));
                mod.factory("evalFilter", require("./eval-filter-factory"));
                mod.factory("filterCompiler", require("./filter-expression-compiler"));
                mod.factory("filterDecompiler", require("./filter-expression-decompiler"));
                mod.factory("BaseExpressionBuilder", require("./base-expression-builder"));
                mod.factory("expression", require("./expression"));
                mod.factory("categoricalExpressionBuilder", require("./categorical-expression-builder"));
                mod.factory("numericExpressionBuilder", require("./numerical-expression-builder"));
                mod.factory("textExpressionBuilder", require("./text-expression-builder"));
                mod.factory("multipleResponseExpressionBuilder", require("./multiple-response-expression-builder"));
                mod.factory("datetimeExpressionBuilder", require("./datetime-expression-builder"));
                mod.factory("ShareFilter", require("./share-filter"));
                mod.factory("FilterBuilder", require("./filter-builder"));
                mod.factory("Filter", require("./filter"));
                mod.directive("filterBuilder", require("./filter-builder-directive"));
                mod.directive("shareFilter", require("./share-filter-directive"));
                return mod;
            }
            return buildModule;
        }.call(this);
    }, {
        "./apply-filter-handler": 138,
        "./base-expression-builder": 139,
        "./categorical-expression-builder": 140,
        "./datetime-expression-builder": 141,
        "./edit-filter-handler": 142,
        "./eligible-variable-ctrl": 143,
        "./eval-filter-factory": 144,
        "./expression": 146,
        "./expression-builder-factory": 145,
        "./filter": 151,
        "./filter-builder": 148,
        "./filter-builder-directive": 147,
        "./filter-expression-compiler": 149,
        "./filter-expression-decompiler": 150,
        "./multiple-response-expression-builder": 153,
        "./numerical-expression-builder": 154,
        "./remove-filter-handler": 155,
        "./replace-filter-handler": 156,
        "./share-filter": 158,
        "./share-filter-directive": 157,
        "./text-expression-builder": 159,
        angular: "angular",
        lodash: 77
    } ],
    153: [ function(require, module, exports) {
        module.exports = MultipleResponseExpressionBuilderProvider;
        MultipleResponseExpressionBuilderProvider.$inject = [ "BaseExpressionBuilder", "lodash" ];
        function MultipleResponseExpressionBuilderProvider(BaseExpressionBuilder, _) {
            var MultipleResponseExpressionBuilder = BaseExpressionBuilder.extend({
                expType: "multiple response",
                functionMap: {
                    "is any of": "any",
                    "is all of": "all",
                    "is not any of": "any",
                    "is not all of": "all"
                },
                functionReverseMap: {
                    any: "is any of",
                    all: "is all of",
                    "not any": "is not any of",
                    "not all": "is not all of"
                },
                pickerItems: [ {
                    item: "is any of"
                }, {
                    item: "is all of"
                }, {
                    item: "is not any of"
                }, {
                    item: "is not all of"
                } ],
                build: function(variablePrefix, variableSuffix) {
                    if (!this.hasSource) {
                        return null;
                    }
                    var cats = _(this.categories).filter(function(it) {
                        return it.isSelected;
                    }).map(function(cat) {
                        return cat.id;
                    }).value();
                    var func = this.functionMap[this.pickerOption];
                    var varUrl = this.variableUrl(variablePrefix, variableSuffix);
                    this.negated = this.pickerOption.indexOf("is not") != -1;
                    var r = {
                        "function": func,
                        args: [ {
                            variable: varUrl
                        }, {
                            column: cats
                        } ]
                    };
                    if (this.negated) {
                        r = {
                            "function": "not",
                            args: [ r ]
                        };
                    }
                    return r;
                },
                decompile: function(fVar) {
                    var self = this;
                    this.negated = fVar["function"] === "not";
                    if (this.negated) {
                        fVar = fVar["args"][0];
                        this.pickerOption = this.functionReverseMap["not " + fVar.function];
                    } else {
                        this.pickerOption = this.functionReverseMap[fVar.function];
                    }
                    var variable;
                    var columns;
                    _.each(fVar.args, function(arg) {
                        if (arg.column !== undefined) {
                            columns = arg.column;
                        }
                        if (arg.variable !== undefined) {
                            variable = arg.variable;
                        }
                    });
                    this.id = variable;
                    _.each(columns, function(catId) {
                        self.toggleCategorySelection(catId);
                    });
                    this.updateCases();
                    return this;
                },
                negateExpression: function(value) {
                    self.pickerOption = functionMap[value] || "is any of";
                    self.updateCases();
                }
            });
            MultipleResponseExpressionBuilder.create = function(isExclusion) {
                var builder = new MultipleResponseExpressionBuilder(isExclusion);
                return builder;
            };
            return MultipleResponseExpressionBuilder;
        }
    }, {} ],
    154: [ function(require, module, exports) {
        module.exports = NumericExpressionBuilderProvider;
        NumericExpressionBuilderProvider.$inject = [ "BaseExpressionBuilder" ];
        function NumericExpressionBuilderProvider(BaseExpressionBuilder) {
            var NumericExpressionBuilder = BaseExpressionBuilder.extend({
                expType: "numeric",
                valueArg: "value"
            });
            NumericExpressionBuilder.create = function(isExclusion) {
                var builder = new NumericExpressionBuilder(isExclusion);
                return builder;
            };
            return NumericExpressionBuilder;
        }
    }, {} ],
    155: [ function(require, module, exports) {
        "use strict";
        module.exports = RemoveFilterHandler;
        RemoveFilterHandler.$inject = [ "Shoji", "bus", "lodash" ];
        function RemoveFilterHandler(Shoji, bus, _) {
            function handle(command) {
                return function(dataset) {
                    return dataset.urls.applied_filters.map(function(applied) {
                        var appliedFilters = applied.value.groups[0].entities;
                        var existing = appliedFilters.filter(function(k) {
                            return k !== command.filterId;
                        });
                        return applied.update({
                            data: {
                                element: "shoji:view",
                                value: {
                                    groups: [ {
                                        entities: existing,
                                        group: "default"
                                    } ]
                                }
                            }
                        }).then(function() {
                            return {
                                event: "filter.removed",
                                filterIds: existing,
                                datasetId: dataset.id
                            };
                        });
                    });
                };
            }
            return function execute(command) {
                return Shoji(command.id).map().then(handle(command)).then(bus.publish);
            };
        }
    }, {} ],
    156: [ function(require, module, exports) {
        "use strict";
        ReplaceFilterHandler.$inject = [ "Shoji", "bus", "lodash" ];
        module.exports = ReplaceFilterHandler;
        function ReplaceFilterHandler(Shoji, bus, _) {
            function handle(command) {
                return function(dataset) {
                    return dataset.urls.applied_filters.map(function(applied) {
                        var appliedFilterIds = applied.value.groups[0].entities;
                        var i = appliedFilterIds.indexOf(command.previousFilterId);
                        if (i !== -1) {
                            var j = appliedFilterIds.indexOf(command.filterId);
                            if (j !== -1) {
                                appliedFilterIds.splice(i, 1);
                            } else {
                                appliedFilterIds[i] = command.filterId;
                            }
                        } else if (i === -1) {
                            appliedFilterIds.push(command.filterId);
                        }
                        appliedFilterIds = _.uniq(appliedFilterIds);
                        return applied.update({
                            data: {
                                element: "shoji:view",
                                value: {
                                    groups: [ {
                                        entities: appliedFilterIds,
                                        group: "default"
                                    } ]
                                }
                            }
                        }).then(function() {
                            return {
                                event: "filter.replaced",
                                filterIds: appliedFilterIds,
                                datasetId: dataset.id,
                                previousFilterId: command.previousFilterId,
                                filterId: command.filterId
                            };
                        });
                    });
                };
            }
            return function execute(command) {
                return Shoji(command.id).map().then(handle(command)).then(bus.publish);
            };
        }
    }, {} ],
    157: [ function(require, module, exports) {
        "use strict";
        module.exports = ShareFilterDirective;
        ShareFilterDirective.$inject = [];
        function ShareFilterDirective() {
            return {
                restrict: "EA",
                replace: true,
                templateUrl: "/filter-builder/share-filter.html"
            };
        }
    }, {} ],
    158: [ function(require, module, exports) {
        "use strict";
        module.exports = ShareFilterFactory;
        ShareFilterFactory.$inject = [ "$q", "lodash", "iFetchCurrentUserDatasetPermissions" ];
        function ShareFilterFactory($q, _, iFetchCurrentUserDatasetPermissions) {
            function ShareFilter(share) {
                var currentUser;
                iFetchCurrentUserDatasetPermissions().then(setPermissions.bind(this));
                function setPermissions(datasetPermissions) {
                    this.allowToEdit = datasetPermissions.edit;
                    this.share = _.isBoolean(share) ? share : this.allowToEdit;
                }
            }
            return {
                create: function(params) {
                    params = params || {};
                    return new ShareFilter(params.share);
                }
            };
        }
    }, {} ],
    159: [ function(require, module, exports) {
        module.exports = TextExpressionBuilderProvider;
        TextExpressionBuilderProvider.$inject = [ "BaseExpressionBuilder" ];
        function TextExpressionBuilderProvider(BaseExpressionBuilder) {
            var TextExpressionBuilder = BaseExpressionBuilder.extend({
                expType: "text"
            });
            TextExpressionBuilder.create = function(isExclusion) {
                var builder = new TextExpressionBuilder(isExclusion);
                return builder;
            };
            return TextExpressionBuilder;
        }
    }, {} ],
    160: [ function(require, module, exports) {
        "use strict";
        module.exports = HierarchicalBehaviorsFactory;
        HierarchicalBehaviorsFactory.$inject = [ "$log" ];
        function HierarchicalBehaviorsFactory($log) {
            var defaultOpts = {
                clickable: false,
                linkable: false,
                types: []
            };
            function copy(src) {
                var dest = {};
                for (var k in defaultOpts) {
                    dest[k] = src[k] || defaultOpts[k];
                }
                return dest;
            }
            function HierarchicalBehaviors(cfg) {
                cfg = cfg || {};
                this.clickable = cfg.clickable;
                this.linkable = cfg.linkable;
                this.strategy = this.getStrategy(cfg);
                this.handlers = [];
                this.hideSubvariables = cfg.hideSubvariables;
                this.hidePrivateVariables = cfg.hidePrivateVariables;
                this.types = cfg.types || [];
                this.self = cfg.self;
            }
            HierarchicalBehaviors.prototype.getStrategy = function(cfg) {
                return cfg.linkable ? "linkable" : "clickable";
            };
            HierarchicalBehaviors.prototype.isSatisfiedBy = function(item) {
                if (this.self && item.self === this.self) {
                    return false;
                }
                if (item.private && this.hidePrivateVariables) {
                    return false;
                }
                if (!this.types || !this.types.length) {
                    return true;
                }
                if (item.hierarchicalType === "group") {
                    return true;
                }
                if (!item.type) {
                    return false;
                }
                return this.types.indexOf(item.type) > -1;
            };
            HierarchicalBehaviors.prototype.toString = function() {
                return "[" + this.strategy + "]" + this.types.join(",");
            };
            function buildHierarchicalBehaviors(cfg) {
                cfg = cfg || {};
                var clone = copy(cfg);
                return new HierarchicalBehaviors(cfg);
            }
            buildHierarchicalBehaviors.DEFAULT = function() {
                return buildHierarchicalBehaviors();
            };
            return buildHierarchicalBehaviors;
        }
    }, {} ],
    161: [ function(require, module, exports) {
        "use strict";
        module.exports = HierarchicalGroupFactory;
        HierarchicalGroupFactory.$inject = [ "machina", "HierarchicalVariable", "Traversable" ];
        function HierarchicalGroupFactory(machina, HierarchicalVariable, Traversable) {
            var HierarchicalGroupBase = machina.Fsm.extend({
                initialState: "uninitialized",
                namespace: "hierarchicalGroupVariablesList",
                destroy: function() {
                    return this.transition("destroyed");
                },
                _collapseItems: function() {
                    this.items.forEach(function(item) {
                        item.handle("collapse");
                    });
                },
                _store: function(cfg) {
                    var group;
                    cfg = cfg || {};
                    group = cfg.group;
                    this.parent = cfg.parent;
                    this.name = group.name;
                    this.self = group.self;
                    this.private = group.private;
                    this.level = group.level;
                    this.hierarchicalType = group.hierarchicalType;
                    this.group = group;
                    if (cfg.behaviors) {
                        this.behaviors = cfg.behaviors;
                    }
                    if (!group.items) {
                        throw new Error("items are expected");
                    }
                },
                _createChildren: function() {
                    var self = this, orderItems = this.group.items, behaviors = this.behaviors;
                    this.all = this.all || orderItems.filter(function(item) {
                        return !item.discarded && !item.hidden;
                    }).filter(function(item) {
                        return item.items ? item.items.length > 0 : true;
                    }).map(function(item) {
                        var hierarchicalItem;
                        if (item.hierarchicalType === "variable") {
                            hierarchicalItem = HierarchicalVariable.create({
                                variable: item,
                                parent: self,
                                behaviors: behaviors
                            });
                        } else {
                            hierarchicalItem = factory.create({
                                group: item,
                                parent: self,
                                behaviors: behaviors
                            });
                        }
                        return hierarchicalItem;
                    });
                    this.items = this.all.filter(function(item) {
                        return behaviors.isSatisfiedBy(item);
                    });
                    this.retraversable(this, "items");
                },
                applyBehaviors: function(behaviors) {
                    this.behaviors = behaviors;
                    this.items = (this.all || []).filter(function(item) {
                        return behaviors.isSatisfiedBy(item);
                    }).map(function(item) {
                        item.applyBehaviors(behaviors);
                        return item;
                    });
                    return this;
                },
                states: {
                    destroyed: {
                        _onEnter: function() {
                            this.items.forEach(function(varb) {
                                varb.destroy();
                            }, this);
                            this.off();
                        }
                    }
                }
            });
            var HierarchicalGroup = HierarchicalGroupBase.extend({
                initialize: function(cfg) {
                    this.items = [];
                    this._traversable = new Traversable({
                        pageLength: this.threshold || 40,
                        pctOverlap: .5
                    });
                    this._traversable.augment(this, "items");
                },
                states: {
                    uninitialized: {
                        initialize: function(cfg) {
                            this._store(cfg);
                            return this.transition("collapsed");
                        }
                    },
                    collapsed: {
                        toggle: function() {
                            this.handle("expand");
                        },
                        expand: function() {
                            this.transition("expanded");
                            if (this.parent) {
                                this.parent.handle("expand");
                            }
                        },
                        "collapse-items": function() {
                            this._collapseItems();
                        }
                    },
                    expanded: {
                        _onEnter: function() {
                            this._createChildren();
                        },
                        toggle: function() {
                            this.handle("collapse");
                        },
                        collapse: function() {
                            this.transition("collapsed");
                        },
                        "collapse-items": function() {
                            this._collapseItems();
                        }
                    }
                }
            });
            var factory = {
                create: function(cfg) {
                    var group = new HierarchicalGroup(cfg);
                    group.handle("initialize", cfg);
                    return group;
                }
            };
            return factory;
        }
    }, {} ],
    162: [ function(require, module, exports) {
        "use strict";
        module.exports = HierarchicalVariableFactory;
        HierarchicalVariableFactory.$inject = [ "machina", "bus" ];
        function HierarchicalVariableFactory(machina, bus) {
            var factory = {
                create: function(cfg) {
                    var varb;
                    if (cfg.variable.type === "categorical_array" && cfg.variable.subvariables && cfg.variable.subvariables.length) {
                        varb = CompositeVariable.create(cfg);
                    } else {
                        varb = ScalarVariable.create(cfg);
                    }
                    return varb;
                }
            };
            var HierarchicalVariable = machina.Fsm.extend({
                initialState: "uninitialized",
                namespace: "hierarchicalVariablesList",
                destroy: function() {
                    this.transition("destroyed");
                },
                _click: function() {
                    this.emit("clicked", this);
                    bus.publish({
                        event: "variable.clicked",
                        variable: this.data,
                        behaviors: this.behaviors
                    });
                },
                _store: function() {
                    throw new Error("not implemented");
                },
                applyBehaviors: function(behaviors) {
                    this.behaviors = behaviors;
                },
                states: {
                    uninitialized: {
                        initialize: function(cfg) {
                            this._store(cfg);
                            this.transition("initialized");
                        }
                    },
                    initialized: {
                        click: function() {
                            this._click();
                        }
                    },
                    destroyed: {
                        _onEnter: function() {
                            this.off();
                        }
                    }
                }
            });
            var ScalarVariable = HierarchicalVariable.extend({
                _store: function(cfg) {
                    var variable;
                    cfg = cfg || {};
                    variable = cfg.variable;
                    this.self = variable.self;
                    this.name = variable.prunedName;
                    this.type = variable.type;
                    this.alias = variable.alias;
                    this.url = variable.self;
                    this.data = variable;
                    this.parent = cfg.parent;
                    this.private = variable.private;
                    this.level = variable.level;
                    this.behaviors = cfg.behaviors;
                    this.hierarchicalType = variable.hierarchicalType;
                },
                destroy: function() {
                    this.transition("destroyed");
                }
            });
            ScalarVariable.create = function(cfg) {
                var variable = new ScalarVariable();
                variable.handle("initialize", cfg);
                return variable;
            };
            var Expansion = machina.Fsm.extend({
                initialState: "collapsed",
                namespace: "hierarchicalVariablesList",
                subvarsLoaded: false,
                states: {
                    collapsed: {
                        toggle: function() {
                            var self = this, variable = this.variable;
                            if (!this.subvarsLoaded) {
                                variable.data.getSubvariables().then(function(subvariables) {
                                    subvariables.forEach(function(varTuple) {
                                        variable.addSubvariable(varTuple);
                                    });
                                    return this;
                                }).then(function() {
                                    self.subvarsLoaded = true;
                                    self.transition("expanded");
                                }, function() {
                                    throw Error("Unable to fetch subvariables");
                                });
                            } else {
                                this.transition("expanded");
                            }
                        }
                    },
                    expanded: {
                        toggle: function() {
                            this.transition("collapsed");
                        }
                    }
                }
            });
            var CompositeVariable = HierarchicalVariable.extend({
                _store: function(cfg) {
                    var variable;
                    cfg = cfg || {};
                    variable = cfg.variable;
                    this.name = variable.prunedName;
                    this.self = variable.self;
                    this.url = variable.self;
                    this.type = variable.type;
                    this.composite = true;
                    this.alias = variable.alias;
                    this.data = variable;
                    this.parent = cfg.parent;
                    this.level = variable.level;
                    this.subvariables = [];
                    this.behaviors = cfg.behaviors;
                    this.hierarchicalType = variable.hierarchicalType;
                },
                addSubvariable: function(subvariableTuple) {
                    this.subvariables.push(factory.create({
                        variable: subvariableTuple,
                        behaviors: this.behaviors
                    }));
                },
                applyBehaviors: function(behaviors) {
                    this.behaviors = behaviors;
                    this.subvariables.forEach(function(subvariable) {
                        if (subvariable.applyBehaviors) {
                            subvariable.applyBehaviors(behaviors);
                        }
                    });
                },
                initialize: function() {
                    this.expansion = new Expansion({
                        variable: this,
                        subvarsLoaded: false
                    });
                },
                states: {
                    initialized: {
                        click: function() {
                            this._click();
                        }
                    }
                }
            });
            CompositeVariable.create = function(cfg) {
                var variable = new CompositeVariable();
                variable.handle("initialize", cfg);
                return variable;
            };
            return factory;
        }
    }, {} ],
    163: [ function(require, module, exports) {
        "use strict";
        module.exports = HierarchicalVariablesListFactory;
        HierarchicalVariablesListFactory.$inject = [ "assert", "machina", "HierarchicalGroup", "hierarchicalBehaviors", "HierarchicalVariables" ];
        function HierarchicalVariablesListFactory(assert, machina, HierarchicalGroup, hierarchicalBehaviors, HierarchicalVariables) {
            var HierarchicalVariablesList = machina.Fsm.extend({
                initialState: "uninitialized",
                namespace: "hierarchicalVariablesList",
                destroy: function() {
                    return this.transition("destroyed");
                },
                _store: function(hierarchical) {
                    var defaultBehaviors = this.behaviors || hierarchicalBehaviors.DEFAULT();
                    assert(hierarchical, "You should pass a HierarchicalVariables object");
                    assert(hierarchical instanceof HierarchicalVariables, "You should pass a valid instance of HierarchicalVariables");
                    this.root = HierarchicalGroup.create({
                        group: hierarchical.ordered,
                        behaviors: defaultBehaviors
                    });
                },
                applyBehaviors: function(behave) {
                    this.behaviors = hierarchicalBehaviors(behave);
                    if (this.root) {
                        this.root.applyBehaviors(this.behaviors);
                    }
                },
                $events: [ "hvl.behaviors.update" ],
                states: {
                    uninitialized: {
                        initialize: function(opts) {
                            this._store(opts.hierarchicalVariables);
                            this.original = this.root;
                            this.transition("initialized");
                        }
                    },
                    initialized: {
                        _onEnter: function() {
                            this.root.handle("expand");
                        },
                        refresh: function(hierarchicalVariables) {
                            this._store(hierarchicalVariables);
                            this.transition("refreshing");
                        },
                        rollback: function() {
                            this.root = this.original;
                            this.emit("hvl.refreshed");
                        },
                        "hvl.behaviors.update": function(e, behaviors) {
                            this.applyBehaviors(behaviors);
                        }
                    },
                    refreshing: {
                        _onEnter: function() {
                            this.transition("initialized");
                            this.emit("hvl.refreshed");
                        }
                    },
                    empty: {
                        refresh: function(hierarchicalVariables) {
                            this._store(hierarchicalVariables);
                            this.transition("refreshing");
                        }
                    },
                    destroyed: {
                        _onEnter: function() {
                            if (this.root) {
                                this.root.destroy();
                            }
                            this.off();
                        }
                    }
                }
            });
            HierarchicalVariablesList.create = function(cfg) {
                var hvl = new HierarchicalVariablesList();
                hvl.handle("initialize", cfg || {});
                return hvl;
            };
            return HierarchicalVariablesList;
        }
    }, {} ],
    164: [ function(require, module, exports) {
        "use strict";
        module.exports = buildModule;
        function buildModule(moduleName) {
            var angular = require("angular");
            var mod = angular.module(moduleName || "hierarchical-variables-list", []);
            mod.factory("lodash", function() {
                return require("lodash");
            });
            mod.factory("assert", function() {
                return console.assert.bind(console);
            });
            mod.factory("HierarchicalVariablesList", require("./hierarchical-variables-list"));
            mod.factory("HierarchicalGroup", require("./hierarchical-group"));
            mod.factory("HierarchicalVariable", require("./hierarchical-variable"));
            mod.factory("hierarchicalBehaviors", require("./hierarchical-behaviors"));
            return mod;
        }
    }, {
        "./hierarchical-behaviors": 160,
        "./hierarchical-group": 161,
        "./hierarchical-variable": 162,
        "./hierarchical-variables-list": 163,
        angular: "angular",
        lodash: 77
    } ],
    165: [ function(require, module, exports) {
        "use strict";
        module.exports = CachedHierarchicalVariablesFactory;
        function CachedHierarchicalVariablesFactory(_, $q) {
            var executionQueue = [], current, refreshing = false;
            function CachedHierarchicalVariables() {}
            CachedHierarchicalVariables.prototype.executeAfterRefresh = function(fn) {
                if (_.isFunction(fn)) {
                    if (refreshing === true) {
                        executionQueue.push(fn);
                    } else {
                        fn();
                    }
                }
            };
            CachedHierarchicalVariables.prototype.refresh = function() {
                refreshing = true;
            };
            Object.defineProperties(CachedHierarchicalVariables.prototype, {
                current: {
                    get: function() {
                        return current;
                    },
                    set: function(value) {
                        current = value;
                        executionQueue.forEach(function(fn) {
                            fn();
                        });
                        executionQueue.length = 0;
                        refreshing = false;
                    }
                }
            });
            return new CachedHierarchicalVariables();
        }
        CachedHierarchicalVariablesFactory.$inject = [ "lodash", "$q" ];
    }, {} ],
    166: [ function(require, module, exports) {
        "use strict";
        module.exports = GroupFactory;
        GroupFactory.$inject = [ "lodash", "iCalculateItemLevel" ];
        function GroupFactory(_, iCalculateItemLevel) {
            function Group(name, parent) {
                this.id = _.uniqueId(name);
                this.name = name;
                this.parent = parent;
                this.items = [];
            }
            Object.defineProperties(Group.prototype, {
                hierarchicalType: {
                    value: "group"
                },
                itemsCount: {
                    get: function() {
                        return this.items.length;
                    }
                },
                level: {
                    get: function() {
                        return iCalculateItemLevel(this);
                    }
                }
            });
            Group.prototype.addItem = function(item) {
                if (!this.containsItem(item)) {
                    this.items.push(item);
                }
            };
            Group.prototype.prependItem = function(item) {
                this.items.unshift(item);
            };
            Group.prototype.removeItem = function(item) {
                var index = this.items.indexOf(item), removed;
                if (index > -1) {
                    removed = this.items.splice(index, 1);
                } else {
                    throw new Error("this group does not contain the item");
                }
                return removed[0];
            };
            Group.prototype.containsItem = function(item) {
                return this.items.indexOf(item) > -1;
            };
            Group.prototype.containsItemNamed = function(name) {
                return !_.isUndefined(this.findItemNamed(name));
            };
            Group.prototype.findItemNamed = function(name) {
                var itemFound;
                this.items.some(function(item) {
                    var matches = item.name === name;
                    if (matches) {
                        itemFound = item;
                    }
                    return matches;
                });
                return itemFound;
            };
            Group.prototype.switchOrder = function(item1, item2) {
                var firstIndex, secondIndex;
                if (!this.containsItem(item1) || !this.containsItem(item2)) {
                    throw new Error("one of these items do not belong to this group");
                }
                firstIndex = this.items.indexOf(item1);
                secondIndex = this.items.indexOf(item2);
                this.items[firstIndex] = item2;
                this.items[secondIndex] = item1;
            };
            Group.prototype.moveItemBefore = function(item, before) {
                var itemIndex, beforeIndex;
                if (!this.containsItem(item) || !this.containsItem(before)) {
                    throw new Error("one of these items do not belong to this group");
                }
                itemIndex = this.items.indexOf(item);
                this.items.splice(itemIndex, 1);
                beforeIndex = this.items.indexOf(before);
                this.items.splice(beforeIndex, 0, item);
            };
            Group.prototype.insertAfter = function(items, after) {
                var index = this.items.indexOf(after), itemsToInsert = items instanceof Array ? items : [ items ], self = this;
                if (index === -1) {
                    throw new Error("This item does not belong to this group");
                }
                itemsToInsert.forEach(function(item) {
                    item.parent = self;
                });
                this.items.splice.apply(self.items, [ index, 0 ].concat(itemsToInsert));
            };
            Group.prototype.removeItem = function(item) {
                var index = this.items.indexOf(item);
                if (index === -1) {
                    throw new Error("This item does not belong to this group");
                }
                this.items.splice(index, 1);
            };
            Group.prototype.toJSON = function() {
                var group = {};
                group[this.name] = this.items.map(function(i) {
                    return i.toJSON();
                });
                if (!this.parent) {
                    group.element = "shoji:order";
                }
                return group;
            };
            return Group;
        }
    }, {} ],
    167: [ function(require, module, exports) {
        "use strict";
        module.exports = HierarchicalOrderFactory;
        HierarchicalOrderFactory.$inject = [];
        function HierarchicalOrderFactory() {
            function HierarchicalOrder(ordered, flattened, orderedIndex) {
                this.ordered = ordered;
                this.flattened = flattened;
                this.orderedIndex = orderedIndex;
            }
            Object.defineProperties(HierarchicalOrder.prototype, {
                groups: {
                    get: function() {
                        throw new Error("deprecated property. use flatten instead.");
                    }
                },
                length: {
                    get: function() {
                        return this.flattened.length;
                    }
                }
            });
            return HierarchicalOrder;
        }
    }, {} ],
    168: [ function(require, module, exports) {
        "use strict";
        module.exports = HierarchicalVariablesFactory;
        HierarchicalVariablesFactory.$inject = [ "iBuildHierarchicalOrder", "iPerformVariableLookup", "iMutateHierarchicalOrder" ];
        function HierarchicalVariablesFactory(iBuildHierarchicalOrder, iPerformVariableLookup, iMutateHierarchicalOrder) {
            function assert(pred, msg) {
                if (!pred) {
                    throw new Error(msg);
                }
            }
            function HierarchicalVariables(catalogs, order, privateVariables) {
                assert(order, "order is required");
                this.orderId = order.self;
                this.catalogs = catalogs;
                this.privateVariables = privateVariables;
                this.order = iBuildHierarchicalOrder(catalogs, order, privateVariables);
            }
            HierarchicalVariables.prototype.exposePrivateVariables = function() {
                var privateOrder = {
                    "My Variables": []
                }, fakeShojiOrder = {
                    graph: [ privateOrder ]
                }, privateHierarchicalOrder, privateGroup, index = [];
                if (!this.privateVariables) {
                    throw new Error("Please provide a privateVariables catalog");
                }
                if (!this.byName("My Variables")) {
                    this.privateVariables.principal().index.forEach(function(variableTuple) {
                        variableTuple.private = true;
                        index.push(variableTuple);
                    });
                    index.sort(function(a, b) {
                        var r;
                        if (a.name < b.name) {
                            r = -1;
                        } else if (a.name > b.name) {
                            r = 1;
                        } else {
                            r = 0;
                        }
                        return r;
                    }).forEach(function(tuple) {
                        privateOrder["My Variables"].push(tuple.self);
                    });
                    privateHierarchicalOrder = iBuildHierarchicalOrder(this.privateVariables, fakeShojiOrder);
                    privateGroup = privateHierarchicalOrder.ordered.items[0];
                    privateGroup.private = true;
                    iMutateHierarchicalOrder.addItem(this.order, privateGroup, {
                        prepend: true
                    });
                }
            };
            HierarchicalVariables.prototype.reorderedBy = function(order) {
                return new HierarchicalVariables(this.catalogs, order, this.privateVariables);
            };
            HierarchicalVariables.prototype.flatten = function() {
                return this.order.flattened;
            };
            HierarchicalVariables.prototype.byId = function(variableId) {
                return iPerformVariableLookup.byId(this.order, variableId);
            };
            HierarchicalVariables.prototype.byName = function(itemName) {
                return iPerformVariableLookup.byName(this.order, itemName);
            };
            HierarchicalVariables.prototype.fromCatalog = function(variableId) {
                return iPerformVariableLookup.fromCatalog(this.catalogs.principal(), variableId);
            };
            HierarchicalVariables.prototype.indexOf = function(variableId) {
                return iPerformVariableLookup.indexOf(this.order, variableId);
            };
            HierarchicalVariables.prototype.slice = function() {
                return this.order.flattened.slice.apply(this.order.flattened, arguments);
            };
            HierarchicalVariables.prototype.at = function(index) {
                return iPerformVariableLookup.at(this.order, index);
            };
            HierarchicalVariables.prototype.firstVariable = function(index) {
                return iPerformVariableLookup.firstVariable(this.order, index);
            };
            HierarchicalVariables.prototype.moveItemToGroup = function(item, group) {
                iMutateHierarchicalOrder.moveItemToGroup(this.order, item, group);
            };
            HierarchicalVariables.prototype.switchItemsOrder = function(item1, item2) {
                iMutateHierarchicalOrder.switchItemsOrder(this.order, item1, item2);
            };
            HierarchicalVariables.prototype.moveItemBefore = function(item, before) {
                iMutateHierarchicalOrder.moveItemBefore(this.order, item, before);
            };
            HierarchicalVariables.prototype.createGroupWithParent = function(name, parent) {
                return iMutateHierarchicalOrder.createGroupWithParent(this.order, name, parent);
            };
            HierarchicalVariables.prototype.removeGroup = function(group) {
                iMutateHierarchicalOrder.removeGroup(this.order, group);
            };
            HierarchicalVariables.prototype.variables = function() {
                return this._variables.principal();
            };
            Object.defineProperties(HierarchicalVariables.prototype, {
                groups: {
                    get: function() {
                        throw new Error("deprecated property. use flatten instead.");
                    }
                },
                ordered: {
                    get: function() {
                        return this.order.ordered;
                    }
                },
                weights: {
                    get: function() {
                        return this.catalogs.principal().urls.weights;
                    }
                },
                searchUrl: {
                    get: function() {
                        return this.catalogs.principal().views.search.self;
                    }
                },
                catalogId: {
                    get: function() {
                        return this.catalogs.principal().self;
                    }
                },
                length: {
                    get: function() {
                        return this.order.length;
                    }
                }
            });
            return HierarchicalVariables;
        }
    }, {} ],
    169: [ function(require, module, exports) {
        "use strict";
        module.exports = IBuildHierarchicalOrderFactory;
        IBuildHierarchicalOrderFactory.$inject = [ "HierarchicalOrder", "Group", "variableFactory", "Map", "iGetVariableHash" ];
        function IBuildHierarchicalOrderFactory(HierarchicalOrder, Group, variableFactory, Map, iGetVariableHash) {
            function assert(pred, msg) {
                if (!pred) {
                    throw new Error(msg);
                }
            }
            return function iBuildHierarchicalOrder(variables, shojiOrder, privateVariables) {
                var numericIndex = 0, ordered, flattened, orderedIndex;
                function addItems(itemsData, parent) {
                    itemsData.forEach(function(item) {
                        addItem(item, parent);
                    });
                }
                function addItem(itemData, parent) {
                    var simple = typeof itemData === "string", create = simple ? createVariable : createGroup, item = create(itemData, parent);
                    flattened[numericIndex] = item;
                    orderedIndex.set(item.id, numericIndex);
                    parent.addItem(item);
                    if (simple) {
                        addSubItems(item);
                        numericIndex += 1;
                    } else {
                        numericIndex += 1;
                        addItems(itemData[item.name], item);
                    }
                }
                function createVariable(url, parent) {
                    var varb = variables.getVariable(url), variable;
                    if (!varb && privateVariables) {
                        varb = privateVariables.getVariable(url);
                    }
                    assert(varb, "variable not found with id " + url);
                    variable = variableFactory.create(varb, parent);
                    return variable;
                }
                function createGroup(groupData, parent) {
                    var name = Object.keys(groupData)[0], group = new Group(name, parent);
                    return group;
                }
                function addSubItems(item) {
                    var subitems = item.subvariables || [];
                    subitems.forEach(function(subvariable) {
                        var trimmed = iGetVariableHash(subvariable);
                        orderedIndex.set(trimmed.replace("/", ""), numericIndex);
                    });
                }
                ordered = new Group("graph");
                flattened = [];
                orderedIndex = new Map();
                addItems(shojiOrder.graph, ordered);
                return new HierarchicalOrder(ordered, flattened, orderedIndex);
            };
        }
    }, {} ],
    170: [ function(require, module, exports) {
        "use strict";
        module.exports = {
            $get: getICacheHierarchicalVariablesFetching
        };
        getICacheHierarchicalVariablesFetching.$inject = [ "$delegate", "cachedHierarchicalVariables" ];
        function getICacheHierarchicalVariablesFetching($delegate, cachedHierarchicalVariables) {
            function cache() {
                var params = arguments[0] || {};
                if (!params.noCache) {
                    cachedHierarchicalVariables.refresh();
                }
                return $delegate.apply($delegate, arguments).then(function(hierarchicalVariables) {
                    if (!params.noCache) {
                        cachedHierarchicalVariables.current = hierarchicalVariables;
                    }
                    return hierarchicalVariables;
                });
            }
            return cache;
        }
    }, {} ],
    171: [ function(require, module, exports) {
        "use strict";
        module.exports = ICalculateItemLevelFactory;
        function ICalculateItemLevelFactory() {
            function iCalculateItemLevel(item) {
                var level = 1, parent = item.parent;
                while (parent) {
                    level += 1;
                    parent = parent.parent;
                }
                return level;
            }
            return iCalculateItemLevel;
        }
    }, {} ],
    172: [ function(require, module, exports) {
        "use strict";
        module.exports = IFetchHierarchicalVariablesFactory;
        IFetchHierarchicalVariablesFactory.$inject = [ "currentDataset", "Shoji", "$q", "VariableCatalogList", "SubvariablesCatalogList", "HierarchicalVariables" ];
        function IFetchHierarchicalVariablesFactory(currentDataset, Shoji, $q, VariableCatalogList, SubvariablesCatalogList, HierarchicalVariables) {
            function loadVariables(acc, dataset) {
                acc.dataset = dataset;
                return dataset.urls.variables.map({
                    noCache: true,
                    params: {
                        relative: "on",
                        nosubvars: 1
                    }
                }).then(function(variables) {
                    acc.variableCatalogs = new VariableCatalogList();
                    acc.variableCatalogs.add(variables);
                });
            }
            function loadJoins(acc) {
                var dataset = acc.dataset;
                return dataset.urls.joins.map();
            }
            function loadSubordinateVariables(acc, joins) {
                var promises = [];
                joins.index.forEach(function(join) {
                    var promise;
                    promise = Shoji(join.variables).map({
                        params: {
                            relative: "on",
                            nosubvars: 1
                        }
                    }).then(function(variables) {
                        acc.variableCatalogs.add(variables);
                    });
                    promises.push(promise);
                });
                return $q.all(promises);
            }
            function loadOrder(acc) {
                return acc.variableCatalogs.principal().orders.hier.map({
                    noCache: true,
                    params: {
                        relative: "on"
                    }
                });
            }
            function loadPrivateVariables(acc, order) {
                var privateCatalog;
                acc.order = order;
                privateCatalog = acc.variableCatalogs.principal().catalogs.private;
                if (privateCatalog) {
                    return privateCatalog.map({
                        noCache: true
                    }).then(function(privateCatalog) {
                        return new SubvariablesCatalogList([ privateCatalog ]);
                    });
                } else {
                    return undefined;
                }
            }
            function buildWithPrivateVariables(acc, privateVariables) {
                return new HierarchicalVariables(acc.variableCatalogs, acc.order, privateVariables);
            }
            function build(acc, order) {
                return new HierarchicalVariables(acc.variableCatalogs, order);
            }
            function iFetchHierarchicalVariables(q) {
                var data = {
                    variables: undefined,
                    order: undefined,
                    dataset: undefined,
                    includePrivateVariables: q.includePrivateVariables
                };
                var handlers = [ loadVariables, loadJoins, loadSubordinateVariables, loadOrder ];
                if (q.includePrivateVariables === true) {
                    handlers.push(loadPrivateVariables, buildWithPrivateVariables);
                } else {
                    handlers.push(build);
                }
                return currentDataset.fetch().then(function(dataset) {
                    return dataset.reduce(data, handlers);
                });
            }
            return iFetchHierarchicalVariables;
        }
    }, {} ],
    173: [ function(require, module, exports) {
        "use strict";
        module.exports = IFetchSubvariablesFactory;
        IFetchSubvariablesFactory.$inject = [ "Shoji", "SubvariablesCatalogList" ];
        function IFetchSubvariablesFactory(Shoji, SubvariablesCatalogList) {
            return function fetch(variable) {
                var url = variable.self + "subvariables/", order = variable.subvariables;
                return Shoji(url).map().then(function(subvariablesData) {
                    return new SubvariablesCatalogList([ subvariablesData ]);
                });
            };
        }
    }, {} ],
    174: [ function(require, module, exports) {
        "use strict";
        module.exports = IGenerateVariableFullNameFactory;
        IGenerateVariableFullNameFactory.$inject = [];
        function IGenerateVariableFullNameFactory() {
            return function(hierarchicalVariable) {
                var fullName = hierarchicalVariable.prunedName || hierarchicalVariable.name, parent = hierarchicalVariable.parent;
                while (parent.hierarchicalType === "variable" || parent.parent && parent.parent.name !== "graph") {
                    fullName = parent.name + " - " + fullName;
                    parent = parent.parent;
                }
                return fullName;
            };
        }
    }, {} ],
    175: [ function(require, module, exports) {
        "use strict";
        module.exports = IGetVariableHashSegmentFactory;
        IGetVariableHashSegmentFactory.$inject = [];
        function IGetVariableHashSegmentFactory() {
            return function getHashSegment(url) {
                var pruneStart = url.lastIndexOf("/", url.length - 2) + 1, pruned = url.substring(pruneStart);
                return pruneStart === -1 ? url : pruned;
            };
        }
    }, {} ],
    176: [ function(require, module, exports) {
        "use strict";
        module.exports = IMutateHierarchicalOrderFactory;
        function IMutateHierarchicalOrderFactory(iPerformVariableLookup, iGetVariableHash, Group, Map) {
            function IMutateHierarchicalOrder() {}
            function rebuildOrderIdMapFromFlattenedIndex(flattenedIndex) {
                var orderIdMap = new Map();
                flattenedIndex.forEach(function(item, index) {
                    orderIdMap.set(item.id, index);
                    if (item.hierarchicalType === "variable") {
                        item.subvariables.forEach(function(subvar) {
                            var subvarId = typeof subvar === "string" ? iGetVariableHash(subvar).replace("/", "") : subvar.id;
                            orderIdMap.set(subvarId, index);
                        });
                    }
                });
                return orderIdMap;
            }
            IMutateHierarchicalOrder.prototype.moveItemToGroup = function(order, item, group) {
                var groupIndex, itemIndex = iPerformVariableLookup.indexOf(order, item.id);
                groupIndex = group === order.ordered ? 0 : iPerformVariableLookup.indexOf(order, group.id);
                if (groupIndex === -1) {
                    throw new Error("This group does not belong to the hierarchical order");
                }
                if (itemIndex === -1) {
                    throw new Error("This item does not belong to the hierarchical order");
                }
                if (item && !group.containsItem(item)) {
                    if (item.parent) {
                        item.parent.removeItem(item);
                    }
                    group.addItem(item);
                    item.parent = group;
                    order.flattened.splice(itemIndex, 1);
                    order.flattened.splice(groupIndex, 0, item);
                    order.orderedIndex = rebuildOrderIdMapFromFlattenedIndex(order.flattened);
                }
            };
            function flat(item) {
                function flatRecurr(item, collection) {
                    var children = item.items || [];
                    collection.push(item);
                    children.forEach(function(child) {
                        flatRecurr(child, collection);
                    });
                    return collection;
                }
                return flatRecurr(item, []);
            }
            IMutateHierarchicalOrder.prototype.addItem = function(order, item, options) {
                var itemIndex = iPerformVariableLookup.indexOf(order, item.id), flattened = flat(item);
                options = options || {};
                if (itemIndex !== -1) {
                    throw new Error("this item already exists in the order");
                }
                if (options.prepend === true) {
                    order.flattened.unshift.apply(order.flattened, flattened);
                    item.parent = order.ordered;
                    order.ordered.prependItem(item);
                } else {
                    order.flattened.push.apply(order.flattened, flattened);
                    order.ordered.addItem(item);
                }
                order.orderedIndex = rebuildOrderIdMapFromFlattenedIndex(order.flattened);
            };
            IMutateHierarchicalOrder.prototype.switchItemsOrder = function(order, item1, item2) {
                var item1Index = iPerformVariableLookup.indexOf(order, item1.id), item2Index = iPerformVariableLookup.indexOf(order, item2.id), parent = item1.parent;
                if (item2Index === -1) {
                    throw new Error("This item does not belong to the hierarchical order");
                }
                parent.switchOrder(item1, item2);
                order.flattened[item1Index] = item2;
                order.flattened[item2Index] = item1;
                order.orderedIndex.set(item1.id, item2Index);
                order.orderedIndex.set(item2.id, item1Index);
            };
            IMutateHierarchicalOrder.prototype.moveItemBefore = function(order, item, before) {
                var itemIndex = iPerformVariableLookup.indexOf(order, item.id), beforeIndex = iPerformVariableLookup.indexOf(order, before.id), parent;
                if (itemIndex === -1) {
                    throw new Error("This item does not belong to the hierarchical order");
                }
                if (beforeIndex === -1) {
                    throw new Error("This item does not belong to the hierarchical order");
                }
                if (itemIndex !== beforeIndex) {
                    parent = item.parent;
                    parent.moveItemBefore(item, before);
                    order.flattened.splice(itemIndex, 1);
                    order.orderedIndex = rebuildOrderIdMapFromFlattenedIndex(order.flattened);
                    beforeIndex = iPerformVariableLookup.indexOf(order, before.id);
                    order.flattened.splice(beforeIndex, 0, item);
                    order.orderedIndex = rebuildOrderIdMapFromFlattenedIndex(order.flattened);
                }
            };
            IMutateHierarchicalOrder.prototype.createGroupWithParent = function(order, name, parent) {
                var parentIndex, newGroup, existingItem;
                parentIndex = parent === order.ordered ? 0 : iPerformVariableLookup.indexOf(order, parent.id);
                if (parentIndex === -1) {
                    throw new Error("The group parent does not belong to the hierarchical order");
                }
                existingItem = parent.findItemNamed(name);
                if (existingItem && existingItem.hierarchicalType === "group") {
                    throw new Error("The parent already contains an item named " + name);
                }
                newGroup = new Group(name, parent);
                parent.prependItem(newGroup);
                order.flattened.splice(parentIndex + 1, 0, newGroup);
                order.orderedIndex = rebuildOrderIdMapFromFlattenedIndex(order.flattened);
                return newGroup;
            };
            IMutateHierarchicalOrder.prototype.removeGroup = function(order, group) {
                var groupIndex, parent;
                if (group === order.ordered) {
                    throw new Error("The root node can't be deleted");
                }
                groupIndex = iPerformVariableLookup.indexOf(order, group.id);
                if (groupIndex === -1) {
                    throw new Error("This group does not belong to the hierarchical order");
                }
                parent = group.parent;
                parent.insertAfter(group.items, group);
                parent.removeItem(group);
                order.flattened.splice(groupIndex, 1);
                order.orderedIndex = rebuildOrderIdMapFromFlattenedIndex(order.flattened);
            };
            return new IMutateHierarchicalOrder();
        }
        IMutateHierarchicalOrderFactory.$inject = [ "iPerformVariableLookup", "iGetVariableHash", "Group", "Map" ];
    }, {} ],
    177: [ function(require, module, exports) {
        "use strict";
        module.exports = IPerformVariableLookupFactory;
        IPerformVariableLookupFactory.$inject = [ "iGetVariableHash" ];
        function IPerformVariableLookupFactory(iGetVariableHash) {
            function IPerformVariableLookup() {}
            IPerformVariableLookup.prototype.byName = function(hierarchicalOrder, itemName) {
                var itemFound;
                hierarchicalOrder.flattened.some(function(item) {
                    if (item.name === itemName) {
                        itemFound = item;
                        return true;
                    }
                });
                return itemFound;
            };
            IPerformVariableLookup.prototype.byId = function(hierarchicalOrder, itemId) {
                var index = this.indexOf(hierarchicalOrder, itemId), item, found;
                if (index > -1) {
                    found = hierarchicalOrder.flattened[index];
                }
                return found;
            };
            IPerformVariableLookup.prototype.fromCatalog = function(catalog, itemId) {
                var pruned = iGetVariableHash(itemId);
                return catalog.index[pruned];
            };
            IPerformVariableLookup.prototype.indexOf = function(hierarchicalOrder, itemId) {
                var pruned, index;
                if (!itemId) {
                    index = -1;
                } else {
                    pruned = iGetVariableHash(itemId);
                    index = hierarchicalOrder.orderedIndex.get(pruned.replace("/", ""));
                }
                return typeof index === "number" ? index : -1;
            };
            IPerformVariableLookup.prototype.at = function(hierarchicalOrder, index) {
                return hierarchicalOrder.flattened[index];
            };
            IPerformVariableLookup.prototype.firstVariable = function(hierarchicalOrder) {
                var first;
                hierarchicalOrder.flattened.some(function(item) {
                    first = item;
                    return !first.discarded && item.hierarchicalType === "variable";
                });
                return first;
            };
            return new IPerformVariableLookup();
        }
    }, {} ],
    178: [ function(require, module, exports) {
        "use strict";
        module.exports = {
            $get: getIThrottleHierarchicalVariablesFetching
        };
        getIThrottleHierarchicalVariablesFetching.$inject = [ "$delegate", "$log", "$q", "$timeout" ];
        function getIThrottleHierarchicalVariablesFetching($delegate, $log, $q, $timeout) {
            var cached = {}, pendingPromises = {};
            function assert(condition, messages) {
                if (!condition) {
                    throw new Error(messages);
                }
            }
            function flush() {
                $log.debug("extracting cached hierarchical variables list");
                cached = {};
            }
            function throttle(params) {
                var cachedResult, pendingPromise, promise, datasetId = params.datasetId;
                assert(datasetId, "Please provide a valid dataset id");
                cachedResult = cached[datasetId];
                pendingPromise = pendingPromises[datasetId];
                if (cachedResult) {
                    promise = $q.when(cachedResult);
                } else if (pendingPromise) {
                    promise = pendingPromise;
                } else {
                    promise = $delegate.apply(this, arguments).then(function(result) {
                        cached[datasetId] = result;
                        $timeout(flush, 1e3);
                        delete pendingPromises[datasetId];
                        return result;
                    }).catch(function() {
                        flush();
                        delete pendingPromises[datasetId];
                    });
                    pendingPromises[datasetId] = promise;
                }
                return promise;
            }
            return throttle;
        }
    }, {} ],
    179: [ function(require, module, exports) {
        "use strict";
        module.exports = buildModule;
        function buildModule(moduleName, cfg) {
            var angular = require("angular"), _ = require("lodash");
            var mod = angular.module(moduleName || "hierarchical-variables", []);
            mod.factory("lodash", function() {
                return _;
            });
            mod.factory("Map", function() {
                return require("es6-map");
            });
            mod.factory("pruneGroupNameFromVariableName", require("./prune-group-name-from-variable-name"));
            mod.factory("iGenerateVariableFullName", require("./i-generate-variable-full-name"));
            mod.factory("iFetchSubvariables", require("./i-fetch-subvariables"));
            mod.factory("iGetVariableHash", require("./i-get-variable-hash"));
            mod.factory("iBuildHierarchicalOrder", require("./i-build-hierarchical-order"));
            mod.factory("iPerformVariableLookup", require("./i-perform-variable-lookup"));
            mod.factory("iMutateHierarchicalOrder", require("./i-mutate-hierarchical-order"));
            mod.factory("iCalculateItemLevel", require("./i-calculate-item-level"));
            mod.factory("cachedHierarchicalVariables", require("./cached-hierarchical-variables"));
            mod.factory("VariableCatalogList", require("./variable-catalog-list"));
            mod.factory("SubvariablesCatalogList", require("./subvariables-catalog-list"));
            mod.factory("HierarchicalOrder", require("./hierarchical-order"));
            mod.factory("Group", require("./group"));
            mod.factory("variableFactory", require("./variable-factory"));
            mod.factory("HierarchicalVariables", require("./hierarchical-variables"));
            mod.provider("iThrottleHierarchicalVariablesFetching", require("./i-throttle-hierarchical-variables-fetching"));
            mod.provider("iCacheHierarchicalVariables", require("./i-cache-hierarchical-variables"));
            mod.factory("iFetchHierarchicalVariables", require("./i-fetch-hierarchical-variables"));
            mod.config([ "$provide", "iThrottleHierarchicalVariablesFetchingProvider", "iCacheHierarchicalVariablesProvider", function($provide, throttleDecorator, cacheDecorator) {
                $provide.decorator("iFetchHierarchicalVariables", throttleDecorator.$get);
                $provide.decorator("iFetchHierarchicalVariables", cacheDecorator.$get);
            } ]);
            return mod;
        }
    }, {
        "./cached-hierarchical-variables": 165,
        "./group": 166,
        "./hierarchical-order": 167,
        "./hierarchical-variables": 168,
        "./i-build-hierarchical-order": 169,
        "./i-cache-hierarchical-variables": 170,
        "./i-calculate-item-level": 171,
        "./i-fetch-hierarchical-variables": 172,
        "./i-fetch-subvariables": 173,
        "./i-generate-variable-full-name": 174,
        "./i-get-variable-hash": 175,
        "./i-mutate-hierarchical-order": 176,
        "./i-perform-variable-lookup": 177,
        "./i-throttle-hierarchical-variables-fetching": 178,
        "./prune-group-name-from-variable-name": 180,
        "./subvariables-catalog-list": 181,
        "./variable-catalog-list": 182,
        "./variable-factory": 183,
        angular: "angular",
        "es6-map": 21,
        lodash: 77
    } ],
    180: [ function(require, module, exports) {
        "use strict";
        module.exports = PruneGroupNameFromVariableNameFactory;
        PruneGroupNameFromVariableNameFactory.$inject = [ "lodash" ];
        function PruneGroupNameFromVariableNameFactory(_) {
            function getInverseHierarchy(group) {
                var current = group, temp, first;
                while (current) {
                    temp = first;
                    first = {
                        item: current
                    };
                    first.child = temp;
                    current = current.parent;
                }
                return first;
            }
            function prune(variableName, groupName) {
                var pruned = variableName, pattern = new RegExp("^" + cleanGroupName(groupName) + "[-\\s]+", "gi");
                if (_.isString(groupName)) {
                    pruned = pruned.replace(pattern, "") || pruned;
                }
                return pruned;
            }
            function cleanGroupName(groupName) {
                return groupName.replace(/([\\(\\)]+)/gi, "\\$1");
            }
            return function(variableName, group) {
                var current = getInverseHierarchy(group), pruned = variableName, groupName;
                while (current) {
                    pruned = prune(pruned, current.item.name);
                    current = current.child;
                }
                return pruned;
            };
        }
    }, {} ],
    181: [ function(require, module, exports) {
        "use strict";
        module.exports = SubvariablesCatalogListFactory;
        SubvariablesCatalogListFactory.$inject = [ "VariableCatalogList", "iGetVariableHash" ];
        function SubvariablesCatalogListFactory(VariableCatalogList, iGetVariableHash) {
            function SubvariablesCatalogList() {
                VariableCatalogList.apply(this, arguments);
            }
            SubvariablesCatalogList.prototype = new VariableCatalogList();
            SubvariablesCatalogList.prototype.getVariable = function(id) {
                var found, hash = iGetVariableHash(id);
                this.catalogs.some(function(catalog) {
                    var self;
                    catalog.index.keys.some(function(key) {
                        var contains = key.indexOf(hash) > -1;
                        if (contains) {
                            self = key;
                        }
                        return contains;
                    });
                    if (self) {
                        found = catalog.index[self];
                        return true;
                    }
                });
                return found;
            };
            return SubvariablesCatalogList;
        }
    }, {} ],
    182: [ function(require, module, exports) {
        "use strict";
        module.exports = VariableCatalogListFactory;
        VariableCatalogListFactory.$inject = [ "iGetVariableHash" ];
        function VariableCatalogListFactory(iGetVariableHash) {
            function VariableCatalogList(catalogs) {
                this.catalogs = catalogs || [];
            }
            VariableCatalogList.prototype.add = function(catalog) {
                this.catalogs.push(catalog);
            };
            VariableCatalogList.prototype.getVariable = function(url) {
                var variableFound, id = iGetVariableHash(url);
                this.catalogs.some(function(catalog, index) {
                    if (variableFound = catalog.index[id]) {
                        return true;
                    }
                });
                return variableFound;
            };
            VariableCatalogList.prototype.principal = function() {
                return this.catalogs[0];
            };
            VariableCatalogList.prototype.countVariables = function() {
                return this.catalogs.reduce(function(previous, catalog) {
                    return previous + catalog.index.length;
                }, 0);
            };
            Object.defineProperty(VariableCatalogList.prototype, "length", {
                get: function() {
                    return this.catalogs.length;
                }
            });
            return VariableCatalogList;
        }
    }, {} ],
    183: [ function(require, module, exports) {
        "use strict";
        module.exports = VariableFactory;
        VariableFactory.$inject = [ "lodash", "$q", "iGetVariableHash", "iFetchSubvariables", "pruneGroupNameFromVariableName", "iGenerateVariableFullName", "iCalculateItemLevel" ];
        function VariableFactory(_, $q, iGetVariableHash, iFetchSubvariables, pruneGroupNameFromVariableName, iGenerateVariableFullName, iCalculateItemLevel) {
            var factory;
            function isSubordinate(varb) {
                var subordinateRegexp = /\/joins\/.{1,32}\/variables/gi;
                return varb.self && subordinateRegexp.test(varb.self);
            }
            function getSubvariables() {
                var self = this, order = self.subvariables;
                if (typeof order[0] === "string") {
                    return iFetchSubvariables(this).then(function(subvariables) {
                        self.subvariables = order.map(function(id) {
                            var subvar = factory.create(subvariables.getVariable(id));
                            subvar.parent = self;
                            return subvar;
                        });
                        return self.subvariables;
                    });
                }
                return $q.when(self.subvariables);
            }
            function subvariableById(variableId) {
                var found = undefined, self = this;
                self.subvariables.some(function(subvar) {
                    var id = _.isString(subvar) ? subvar : subvar.self;
                    if (iGetVariableHash(id) === iGetVariableHash(variableId)) {
                        found = subvar;
                    }
                    return found;
                });
                return found;
            }
            function extendSelf(map, params) {
                var tuple = this;
                return map.call(tuple, params).then(function(entity) {
                    return factory.create(entity, tuple.parent);
                });
            }
            function clone() {
                return factory.create(this, this.parent);
            }
            function contains(variableId) {
                return subvariableById.call(this, variableId) !== undefined;
            }
            function toJSON() {
                return this.self;
            }
            var properties = {
                fullName: {
                    get: function() {
                        return this._fullName || (this._fullName = iGenerateVariableFullName(this));
                    }
                },
                url: {
                    get: function() {
                        return this.self;
                    }
                },
                prunedName: {
                    get: function() {
                        return this._prunedName || (this._prunedName = pruneGroupNameFromVariableName(this.name, this.parent));
                    }
                },
                subordinate: {
                    get: function() {
                        return isSubordinate(this);
                    }
                },
                level: {
                    get: function() {
                        return iCalculateItemLevel(this);
                    }
                },
                categoricalArray: {
                    get: function() {
                        return this.type === "categorical_array";
                    }
                },
                hierarchicalType: {
                    value: "variable"
                }
            };
            return factory = {
                create: function(data, group) {
                    var variable = _.clone(data);
                    variable.prototype = data.prototype;
                    Object.defineProperties(variable, properties);
                    variable.map = _.wrap(data.map, extendSelf);
                    variable.getSubvariables = getSubvariables;
                    variable.toJSON = toJSON;
                    variable.subvariables = variable.subvariables || [];
                    variable.subvariableById = subvariableById;
                    variable.contains = contains;
                    variable.clone = clone;
                    variable.parent = group;
                    return variable;
                }
            };
        }
    }, {} ],
    184: [ function(require, module, exports) {
        "use strict";
        module.exports = buildModule;
        function buildModule(moduleName) {
            var angular = require("angular"), machina = require("machina"), _ = require("lodash");
            var mod = angular.module(moduleName || "machina-angular", []);
            mod.factory("machina", function() {
                return machina(_);
            });
            mod.provider("scopeable", require("./scopeable"));
            mod.config([ "$provide", "scopeableProvider", function($provide, scopeableProvider) {
                $provide.decorator("machina", scopeableProvider.$get);
            } ]);
            mod.run(require("./tappable"));
            mod.directive("transition", require("./transition-directive"));
            return mod;
        }
    }, {
        "./scopeable": 185,
        "./tappable": 186,
        "./transition-directive": 187,
        angular: "angular",
        lodash: 77,
        machina: 78
    } ],
    185: [ function(require, module, exports) {
        "use strict";
        module.exports = {
            $get: getScopeable
        };
        function getScopeable($delegate, $log) {
            var Fsm = $delegate.Fsm;
            if (!Fsm) {
                throw new Error("this decorator is intended to extend machina Fsm");
            }
            function Scopeable(scope, target) {
                if (!scope) {
                    throw new Error("scope is required");
                }
                if (!target) {
                    throw new Error("target is required");
                }
                this.target = target;
                this.scope = scope;
                this.listeners = [];
                this._init();
            }
            Scopeable.prototype._init = function() {
                this.listeners.forEach(function(unlisten) {
                    unlisten();
                });
                this.listeners.length = 0;
                this.listeners.push(this.scope.$on("$destroy", this.$destroy.bind(this)));
                if (this.target._$scoped) {
                    this.target._$scoped.apply(this.target, [ this.scope ]);
                }
            };
            Scopeable.prototype.$destroy = function $destroy() {
                var subs = this.target.eventListeners || {};
                this.scope = undefined;
                this.listeners.forEach(function(unlisten) {
                    unlisten();
                });
                if (this.target.destroy) {
                    this.target.destroy();
                } else if (this.target.off) {
                    this.target.off();
                }
                this.destroyed = true;
            };
            function $scoped(scope) {
                if (!scope) {
                    throw new Error("scope is required");
                }
                this.$scopeable = new Scopeable(scope, this);
                return this;
            }
            Fsm.prototype.$scoped = $scoped;
            return $delegate;
        }
        getScopeable.$inject = [ "$delegate", "$log" ];
    }, {} ],
    186: [ function(require, module, exports) {
        "use strict";
        module.exports = [ "machina", "$rootScope", "$log", function(machina, $rootScope, $log) {
            function Tappable(target, scope) {
                scope = scope || $rootScope;
                if (!scope) {
                    throw new Error("scope is required");
                }
                if (!target) {
                    throw new Error("target is required");
                }
                this.target = target;
                this.scope = scope;
                this.listeners = [];
                this._scopeAwareOff = this._scopeAwareOff.bind(this);
                this.$destroy = this.$destroy.bind(this);
                this.$tap(this.target.$events);
                this._off = this.target.off;
                this.target.off = this._scopeAwareOff.bind(this);
                this.target._off = this._off;
            }
            Tappable.prototype._scopeAwareOff = function() {
                if (arguments.length) {
                    this._off.apply(this.target, arguments);
                    return;
                }
                this.$destroy();
                this._off.apply(this.target, arguments);
                return this.target;
            };
            Tappable.prototype._unsubscribe = function(e) {
                if (e && e.toState !== "destroyed") {
                    return;
                }
                $log.debug("tappable", "unsubscribing all");
                this.listeners.forEach(function(unlisten) {
                    unlisten();
                });
            };
            Tappable.prototype.$tap = function $tap($events) {
                $events = $events || [];
                if ($events && $events.length && this.target.handle) {
                    $log.debug("tappable", "discovered", this.target.$events);
                    var subs = $events.map(function(e) {
                        return this.scope.$on(e, function() {
                            var args = [].slice.call(arguments);
                            args.unshift(e);
                            $log.debug("tappable", "handling", e);
                            this.target.handle.apply(this.target, args);
                        }.bind(this));
                    }, this);
                    this.listeners = this.listeners.concat(subs);
                    this.target.on("destroyed", this.$destroy);
                    this.target.on("transition", this.$destroy);
                }
            };
            Tappable.prototype.$destroy = function(e) {
                this._unsubscribe(e);
                this.target.off("destroyed", this.$destroy);
                this.target.off("transition", this.$destroy);
            };
            function wireUpNewMachina(instance) {
                instance.__tappable = new Tappable(instance);
            }
            machina.on("newfsm", wireUpNewMachina);
            $rootScope.$on("$destroy", function() {
                machina.off("newfsm", wireUpNewMachina);
            });
        } ];
    }, {} ],
    187: [ function(require, module, exports) {
        "use strict";
        module.exports = TransitionDirective;
        TransitionDirective.$inject = [ "$document" ];
        function TransitionDirective($document) {
            return {
                restrict: "A",
                link: function(scope, el, attrs) {
                    var ESC = 27;
                    var doc = $document[0], elm = el[0];
                    function enabled() {
                        var machine = scope.$eval(attrs.transition);
                        if (!machine) {
                            return;
                        }
                        var when = attrs["transitionWhen"];
                        if (when && machine.state !== when) {
                            return false;
                        }
                        return machine;
                    }
                    function handle(e) {
                        var key = e.keyCode && e.which;
                        if (key && key !== ESC) {
                            return false;
                        }
                        var machine = enabled();
                        if (!machine) {
                            return;
                        }
                        scope.$apply(function() {
                            var withState = attrs["transitionWith"] || "cancel";
                            machine.handle(withState);
                        });
                    }
                    function stop(e) {
                        if (!enabled()) {
                            return;
                        }
                        return e.stopPropagation();
                    }
                    elm.addEventListener("click", stop);
                    doc.addEventListener("click", handle);
                    doc.addEventListener("keyup", handle);
                    scope.$on("$destroy", function() {
                        doc.removeEventListener("click", handle);
                        doc.removeEventListener("keyup", handle);
                        elm.removeEventListener("click", stop);
                    });
                }
            };
        }
    }, {} ],
    188: [ function(require, module, exports) {
        module.exports = function() {
            "use strict";
            function BusAngularMediator(bus, $rootScope, $log) {
                return {
                    init: function() {
                        $log.debug("initializing bus and linking bus to rootScope");
                        bus.reset();
                        var untap = bus.tap(function(data, env) {
                            try {
                                if (data && data.event) {
                                    return $rootScope.$broadcast(data.event, data);
                                }
                            } catch (err) {
                                $log.error("Error $broadcasting event", data, err);
                                throw err;
                            }
                        });
                        $rootScope.$on("$destroy", function() {
                            bus.publish("rootScope.destroying");
                            untap();
                        });
                        bus.subscribe("error", function(data, env) {
                            $rootScope.$broadcast("error", data);
                        });
                        bus.subscribe("info", function(data, env) {
                            $rootScope.$broadcast("info", data);
                        });
                        $rootScope.error = function(error) {
                            $rootScope.$broadcast("error", error);
                        };
                        return bus;
                    },
                    publish: bus.publish,
                    send: bus.publish
                };
            }
            BusAngularMediator.$inject = [ "bus", "$rootScope", "$log" ];
            return BusAngularMediator;
        }.call(this);
    }, {} ],
    189: [ function(require, module, exports) {
        "use strict";
        module.exports = Bus;
        Bus.$inject = [ "commandBus", "eventBus" ];
        function Bus(commandBus, eventBus) {
            return {
                publish: eventBus.publish,
                reset: eventBus.reset,
                send: commandBus.send,
                subscribe: eventBus.subscribe,
                tap: eventBus.tap
            };
        }
    }, {} ],
    190: [ function(require, module, exports) {
        "use strict";
        CommandBus.$inject = [ "$q", "$log", "$injector", "lodash" ];
        module.exports = {
            $get: CommandBus
        };
        function CommandBus($q, $log, $injector, _) {
            function validate(command) {
                if (!command.command) {
                    throw new Error("The `command` property is required when sending a command. Please check your payload.");
                }
            }
            function execute(command) {
                try {
                    var handler = $injector.get(command.command + "Handler");
                    return $q.when(handler.apply(this, [ command ]));
                } catch (err) {
                    if (err.toString().indexOf("[$injector:unpr]") > -1) {
                        throw new Error("Command handler for '" + command.command + "'" + " could not be found.");
                    }
                    $log.error(err.toString());
                    $q.reject(err);
                    throw err;
                }
            }
            var bus = {
                send: function(commands) {
                    if (!_.isArray(commands)) {
                        commands = [ commands ];
                    }
                    _.each(commands, validate);
                    var all = _.map(commands, execute);
                    return $q.all(all);
                }
            };
            return bus;
        }
    }, {} ],
    191: [ function(require, module, exports) {
        "use strict";
        module.exports = EventBus;
        EventBus.$inject = [ "postal", "$q" ];
        function EventBus(postal, $q) {
            var CHANNEL = "events";
            var channel = postal.channel(CHANNEL);
            return {
                publish: function(e) {
                    if (!e.event) {
                        throw new Error("`event` property is required for events.");
                    }
                    return $q.when(channel.publish(e.event, e));
                },
                reset: postal.utils.reset,
                subscribe: function(e, cb) {
                    return postal.subscribe({
                        channel: CHANNEL,
                        topic: e,
                        callback: cb
                    });
                },
                tap: function(cb) {
                    return postal.addWireTap(cb);
                }
            };
        }
    }, {} ],
    192: [ function(require, module, exports) {
        "use strict";
        module.exports = buildModule;
        function buildModule(moduleName) {
            var angular = require("angular"), _ = require("lodash");
            var mod = angular.module(moduleName || "messaging", []);
            var postal = require("postal");
            mod.factory("lodash", function() {
                return _;
            });
            mod.factory("postal", [ "lodash", function(_) {
                if (_.isFunction(postal)) {
                    return postal(_);
                }
                return postal;
            } ]);
            mod.factory("eventBus", require("./event-bus"));
            mod.provider("commandBus", require("./command-bus"));
            mod.factory("bus", require("./bus"));
            mod.factory("busAngularMediator", require("./bus-angular-mediator"));
            mod.run([ "busAngularMediator", function(Mediator) {
                Mediator.init();
            } ]);
            return mod;
        }
    }, {
        "./bus": 189,
        "./bus-angular-mediator": 188,
        "./command-bus": 190,
        "./event-bus": 191,
        angular: "angular",
        lodash: 77,
        postal: 105
    } ],
    193: [ function(require, module, exports) {
        "use strict";
        module.exports = IResourceAccount;
        IResourceAccount.$inject = [ "iResourceUser" ];
        function IResourceAccount(iResourceUser) {
            return {
                current: function() {
                    var account = iResourceUser.current().then(function(user) {
                        return user.urls.account.map();
                    });
                    return account;
                }
            };
        }
    }, {} ],
    194: [ function(require, module, exports) {
        "use strict";
        module.exports = IResourceBatchFactory;
        IResourceBatchFactory.$inject = [ "Shoji" ];
        function IResourceBatchFactory(Shoji) {
            function fetchWithId(batchId) {
                return Shoji(batchId).map();
            }
            return function(params) {
                if (params && typeof params.batchId === "string") {
                    return fetchWithId(params.batchId);
                } else {
                    throw new Error("You should provide a batchId");
                }
            };
        }
    }, {} ],
    195: [ function(require, module, exports) {
        "use strict";
        module.exports = IResourceBatchesFactory;
        IResourceBatchesFactory.$inject = [ "iResourceDataset" ];
        function IResourceBatchesFactory(iResourceDataset) {
            return function(params) {
                return iResourceDataset({
                    datasetId: params.datasetId
                }).then(function(dataset) {
                    return dataset.urls.batches.map({
                        cache: false
                    });
                });
            };
        }
    }, {} ],
    196: [ function(require, module, exports) {
        "use strict";
        module.exports = IResourceDataset;
        IResourceDataset.$inject = [ "iResourceDatasets", "Shoji", "$log" ];
        function IResourceDataset(iResourceDatasets, Shoji, $log) {
            function assertQuery(q) {
                if (!q || !q.datasetId) {
                    throw new Error("Provide a valid datasetId");
                }
            }
            function execute(q) {
                var params = {};
                assertQuery(q);
                if (q.noCache) {
                    params.headers = {
                        "Cache-Control": "no-cache",
                        Expires: 0
                    };
                }
                $log.debug("iResourceDataset", "fetching", q);
                return Shoji(q.datasetId).map(params).then(function(dataset) {
                    return dataset;
                });
            }
            return execute;
        }
    }, {} ],
    197: [ function(require, module, exports) {
        "use strict";
        module.exports = IResourceDatasets;
        IResourceDatasets.$inject = [ "iResourceUser" ];
        function IResourceDatasets(iResourceUser) {
            function execute(q) {
                var catalog;
                if (q && q.datasetId && (q.datasetId[0] === "/" || q.datasetId.indexOf("http") > -1)) {
                    return iResourceUser.current().then(function(user) {
                        return user.urls.datasets.map();
                    }).then(function(datasets) {
                        var tuple;
                        catalog = datasets.self;
                        tuple = datasets.index.tuple(q.datasetId);
                        tuple.catalog = catalog;
                        return tuple;
                    });
                }
                return iResourceUser.current().then(function(user) {
                    return user.urls.datasets.map();
                });
            }
            return execute;
        }
    }, {} ],
    198: [ function(require, module, exports) {
        "use strict";
        module.exports = IResourceSourceFactory;
        IResourceSourceFactory.$inject = [ "Shoji" ];
        function IResourceSourceFactory(Shoji) {
            function fetchWithId(sourceId) {
                return Shoji(sourceId).map();
            }
            return function(params) {
                if (params && typeof params.sourceId === "string") {
                    return fetchWithId(params.sourceId);
                } else {
                    throw new Error("You should provide a sourceId");
                }
            };
        }
    }, {} ],
    199: [ function(require, module, exports) {
        "use strict";
        module.exports = IResourceUser;
        IResourceUser.$inject = [ "Shoji" ];
        function IResourceUser(Shoji) {
            return {
                current: function() {
                    return Shoji.API.map(function(api) {
                        return api.urls.user.map();
                    });
                }
            };
        }
    }, {} ],
    200: [ function(require, module, exports) {
        "use strict";
        module.exports = IResourceUsers;
        IResourceUsers.$inject = [ "iResourceAccount" ];
        function IResourceUsers(iResourceAccount) {
            function assertQuery(q) {
                if (!q) {
                    return undefined;
                }
                if (!q.userId) {
                    throw new Error("userId is required for iResourceUsers");
                }
                return {
                    userid: q.userId
                };
            }
            function execute(q) {
                q = assertQuery(q);
                return iResourceAccount.current().then(function(account) {
                    return account.urls.users.map({
                        cache: false,
                        params: q
                    });
                });
            }
            return execute;
        }
    }, {} ],
    201: [ function(require, module, exports) {
        module.exports = function() {
            "use strict";
            function IResourceVariable(iResourceVariables, $log, Shoji) {
                function isUrl(str) {
                    return str && str[0] === "/" || str.indexOf("http") > -1;
                }
                function assertQuery(q) {
                    if (!q || !q.variableId) {
                        throw new Error("iResourceVariable requires `variableId` parameter");
                    }
                    return q;
                }
                return function execute(q) {
                    if (q.variableId && isUrl(q.variableId)) {
                        return Shoji(q.variableId).map();
                    }
                    q = assertQuery(q);
                    $log.debug("iResourceVariable", "fetching", q);
                    return iResourceVariables(q).then(function(variables) {
                        return variables.index.first().map();
                    });
                };
            }
            IResourceVariable.$inject = [ "iResourceVariables", "$log", "Shoji" ];
            return IResourceVariable;
        }.call(this);
    }, {} ],
    202: [ function(require, module, exports) {
        module.exports = function() {
            "use strict";
            function IResourceVariables(iResourceDataset) {
                function assertQuery(q) {
                    if (q && (q.variableAlias || q.variableId)) {
                        var result = {};
                        if (!!q.variableAlias) {
                            result.alias = q.variableAlias;
                        }
                        if (!!q.variableId) {
                            var id = q.variableId;
                            if (id[id.length - 1] === "/") {
                                id = id.substring(id, id.length - 1);
                            }
                            result.id = id;
                        }
                        return result;
                    }
                    return undefined;
                }
                return function execute(q) {
                    var params = assertQuery(q);
                    return iResourceDataset(q).then(function(dataset) {
                        return dataset.urls.variables.map({
                            params: params
                        });
                    });
                };
            }
            IResourceVariables.$inject = [ "iResourceDataset" ];
            return IResourceVariables;
        }.call(this);
    }, {} ],
    203: [ function(require, module, exports) {
        "use strict";
        module.exports = buildModule;
        function buildModule(moduleName, cfg) {
            var angular = require("angular"), _ = require("lodash");
            var defaultCfg = {
                cacheable: false
            };
            cfg = _.extend({}, defaultCfg, cfg);
            var mod = angular.module(moduleName || "resources", []);
            mod.factory("iResourceUser", require("./i-resource-user"));
            mod.factory("iResourceUsers", require("./i-resource-users"));
            mod.factory("iResourceAccount", require("./i-resource-account"));
            mod.factory("iResourceDatasets", require("./i-resource-datasets"));
            mod.factory("iResourceDataset", require("./i-resource-dataset"));
            mod.factory("iResourceVariables", require("./i-resource-variables"));
            mod.factory("iResourceVariable", require("./i-resource-variable"));
            mod.factory("iResourceBatches", require("./i-resource-batches"));
            mod.factory("iResourceBatch", require("./i-resource-batch"));
            mod.factory("iResourceSource", require("./i-resource-source"));
            return mod;
        }
    }, {
        "./i-resource-account": 193,
        "./i-resource-batch": 194,
        "./i-resource-batches": 195,
        "./i-resource-dataset": 196,
        "./i-resource-datasets": 197,
        "./i-resource-source": 198,
        "./i-resource-user": 199,
        "./i-resource-users": 200,
        "./i-resource-variable": 201,
        "./i-resource-variables": 202,
        angular: "angular",
        lodash: 77
    } ],
    204: [ function(require, module, exports) {
        "use strict";
        module.exports = function buildModule(moduleName, cfg) {
            var angular = require("angular"), _ = require("lodash");
            moduleName = moduleName || "shoji";
            var defaults = {
                offline: false
            };
            cfg = _.extend({}, defaults, cfg);
            var shoji = angular.module(moduleName, []);
            shoji.constant("SHOJI_CFG", cfg);
            shoji.factory("lodash", function() {
                return _;
            });
            shoji.factory("url", function() {
                return require("url");
            });
            shoji.provider("shojiDataStrategy", require("./shoji-http-data-strategy"));
            shoji.factory("Shoji", require("./shoji-resource-factory"));
            shoji.factory("shojiParser", require("./shoji-parser"));
            shoji.factory("shojiSerializer", require("./shoji-serializer"));
            shoji.factory("ShojiCollection", require("./shoji-collection-factory"));
            shoji.factory("ShojiCatalogIndex", require("./shoji-catalog-index"));
            shoji.factory("ShojiTuple", require("./shoji-tuple"));
            return shoji;
        };
    }, {
        "./shoji-catalog-index": 205,
        "./shoji-collection-factory": 206,
        "./shoji-http-data-strategy": 207,
        "./shoji-parser": 208,
        "./shoji-resource-factory": 209,
        "./shoji-serializer": 210,
        "./shoji-tuple": 211,
        angular: "angular",
        lodash: 77,
        url: 11
    } ],
    205: [ function(require, module, exports) {
        "use strict";
        module.exports = ShojiCatalogIndexFactory;
        ShojiCatalogIndexFactory.$inject = [ "lodash", "ShojiTuple", "$q" ];
        function ShojiCatalogIndexFactory(_, ShojiTuple, $q) {
            function assert(pred, msg) {
                if (!pred) {
                    throw new Error(msg);
                }
            }
            function ShojiCatalogIndex() {
                Object.defineProperty(this, "keys", {
                    writable: true,
                    configurable: false,
                    enumerable: false,
                    value: []
                });
                Object.defineProperty(this, "length", {
                    writable: true,
                    configurable: false,
                    enumerable: false,
                    value: 0
                });
                this.tuple = this.tuple.bind(this);
            }
            ShojiCatalogIndex.create = function(context, data) {
                assert(context, "context is required");
                assert(context.chain, "context must expose a `chain` method");
                var index = new ShojiCatalogIndex();
                data = data || {};
                Object.keys(data).forEach(function(k) {
                    index.tuple(k, data[k], context);
                });
                return index;
            };
            ShojiCatalogIndex.prototype.mapResources = function() {
                var promises = this.keys.map(function(key) {
                    return this.tuple(key).map();
                }, this);
                return $q.all(promises);
            };
            ShojiCatalogIndex.prototype.first = function() {
                if (this.keys.length > 1) {
                    throw new Error("you cannot meaningfully call `first` on an index with more than one tuple");
                }
                return this.tuple(this.keys[0]);
            };
            ShojiCatalogIndex.prototype.tuple = function(key, data, context) {
                if (!data && !context) {
                    return this[key];
                }
                this.keys.push(key);
                this.length = this.keys.length;
                this[key] = ShojiTuple.create(context, key, data);
                return this[key];
            };
            ShojiCatalogIndex.prototype.forEach = function(fn, ctx) {
                this.keys.forEach(function(k) {
                    var tuple = this.tuple(k);
                    fn.apply(ctx || this, [ tuple, k ]);
                }, this);
            };
            ShojiCatalogIndex.prototype.toObject = function() {
                var json = {};
                this.keys.forEach(function(k) {
                    json[k] = this.tuple(k).memento;
                    json[k].self = k;
                }, this);
                return json;
            };
            return ShojiCatalogIndex;
        }
    }, {} ],
    206: [ function(require, module, exports) {
        "use strict";
        module.exports = ShojiCollectionFactory;
        ShojiCollectionFactory.$inject = [ "$q", "lodash", "$log" ];
        function ShojiCollectionFactory($q, _, $log) {
            $log = $log || console;
            function noop() {}
            function saneKey(key) {
                if (_.isString(key)) {
                    return key.replace("_url", "");
                }
                return key;
            }
            function ShojiCollection() {
                Object.defineProperty(this, "_collection", {
                    value: {},
                    writable: true,
                    enumerable: false,
                    configurable: true
                });
                Object.defineProperty(this, "clientId", {
                    value: _.uniqueId("shoji_"),
                    writable: false,
                    enumerable: false,
                    configurable: false
                });
                Object.defineProperty(this, "keys", {
                    value: [],
                    writable: true,
                    enumerable: false,
                    configurable: true
                });
                Object.defineProperty(this, "length", {
                    value: 0,
                    writable: true,
                    enumerable: false,
                    configurable: false
                });
            }
            ShojiCollection.parse = function(target, src) {
                var coll = new ShojiCollection();
                _.each(src || [], function(url, key) {
                    return coll.add(key, target.chain(url));
                }, coll);
                return coll;
            };
            ShojiCollection.collect = function(seed) {
                var coll = new ShojiCollection();
                _.each(seed || [], function(res, key) {
                    return coll.add(key, res);
                }, coll);
                return coll;
            };
            ShojiCollection.prototype.add = function(key, res) {
                var sane = saneKey(key);
                this.keys.push(sane);
                Object.defineProperty(this, sane, {
                    value: res,
                    writable: false,
                    enumerable: true,
                    configurable: true
                });
                this._collection[key] = res;
                this.length = _.size(this._collection);
                return res;
            };
            ShojiCollection.prototype.accept = function(visitor) {
                this.forEach(function(res) {
                    res.accept(visitor);
                });
            };
            ShojiCollection.prototype.clear = function() {
                _.each(this.keys, function(key) {
                    delete this[key];
                }, this);
            };
            ShojiCollection.prototype.equals = function(other) {
                return other.clientId && other.clientId === this.clientId;
            };
            ShojiCollection.prototype.reduce = function(fn, accumulator, ctx) {
                fn = fn || _.identity;
                accumulator = accumulator || [];
                ctx = ctx || this;
                return _.reduce(this._collection, fn, accumulator, ctx);
            };
            ShojiCollection.prototype.filter = function(fn) {
                fn = fn || _.identity;
                var coll = new ShojiCollection();
                this.forEach(function(res, key) {
                    if (fn(res)) {
                        coll.add(key, res);
                    }
                });
                return coll;
            };
            ShojiCollection.prototype.forEach = function(fn, ctx) {
                fn = fn || noop;
                ctx = ctx || this;
                return _.each(this.keys, function(key) {
                    return fn.apply(ctx, [ this[key], key ]);
                }, this);
            };
            ShojiCollection.prototype.map = function(mapFn, ctx) {
                var self = this;
                mapFn = mapFn || _.identity;
                ctx = ctx || this;
                var all = _.map(this._collection, function(item, key) {
                    return item.map().then(function(it) {
                        var xform = mapFn.apply(ctx, [ it ]);
                        Object.defineProperty(self, saneKey(key), {
                            value: xform,
                            writable: false,
                            enumerable: true,
                            configurable: false
                        });
                        self._collection[key] = xform;
                        return xform;
                    });
                }, this);
                return $q.all(all).then(function(results) {
                    return self;
                });
            };
            ShojiCollection.prototype.toArray = function() {
                return _.toArray(this._collection);
            };
            ShojiCollection.prototype.reject = function(fn) {
                fn = fn || _.identity;
                var coll = new ShojiCollection();
                this.forEach(function(res, key) {
                    if (!fn(res)) {
                        coll.add(key, res);
                    }
                });
                return coll;
            };
            ShojiCollection.prototype.toString = function() {
                return "ShojiCollection " + this.clientId + " ; Length: " + this.length + " ; Keys: " + this.keys;
            };
            return ShojiCollection;
        }
    }, {} ],
    207: [ function(require, module, exports) {
        "use strict";
        module.exports = {
            $get: ShojiHttpDataStrategy,
            mount: ShojiHttpDataStrategy.mount
        };
        ShojiHttpDataStrategy.$inject = [ "lodash", "$q", "$http", "$log", "SHOJI_CFG" ];
        function ShojiHttpDataStrategy(_, $q, $http, $log, SHOJI_CFG) {
            function noop() {}
            function errorPassthru(err) {
                return $q.reject(err);
            }
            function passthru(response) {
                return response;
            }
            function Strategy(url, storage) {
                var appliedResponseFilters = [], internalApi, methods = [ "DELETE", "GET", "POST", "PUT", "PATCH" ], requestCount = 0, storage = storage || $http, strategy = this;
                if (!url) {
                    throw new Error("url is required for data strategy");
                }
                function buildDefaultResponseFilters(opts) {
                    function buildRestrictFilter() {
                        return function restrictFilter(response) {
                            var allow = response.headers("ALLOW") || "";
                            restrictMethods(allow);
                            return response;
                        };
                    }
                    function buildPostDeleteFilter() {
                        return function postDeleteFilter(response) {
                            if (!response || !response.config || !response.config.method) {
                                return response;
                            }
                            var meth = response.config.method;
                            if (meth === "DELETE") {
                                markDeleted();
                            }
                            return response;
                        };
                    }
                    var filters = [];
                    filters.push(buildRestrictFilter());
                    filters.push(buildPostDeleteFilter());
                    return filters;
                }
                function buildInternalApi() {
                    var api = {};
                    var defaultOpts = {
                        sync: true
                    };
                    _.each(methods, function(meth) {
                        var request = new Request({
                            method: meth
                        });
                        request.responseFilters(buildDefaultResponseFilters(defaultOpts));
                        this[meth] = request;
                    }, api);
                    return api;
                }
                function buildPublicApi(target) {
                    target = target || {};
                    internalApi = internalApi || buildInternalApi();
                    _.each(methods, function(meth) {
                        var self = this;
                        this[meth.toLowerCase()] = function() {
                            var execute = internalApi[meth].execute;
                            return execute.apply(self, arguments);
                        };
                    }, target);
                    return target;
                }
                function markDeleted() {
                    _.each(methods, function(meth) {
                        this[meth].markDeleted();
                    }, internalApi);
                    return internalApi;
                }
                function addNoCacheHeader(config) {
                    var headers;
                    if (!config) {
                        return;
                    }
                    headers = config.headers = config.headers || {};
                    headers["Cache-Control"] = "no-cache";
                    return config;
                }
                function restrictMethods(allow) {
                    var api = internalApi;
                    allow = allow || "";
                    var allows = _(allow.split(",")).map(function(s) {
                        return s.replace(/\s/g, "");
                    });
                    _.each(methods, function(meth) {
                        if (!~allows.indexOf(meth) && meth !== "GET") {
                            this[meth].restrict();
                        } else {
                            this[meth].allow();
                        }
                    }, api);
                    return api;
                }
                function Request(cfg) {
                    var method = cfg.method, responseFilters = [], request = this, validateRequest = noop;
                    if (!method) {
                        throw new Error("method is required");
                    }
                    function applyFilters(promise, filters) {
                        filters = filters || [];
                        _.each(filters, function(filter) {
                            var errorHandler, successHandler;
                            if (_.isFunction(filter)) {
                                errorHandler = errorPassthru;
                                successHandler = filter;
                            } else if (_.isObject(filter) && filter.error) {
                                errorHandler = filter.error || errorPassthru;
                                successHandler = filter.success || passthru;
                            }
                            promise = promise.then(successHandler, errorHandler);
                        });
                        return promise;
                    }
                    function isDiscovering() {
                        return !requestCount && method === "GET";
                    }
                    this.allow = function() {
                        this.validate = validateRequest = function(args) {
                            if (!args.url) {
                                throw new Error("url is required");
                            }
                            if (args.method.toLowerCase() === "post" || args.method.toLowerCase() === "put" || args.method.toLowerCase() === "patch") {
                                if (args.data) {
                                    return;
                                }
                                $log.warn("attempting to " + args.method + " to url " + args.url + " has no `data` attribute." + "This seems odd.");
                            }
                        };
                    };
                    this.markDeleted = function() {
                        this.validate = validateRequest = function() {
                            throw new Error("Resource at " + url + " has been DELETED");
                        };
                    };
                    this.restrict = function() {
                        this.validate = validateRequest = function(args) {
                            if (isDiscovering()) {
                                return;
                            }
                            var err = new Error("Method '" + method + "' not permitted on \"" + url + '" The resource may not have been synced to the server;' + " or, the allow header has indicated it is prohibited.");
                            throw err;
                        };
                    };
                    this.responseFilters = function(filters) {
                        if (_.isUndefined(filters)) {
                            return responseFilters;
                        }
                        responseFilters = filters || [];
                        return this;
                    };
                    this.execute = function(cfg, success, error) {
                        $log.debug("shoji-http-data-strategy" + " executing request number " + requestCount + " on " + url + " with method " + method);
                        if (_.isFunction(cfg)) {
                            error = success;
                            success = cfg;
                            cfg = {};
                        }
                        cfg = cfg || {};
                        cfg.url = url;
                        if (cfg.noCache) {
                            cfg = addNoCacheHeader(cfg);
                        }
                        success = success || passthru;
                        error = error || errorPassthru;
                        cfg.method = method;
                        validateRequest(cfg);
                        var result = strategy.makeRequest(cfg);
                        requestCount++;
                        var filters = responseFilters.concat(cfg.responseFilters || []);
                        result = applyFilters(result, filters);
                        return result.then(success, error);
                    };
                    this.restrict();
                }
                this.allowAll = function() {
                    return restrictMethods(methods.join(", "));
                };
                this.initialize = function(opts) {
                    var responseFilters = [];
                    var defaultOpts = {
                        responseFilters: []
                    };
                    opts = _.extend(defaultOpts, opts);
                    var responseFilters = buildDefaultResponseFilters(opts).concat(opts.responseFilters || []);
                    _.each(internalApi, function(request, meth) {
                        request.responseFilters(responseFilters);
                    });
                    return this;
                };
                this.makeRequest = function(cfg) {
                    return storage(cfg);
                };
                this.restrictAll = function() {
                    return restrictMethods();
                };
                buildPublicApi(this);
            }
            return Strategy;
        }
        ShojiHttpDataStrategy.mount = function() {
            throw new Error("not supported for http strategy");
        };
    }, {} ],
    208: [ function(require, module, exports) {
        "use strict";
        module.exports = ShojiParser;
        ShojiParser.$inject = [ "lodash", "ShojiCollection", "ShojiCatalogIndex", "$log" ];
        function ShojiParser(_, ShojiCollection, ShojiCatalogIndex, $log) {
            function deprecateEntitiesSupport(on) {
                Object.defineProperty(on, "entities", {
                    configurable: true,
                    enumerable: false,
                    get: function() {
                        var msg = "DEPRECATED: `entities` is no longer supported. You need to use `index` instead. \n" + "You received this error because you attempted to access `entities` on a shoji resource at :\n" + '"' + on.self + '"';
                        throw new Error(msg);
                    }
                });
            }
            function Parser() {
                var self = this;
                var extend = _.extend;
                this.isShoji = function(data) {
                    data = data || {};
                    var knownShojiElements = [ "shoji:entity", "shoji:catalog", "shoji:value", "shoji:view", "shoji:order" ];
                    var is = !!(data.element && knownShojiElements.indexOf(data.element) > -1) && !!data.self;
                    return is;
                };
                this.validate = function(data, context) {
                    data = data || {};
                    var element = data.element;
                    if (self.isShoji(data)) {
                        switch (element) {
                          case "shoji:catalog":
                            if (!_.isUndefined(data.entities) && !_.isArray(data.entities)) {
                                throw new Error("catalog entities must be an Array");
                            }
                            if (!_.isUndefined(data.index) && !_.isObject(data.index)) {
                                throw new Error("catalog index must be an Object");
                            }
                            break;

                          case "shoji:entity":
                            if (!_.isUndefined(data.urls) && !_.isObject(data.urls)) {
                                throw new Error("entity urls must be an Object");
                            }
                            break;

                          case "shoji:view":
                            if (!data.hasOwnProperty("value")) {
                                throw new Error("shoji:view expects an `value` property");
                            }
                        }
                    }
                    return data;
                };
                this.parse = function(data, context) {
                    var target = context || {};
                    data = self.validate(data);
                    target.self = data.self || target.self;
                    if (self.isShoji(data)) {
                        target.element = data.element;
                    } else {
                        target.element = "shoji:value";
                    }
                    target.specification = data.specification ? target.chain(data.specification) : null;
                    switch (target.element) {
                      case "shoji:catalog":
                        deprecateEntitiesSupport(target);
                        target.index = ShojiCatalogIndex.create(target, data.index);
                        target.views = ShojiCollection.parse(target, data.views);
                        target.urls = ShojiCollection.parse(target, data.urls);
                        target.orders = ShojiCollection.parse(target, data.orders);
                        target.catalogs = ShojiCollection.parse(target, data.catalogs);
                        break;

                      case "shoji:entity":
                        extend(target, data.body || {});
                        var col = ShojiCollection.parse(target, data.urls);
                        target.urls = col;
                        target.fragments = ShojiCollection.parse(target, data.fragments);
                        target.views = ShojiCollection.parse(target, data.views);
                        target.catalogs = ShojiCollection.parse(target, data.catalogs);
                        break;

                      case "shoji:view":
                        target.value = data.value;
                        break;

                      case "shoji:value":
                        target.value = data;
                        break;

                      case "shoji:order":
                        target.graph = data.graph;
                        break;

                      default:
                        throw new Error("unknown element type " + target.element);
                    }
                    return target;
                };
            }
            return new Parser().parse;
        }
    }, {} ],
    209: [ function(require, module, exports) {
        "use strict";
        module.exports = ShojiResourceService;
        ShojiResourceService.$inject = [ "$q", "lodash", "shojiDataStrategy", "shojiParser", "ShojiCollection", "$log" ];
        function ShojiResourceService($q, _, DataStrategy, parse, ShojiCollection, $log) {
            var noop = angular.noop, errorPassthru = function(err) {
                return $q.reject(err);
            }, passthru = function(arg) {
                return arg;
            };
            function buildPostSyncFilter(target, opts) {
                var self = target;
                return function postSyncFilter(response) {
                    var config = response.config || {};
                    if (!_.isUndefined(config.sync) && !!!config.sync || !opts.sync) {
                        return response;
                    }
                    var meth = config.method;
                    if (meth === "POST" && response.headers && response.headers("Location")) {
                        var newUri = response.headers("Location");
                        return $q.when(self.chain(newUri));
                    }
                    if (meth === "PUT" || meth === "PATCH") {
                        $log.debug("shoji-resource-factory syncing to server", self.self);
                        return self.get();
                    }
                    return response;
                };
                return _.bind(postSyncFilter, target);
            }
            function buildDefaultFilters(target) {
                var self = target;
                var filters = [];
                if (self.sync) {
                    filters.push(_.bind(self.sync, self));
                }
                filters.push(buildPostSyncFilter(target, {
                    sync: !!self.sync
                }));
                function mapToResource(response) {
                    if (response instanceof Resource || !!response.self) {
                        return response;
                    }
                    return self;
                }
                filters.push(_.bind(mapToResource, self));
                return filters;
            }
            function Resource(url) {
                if (!(this instanceof Resource)) {
                    return new Resource();
                }
                this.self = url;
                this.clientId = _.uniqueId("shoji_");
                this.reset = noop;
                this.timestamp = new Date();
                this.syncedOn = false;
                this.element = "unknown";
                this.specification = null;
                var filters = buildDefaultFilters(this);
                this.dataStrategy = new DataStrategy(this.self);
                this.dataStrategy.initialize({
                    sync: true,
                    responseFilters: filters
                });
                this.get = this.dataStrategy.get;
                this.save = this.dataStrategy.post;
                this.update = this.dataStrategy.put;
                this.patch = this.dataStrategy.patch;
                this["delete"] = this.dataStrategy["delete"];
            }
            Resource.prototype.accept = function(visitor) {
                visitor.visitResource(this);
            };
            Resource.prototype.chain = function(chained) {
                var resource = new Resource(chained);
                if (!chained) {
                    throw new Error("url cannot be empty");
                }
                resource = new Resource(chained);
                resource.allowAll();
                return resource;
            };
            Resource.prototype.allowAll = function() {
                this.dataStrategy.allowAll();
            };
            Resource.prototype.attach = function(path, as, cfg) {
                var self = this;
                as = as || path;
                cfg = cfg || {};
                if (!this.urls || !this.urls[path]) {
                    throw new Error("Path `" + path + "` not found from `" + this.self + "`");
                }
                if (this[as]) {
                    throw new Error("Property " + "`" + as + "` is already attached to " + "`" + this.self + "`.");
                }
                return this.urls[path].map(cfg, function(res) {
                    self[as] = res;
                    return self;
                });
            };
            Resource.prototype.collect = shojiResourceFactory.collect;
            Resource.prototype.reduce = function(cfg, accumulator, handlers) {
                var resource = this;
                if (_.isArray(accumulator)) {
                    handlers = accumulator;
                    accumulator = cfg;
                    cfg = {};
                } else if (_.isArray(cfg)) {
                    handlers = cfg;
                    accumulator = resource;
                    cfg = {};
                }
                function passthru(acc) {
                    return acc;
                }
                handlers = handlers || [ passthru ];
                var outer = $q.defer();
                handlers = _.map(handlers, function(h) {
                    return _.partial(_.bind(h, accumulator), accumulator);
                });
                try {
                    var inner = $q.when(handlers[0](resource));
                    _.each(_.rest(handlers), function(h) {
                        inner = inner.then(h);
                    });
                    inner.then(outer.resolve, outer.reject);
                } catch (err) {
                    $log.error(err);
                    $q.reject(err).then(outer.resolve, outer.reject);
                }
                return outer.promise;
            };
            Resource.prototype.map = function(cfg, success, error) {
                var resource = this;
                if (_.isFunction(cfg)) {
                    error = success;
                    success = cfg;
                    cfg = {};
                }
                cfg = cfg || {};
                success = success || passthru;
                error = error || errorPassthru;
                var outer = $q.defer();
                var resolve = outer.resolve;
                outer.resolve = function(obj) {
                    return resolve.apply(resource, [ obj ]);
                };
                function disableLoad(res) {
                    try {
                        var col = res.urls || res.index;
                        if (!col || !col.disableLoad) {
                            return;
                        }
                        return col.disableLoad();
                    } catch (err) {
                        $log.error(err);
                        throw err;
                    }
                }
                try {
                    resource.get(cfg).then(function(res) {
                        try {
                            disableLoad(res);
                            var val = success(res);
                            if (_.isUndefined(val)) {
                                var msg = "`Resource.map` must return a value from all nested promises.\n" + "This function is failing to do so: " + success.toString();
                                throw new Error(msg);
                            }
                            if (val && val.then) {
                                return val.then(outer.resolve, outer.reject);
                            }
                            return $q.when(val).then(outer.resolve, outer.reject);
                        } catch (err) {
                            $log.error(err);
                            return $q.reject(err).then(outer.resolve, outer.reject);
                        }
                    }, function(err) {
                        return $q.reject(err).then(outer.resolve, outer.reject);
                    });
                } catch (err) {
                    $q.reject(err).then(outer.resolve, outer.reject);
                }
                return outer.promise;
            };
            Resource.prototype.parse = function(data) {
                this.reset();
                parse(data, this);
                this.setupNextReset({
                    data: data
                });
                this._memento = data;
                return this;
            };
            Resource.prototype.setupNextReset = function(response) {
                var target = this;
                this.reset = function executeReset() {
                    var data = response.data, body = data.body || {};
                    delete target.specification;
                    switch (target.element) {
                      case "shoji:entity":
                        for (var k in body) {
                            delete target[k];
                        }
                        delete target.urls;
                        break;

                      case "shoji:catalog":
                        delete target.index;
                        delete target.views;
                        break;

                      case "shoji:value":
                        delete target.value;
                        break;

                      case "shoji:view":
                        delete target.value;
                        break;
                    }
                    return target;
                };
                return target;
            };
            Resource.prototype.getMemento = function() {
                return this._memento;
            };
            Resource.prototype.sync = function(response) {
                var self = this;
                if (response && response.config && response.config.method.toUpperCase() === "GET") {
                    this.syncedOn = new Date();
                    self.parse(response.data, self);
                }
                return response;
            };
            function shojiResourceFactory(url) {
                var resource;
                if (!url) {
                    throw new Error("url is required for a resource");
                }
                resource = new Resource(url);
                resource.allowAll();
                return resource;
            }
            shojiResourceFactory.collect = function(responses) {
                var shojis = _.map(responses, function(r) {
                    return shojiResourceFactory(r.self).parse(r);
                });
                return ShojiCollection.collect(shojis);
            };
            return shojiResourceFactory;
        }
    }, {} ],
    210: [ function(require, module, exports) {
        module.exports = function() {
            "use strict";
            function ShojiSerializer(parse, Shoji) {
                return {
                    serialize: function(it) {
                        var obj = it.getMemento();
                        obj.__serializer = it.__serializer;
                        return JSON.stringify(obj);
                    },
                    deserialize: function(str) {
                        var parsed = JSON.parse(str);
                        return Shoji(parsed.self).parse(parsed);
                    }
                };
            }
            ShojiSerializer.$inject = [ "shojiParser", "Shoji" ];
            return ShojiSerializer;
        }.call(this);
    }, {} ],
    211: [ function(require, module, exports) {
        "use strict";
        var _ = require("lodash");
        module.exports = ShojiTupleFactory;
        ShojiTupleFactory.$inject = [ "url" ];
        function ShojiTupleFactory(url) {
            function extend(data, instance) {
                var payload = _.cloneDeep(data);
                _.extend(instance, payload);
                return instance;
            }
            function ShojiTuple(target, data) {
                this.target = target;
                this.self = target.self;
                this.clientId = _.uniqueId("shoji_");
                this.memento = data || {};
                extend(data, this);
            }
            ShojiTuple.create = function(context, key, data) {
                if (!context.chain) {
                    throw new Error("context expects a `chain` method for traversal ops");
                }
                var self = url.resolve(context.self, key);
                var target = context.chain(self);
                return new ShojiTuple(target, data);
            };
            ShojiTuple.prototype.map = function delegate() {
                var args = [].slice.call(arguments), target = this.target;
                target.self = this.self;
                var resource = target.map.apply(target, args);
                return resource;
            };
            return ShojiTuple;
        }
    }, {
        lodash: 77
    } ],
    212: [ function(require, module, exports) {
        "use strict";
        module.exports = buildModule;
        function buildModule(moduleName) {
            var angular = require("angular");
            var mod = angular.module(moduleName || "start-from", []);
            mod.filter("startFrom", require("./start-from-filter"));
            return mod;
        }
    }, {
        "./start-from-filter": 213,
        angular: "angular"
    } ],
    213: [ function(require, module, exports) {
        "use strict";
        module.exports = StartFromFilter;
        StartFromFilter.$inject = [];
        function StartFromFilter() {
            return function filter(arr, start) {
                arr = arr || [];
                start = start || 0;
                return arr.slice(start);
            };
        }
    }, {} ],
    214: [ function(require, module, exports) {
        "use strict";
        module.exports = buildModule;
        function buildModule(moduleName) {
            var angular = require("angular");
            var mod = angular.module(moduleName || "traversable", []);
            mod.factory("Traversable", require("./traversable"));
            return mod;
        }
    }, {
        "./traversable": 215,
        angular: "angular"
    } ],
    215: [ function(require, module, exports) {
        "use strict";
        module.exports = TraversableFactory;
        TraversableFactory.$inject = [];
        function TraversableFactory(_) {
            function isFunction(functionToCheck) {
                var getType = {};
                return functionToCheck && getType.toString.call(functionToCheck) === "[object Function]";
            }
            function Traversable(cfg) {
                cfg = cfg || {};
                if (!cfg.pageLength) {
                    throw new Error("page length is required. use `1` to apply one-at-a time.");
                }
                this._cfg = cfg;
                this.incrementable = false;
                this.decrementable = false;
                this.max = cfg.max || 0;
                this.pageLength = cfg.pageLength;
                this.page = 0;
                this.pages = 0;
                this.startFrom = 0;
                if (this.pageLength === 1) {
                    this.pctOverlap = 1;
                } else {
                    this.pctOverlap = cfg.pctOverlap || .5;
                }
            }
            Traversable.prototype._updateTraversal = function() {
                this.decrementable = this.page > 0;
                this.incrementable = this.pages > 1 && this.page < this.pages - 1;
                this.startFrom = this.page * Math.floor(this.pageLength * this.pctOverlap);
            };
            Traversable.prototype._calcPages = function(max, pageLength, overlap) {
                var targetOverlap = max <= pageLength ? 1 : overlap;
                var batch = Math.floor(pageLength * targetOverlap);
                var pages = Math.ceil(max / batch);
                return pages;
            };
            Traversable.prototype.inc = function() {
                if (this.page === this.pages - 1) {
                    return;
                }
                this.page = this.page + 1;
                this._updateTraversal();
            };
            Traversable.prototype.dec = function() {
                if (this.page < 1) {
                    return;
                }
                this.page = this.page - 1;
                this._updateTraversal();
            };
            Traversable.prototype.openAt = function(page) {
                page = parseInt(page, 10);
                if (page > this.pages || page < 0) {
                    page = 0;
                }
                this.page = page;
                this._updateTraversal();
            };
            Traversable.prototype.itemCountAt = function(pageNumber) {
                pageNumber = parseInt(pageNumber, 10) || 0;
                if (pageNumber === this.pages - 1) {
                    return this.max - pageNumber * this.pageLength;
                }
                return Math.min(this.pageLength, this.max);
            };
            Traversable.prototype.interpret = function(traversable, listProperty) {
                var list = traversable[listProperty];
                if (!list) {
                    throw new Error("property " + listProperty + " not found on traversable");
                }
                this.max = this.max || list.length;
                this.single = list.length === 1;
                this.pages = this._calcPages(this.max, this.pageLength, this.pctOverlap);
                this.page = 0;
                this._updateTraversal();
                return this;
            };
            Traversable.prototype.retraversable = function() {
                var args = [].slice.call(arguments);
                this.max = this._cfg.max || 0;
                var current = {
                    page: this.page,
                    startFrom: this.startFrom
                };
                Traversable.prototype.interpret.apply(this, args);
                if (this.pages - 1 >= current.page) {
                    this.page = current.page;
                    this.startFrom = current.startFrom;
                    this._updateTraversal();
                }
                return this;
            };
            Traversable.prototype.augment = function(traversable, listProperty) {
                var args = [].slice.call(arguments);
                var self = Traversable.prototype.interpret.apply(this, args);
                var funcs = [];
                for (var k in self) {
                    var prop = self[k];
                    var funcy = isFunction(self[k]);
                    if (funcy) {
                        prop = prop.bind(traversable);
                    }
                    Object.defineProperty(traversable, k, {
                        value: prop,
                        writable: true,
                        configurable: false,
                        enumerable: true
                    });
                }
                return traversable;
            };
            return Traversable;
        }
    }, {} ],
    216: [ function(require, module, exports) {
        "use strict";
        module.exports = BehavioralVariableDirective;
        BehavioralVariableDirective.$inject = [ "$compile" ];
        function BehavioralVariableDirective($compile) {
            return {
                restrict: "C",
                scope: {
                    behavioral: "=variable"
                },
                replace: true,
                templateUrl: "/variables-accordion/behavioral-variable.html",
                link: function(scope, el, attrs) {
                    var BASIC_PADDING = 15, level, padding, behavioral = scope.behavioral;
                    padding = (behavioral.level - 1) * BASIC_PADDING;
                    function setPaddingLeft(el, padding) {
                        el.css({
                            paddingLeft: padding
                        });
                    }
                    setPaddingLeft(el, padding);
                    function setPaddingToBehavioralObject() {
                        setPaddingLeft(el, 0);
                        setPaddingLeft(el.find(".variable-button"), padding);
                    }
                    scope.$watch("behavioral.behaviors.strategy", function() {
                        setPaddingToBehavioralObject();
                    });
                }
            };
        }
    }, {} ],
    217: [ function(require, module, exports) {
        "use strict";
        module.exports = CompositeVariableDirective;
        CompositeVariableDirective.$inject = [];
        function CompositeVariableDirective() {
            return {
                restrict: "CE",
                templateUrl: "/variables-accordion/composite-variable.html",
                replace: true,
                scope: true,
                link: function(scope, el, attrs) {
                    scope.$watch("variable", function(variable) {
                        if (!variable) {
                            return;
                        }
                        var elm = el[0];
                        var header = elm.querySelector(".composite-header");
                        if (variable.behaviors.linkable) {
                            header.setAttribute("dragit", "variable");
                            header.setAttribute("dragit-operation", "link");
                        }
                    });
                }
            };
        }
    }, {} ],
    218: [ function(require, module, exports) {
        "use strict";
        module.exports = [ function DisplayHeaderFilter() {
            return function(group) {
                if (!group.collapsable) {
                    return !!!group.ungrouped;
                }
                return true;
            };
        } ];
    }, {} ],
    219: [ function(require, module, exports) {
        "use strict";
        module.exports = HierarchicalGroupDirective;
        HierarchicalGroupDirective.$inject = [];
        function HierarchicalGroupDirective() {
            return {
                restrict: "AC",
                templateUrl: "/variables-accordion/hierarchical-group.html",
                scope: true,
                replace: true,
                link: function(scope, el, attrs) {}
            };
        }
    }, {} ],
    220: [ function(require, module, exports) {
        "use strict";
        module.exports = HierarchicalItemDirective;
        HierarchicalItemDirective.$inject = [ "$compile" ];
        function HierarchicalItemDirective($compile) {
            return {
                restrict: "C",
                scope: true,
                link: function(scope, el, attrs) {
                    var elm = el[0];
                    scope.$watch("item", function(item) {
                        elm.innerHTML = "";
                        var compiled;
                        if (item.alias) {
                            scope.variable = item;
                            compiled = $compile('<div class="hierarchical-variable"></div>')(scope);
                        } else {
                            scope.nestedGroup = item;
                            compiled = $compile('<div class="hierarchical-nested-group"></div>')(scope);
                        }
                        el.replaceWith(compiled[0]);
                    });
                }
            };
        }
    }, {} ],
    221: [ function(require, module, exports) {
        "use strict";
        module.exports = HierarchicalNestedGroupDirective;
        HierarchicalNestedGroupDirective.$inject = [];
        function HierarchicalNestedGroupDirective() {
            return {
                restrict: "C",
                scope: true,
                templateUrl: "/variables-accordion/hierarchical-nested-group.html",
                link: function(scope, el) {
                    var BASIC_PADDING = 15, padding = (scope.nestedGroup.level - 1) * BASIC_PADDING;
                    function setPaddingLeft(el, padding) {
                        el.css({
                            paddingLeft: padding
                        });
                    }
                    setPaddingLeft(el, padding);
                    setTimeout(function() {
                        setPaddingLeft(el, 0);
                        setPaddingLeft(el.find("a"), padding);
                    }, 10);
                }
            };
        }
    }, {} ],
    222: [ function(require, module, exports) {
        "use strict";
        module.exports = HierarchicalTopLevelItemDirective;
        HierarchicalTopLevelItemDirective.$inject = [ "$compile" ];
        function HierarchicalTopLevelItemDirective($compile) {
            return {
                restrict: "C",
                scope: true,
                link: function(scope, el, attrs) {
                    var elm = el[0];
                    scope.$watch("item", function(item) {
                        elm.innerHTML = "";
                        var compiled;
                        if (item.alias) {
                            scope.variable = item;
                            compiled = $compile('<div class="hierarchical-variable"></div>')(scope);
                        } else {
                            scope.group = item;
                            compiled = $compile('<div class="group-item"><div class="hierarchical-group"></div></div>')(scope);
                        }
                        el.replaceWith(compiled[0]);
                    });
                }
            };
        }
    }, {} ],
    223: [ function(require, module, exports) {
        "use strict";
        module.exports = HierarchicalVariableDirective;
        HierarchicalVariableDirective.$inject = [ "$compile" ];
        function HierarchicalVariableDirective($compile) {
            return {
                restrict: "C",
                scope: true,
                link: function(scope, el, attrs) {
                    var elm = el[0];
                    scope.$watch("variable", function(variable) {
                        elm.innerHTML = "";
                        var compiled, type;
                        if (variable.subvariables) {
                            type = "composite";
                            compiled = $compile("<composite-variable></composite-variable>")(scope);
                        } else {
                            compiled = $compile("<scalar-variable></scalar-variable>")(scope);
                            type = "scalar";
                        }
                        elm.classList.add(type);
                        elm.appendChild(compiled[0]);
                    });
                }
            };
        }
    }, {} ],
    224: [ function(require, module, exports) {
        "use strict";
        module.exports = buildModule;
        function buildModule(moduleName) {
            var angular = require("angular");
            var mod = angular.module(moduleName || "variables-accordion", []);
            mod.factory("lodash", function() {
                return require("lodash");
            });
            mod.directive("variablesAccordion", require("./variables-accordion-directive"));
            mod.directive("hierarchicalGroup", require("./hierarchical-group-directive"));
            mod.directive("hierarchicalTopLevelItem", require("./hierarchical-top-level-item-directive"));
            mod.directive("hierarchicalItem", require("./hierarchical-item-directive"));
            mod.directive("hierarchicalNestedGroup", require("./hierarchical-nested-group-directive"));
            mod.directive("hierarchicalVariable", require("./hierarchical-variable-directive"));
            mod.directive("scalarVariable", require("./scalar-variable-directive"));
            mod.directive("compositeVariable", require("./composite-variable-directive"));
            mod.directive("behavioralVariable", require("./behavioral-variable-directive"));
            mod.filter("shouldDisplayHeader", require("./display-header-filter"));
            mod.run(function($templateCache) {
                var fs = require("fs");
                if (fs.readFile) {
                    var fileToTemplateCache = function(key, fn) {
                        fs.readFile(fn, "utf8", function(err, data) {
                            if (err) {
                                return console.log(err);
                            }
                            $log.log("here");
                            console.log("here");
                            console.log(data);
                            $templateCache.put(key, "" + data);
                        });
                    };
                    fileToTemplateCache("/variables-accordion/variables-accordion.html", "./variables-accordion.html");
                    fileToTemplateCache("/variables-accordion/composite-variable.html", "./composite-variable.html");
                    fileToTemplateCache("/variables-accordion/scalar-variable.html", "./scalar-variable.html");
                    fileToTemplateCache("/variables-accordion/hierarchical-nested-group.html", "./hierarchical-nested-group.html");
                }
            });
            return mod;
        }
    }, {
        "./behavioral-variable-directive": 216,
        "./composite-variable-directive": 217,
        "./display-header-filter": 218,
        "./hierarchical-group-directive": 219,
        "./hierarchical-item-directive": 220,
        "./hierarchical-nested-group-directive": 221,
        "./hierarchical-top-level-item-directive": 222,
        "./hierarchical-variable-directive": 223,
        "./scalar-variable-directive": 225,
        "./variables-accordion-directive": 226,
        angular: "angular",
        fs: 2,
        lodash: 77
    } ],
    225: [ function(require, module, exports) {
        "use strict";
        module.exports = ScalarVariableDirective;
        ScalarVariableDirective.$inject = [ "$compile" ];
        function ScalarVariableDirective($compile) {
            return {
                restrict: "CE",
                scope: true,
                templateUrl: "/variables-accordion/scalar-variable.html",
                link: function(scope, el, attrs) {
                    var elm = el[0];
                }
            };
        }
    }, {} ],
    226: [ function(require, module, exports) {
        "use strict";
        module.exports = HierarchicalVariablesListDirective;
        HierarchicalVariablesListDirective.$inject = [];
        function HierarchicalVariablesListDirective() {
            return {
                restrict: "E",
                templateUrl: "/variables-accordion/variables-accordion.html",
                link: function(scope) {
                    var currentHVL;
                    console.log("here1");
                    scope.$watch("hierarchicalVariablesList", function(hvl) {
                        if (hvl === undefined) {
                            return;
                        }
                        refreshRoot(hvl);
                        if (currentHVL !== hvl) {
                            currentHVL = hvl;
                            hvl.on("hvl.refreshed", function() {
                                refreshRoot(hvl);
                            });
                        }
                    });
                    function refreshRoot(hvl) {
                        scope.root = hvl.root;
                    }
                }
            };
        }
    }, {} ],
    "angular-mocks": [ function(require, module, exports) {
        "use strict";
        if (!window.angular) {
            throw new Error("angular not found on the `window` object. Is it included on the page?");
        }
        require("angular");
        module.exports = window.angular.mocks;
    }, {
        angular: "angular"
    } ],
    angular: [ function(require, module, exports) {
        "use strict";
        if (!window.angular) {
            throw new Error("angular not found on the `window` object. Is it included on the page?");
        }
        module.exports = window.angular;
    }, {} ]
}, {}, [ 1 ]);
//# sourceMappingURL=crunch.js.map